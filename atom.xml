<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>天青色等烟雨</title>
  <icon>https://www.gravatar.com/avatar/690a00fbf50ac9aaeed6982cc8330e10</icon>
  <subtitle>而我在等你</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://magiceses.github.io/"/>
  <updated>2021-10-02T07:58:41.111Z</updated>
  <id>https://magiceses.github.io/</id>
  
  <author>
    <name>magiceses</name>
    <email>magiceses0118@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Alertmanager 高可用总结-上</title>
    <link href="https://magiceses.github.io/2020/12/24/prometheus-alertmanager-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%BB%E7%BB%93-%E4%B8%8A/"/>
    <id>https://magiceses.github.io/2020/12/24/prometheus-alertmanager-高可用总结-上/</id>
    <published>2020-12-24T14:25:24.000Z</published>
    <updated>2021-10-02T07:58:41.111Z</updated>
    
    <content type="html"><![CDATA[<p id="div-border-top-green">人生不过如此，且行且珍惜，每一次的失败，都是成功的伏笔；每一次的考验，都有一份收获；每一次的泪水，都有一次醒悟；每一次的磨难，都有生命的财富。<br></p><h2 id="高可用简介"><a href="#高可用简介" class="headerlink" title="高可用简介"></a>高可用简介</h2><p>之前我们主要讨论了Prometheus Server自身的高可用问题。而接下来，重点将放在告警处理也就是Alertmanager部分。如下所示。</p><p><img src="/images/prometheus-alertmanager-0.png" alt="image-20210906110008076"></p><p>为了提升Promthues的服务可用性，通常用户会部署两个或者两个以上的Promthus Server，它们具有完全相同的配置包括Job配置，以及告警配置等。当某一个Prometheus Server发生故障后可以确保Promthues持续可用。</p><a id="more"></a><p>同时基于Alertmanager的告警分组机制即使不同的Prometheus Sever分别发送相同的告警给Alertmanager，Alertmanager也可以自动将这些告警合并为一个通知向receiver发送。</p><p><img src="/images/prometheus-alertmanager-1.png" alt="image-20210906110119996"></p><p>但不幸的是，虽然Alertmanager能够同时处理多个相同的Prometheus Server所产生的告警。但是由于单个Alertmanager的存在，当前的部署结构存在明显的单点故障风险，当Alertmanager单点失效后，告警的后续所有业务全部失效。</p><p>如下所示，最直接的方式，就是尝试部署多套Alertmanager。但是由于Alertmanager之间不存在并不了解彼此的存在，因此则会出现告警通知被不同的Alertmanager重复发送多次的问题。</p><p><img src="/images/prometheus-alertmanager-2.png" alt="image-20210906110143793"></p><p>为了解决这一问题，如下所示。Alertmanager引入了Gossip机制。Gossip机制为多个Alertmanager之间提供了信息传递的机制。确保及时在多个Alertmanager分别接收到相同告警信息的情况下，也只有一个告警通知被发送给Receiver。</p><p><img src="/images/prometheus-alertmanager-3.png" alt="image-20210906110223932"></p><h2 id="Gossip协议"><a href="#Gossip协议" class="headerlink" title="Gossip协议"></a>Gossip协议</h2><p>Gossip protocol 也叫 Epidemic Protocol （流行病协议），实际上它还有很多别名，比如：“流言算法”、“疫情传播算法”等。</p><p>这个协议的作用就像其名字表示的意思一样，非常容易理解，它的方式其实在我们日常生活中也很常见，比如电脑病毒的传播，森林大火，细胞扩散等等。</p><p><strong>这里先简单介绍一下 Gossip 协议的执行过程：</strong></p><p>Gossip 过程是由种子节点发起，当一个种子节点有状态需要更新到网络中的其他节点时，它会随机的选择周围几个节点散播消息，收到消息的节点也会重复该过程，直至最终网络中所有的节点都收到了消息。这个过程可能需要一定的时间，由于不能保证某个时刻所有节点都收到消息，但是理论上最终所有节点都会收到消息，因此它是一个最终一致性协议。</p><p><strong>Gossip 演示</strong></p><p>现在，我们通过一个具体的实例来深入体会一下 Gossip 传播的完整过程</p><p><strong>为了表述清楚，我们先做一些前提设定</strong></p><p>1、Gossip 是周期性的散播消息，把周期限定为 1 秒</p><p>2、被感染节点随机选择 k 个邻接节点（fan-out）散播消息，这里把 fan-out 设置为 3，每次最多往 3 个节点散播。</p><p>3、每次散播消息都选择尚未发送过的节点进行散播</p><p>4、收到消息的节点不再往发送节点散播，比如 A -&gt; B，那么 B 进行散播的时候，不再发给 A。</p><p>注意：Gossip 过程是异步的，也就是说发消息的节点不会关注对方是否收到，即不等待响应；不管对方有没有收到，它都会每隔 1 秒向周围节点发消息。异步是它的优点，而消息冗余则是它的缺点。</p><p>这里一共有 16 个节点，节点 1 为初始被感染节点，通过 Gossip 过程，最终所有节点都被感染：</p><video src="/Users/stark/Pictures/screenshot/gossip.mp4"></video><h3 id="Gossip-的特点（优势）"><a href="#Gossip-的特点（优势）" class="headerlink" title="Gossip 的特点（优势）"></a><strong>Gossip 的特点（优势）</strong></h3><p><strong>1）扩展性</strong></p><p>网络可以允许节点的任意增加和减少，新增加的节点的状态最终会与其他节点一致。</p><p><strong>2）容错</strong></p><p>网络中任何节点的宕机和重启都不会影响 Gossip 消息的传播，Gossip 协议具有天然的分布式系统容错特性。</p><p><strong>3）去中心化</strong></p><p>Gossip 协议不要求任何中心节点，所有节点都可以是对等的，任何一个节点无需知道整个网络状况，只要网络是连通的，任意一个节点就可以把消息散播到全网。</p><p><strong>4）一致性收敛</strong></p><p>Gossip 协议中的消息会以一传十、十传百一样的指数级速度在网络中快速传播，因此系统状态的不一致可以在很快的时间内收敛到一致。消息传播速度达到了 logN。</p><p><strong>5）简单</strong></p><p>Gossip 协议的过程极其简单，实现起来几乎没有太多复杂性。</p><h3 id="Gossip-的缺陷"><a href="#Gossip-的缺陷" class="headerlink" title="Gossip 的缺陷"></a><strong>Gossip 的缺陷</strong></h3><p>分布式网络中，没有一种完美的解决方案，Gossip 协议跟其他协议一样，也有一些不可避免的缺陷，主要是两个：</p><p><strong>1）消息的延迟</strong></p><p>由于 Gossip 协议中，节点只会随机向少数几个节点发送消息，消息最终是通过多个轮次的散播而到达全网的，因此使用 Gossip 协议会造成不可避免的消息延迟。不适合用在对实时性要求较高的场景下。</p><p><strong>2）消息冗余</strong></p><p>Gossip 协议规定，节点会定期随机选择周围节点发送消息，而收到消息的节点也会重复该步骤，因此就不可避免的存在消息重复发送给同一节点的情况，造成了消息的冗余，同时也增加了收到消息的节点的处理压力。而且，由于是定期发送，因此，即使收到了消息的节点还会反复收到重复消息，加重了消息的冗余。</p><h3 id="Gossip-类型"><a href="#Gossip-类型" class="headerlink" title="Gossip 类型"></a><strong>Gossip 类型</strong></h3><p>Gossip 有两种类型：</p><ul><li>Anti-Entropy（反熵）：以固定的概率传播所有的数据</li><li>Rumor-Mongering（谣言传播）：仅传播新到达的数据</li></ul><p>Anti-Entropy 是 SI model，节点只有两种状态，Suspective 和 Infective，叫做 simple epidemics。</p><p>Rumor-Mongering 是 SIR model，节点有三种状态，Suspective，Infective 和 Removed，叫做 complex epidemics。</p><p>其实，Anti-entropy 反熵是一个很奇怪的名词，之所以定义成这样，Jelasity 进行了解释，因为 entropy 是指混乱程度（disorder），而在这种模式下可以消除不同节点中数据的 disorder，因此 Anti-entropy 就是 anti-disorder。换句话说，它可以提高系统中节点之间的 similarity。</p><p>在 SI model 下，一个节点会把所有的数据都跟其他节点共享，以便消除节点之间数据的任何不一致，它可以保证最终、完全的一致。</p><p>由于在 SI model 下消息会不断反复的交换，因此消息数量是非常庞大的，无限制的（unbounded），这对一个系统来说是一个巨大的开销。</p><p>但是在 Rumor Mongering（SIR Model） 模型下，消息可以发送得更频繁，因为消息只包含最新 update，体积更小。而且，一个 Rumor 消息在某个时间点之后会被标记为 removed，并且不再被传播，因此，SIR model 下，系统有一定的概率会不一致。</p><p>而由于，SIR Model 下某个时间点之后消息不再传播，因此消息是有限的，系统开销小。</p><h3 id="Gossip-中的通信模式"><a href="#Gossip-中的通信模式" class="headerlink" title="Gossip 中的通信模式"></a><strong>Gossip 中的通信模式</strong></h3><p>在 Gossip 协议下，网络中两个节点之间有三种通信方式:</p><ul><li>Push: 节点 A 将数据 (key,value,version) 及对应的版本号推送给 B 节点，B 节点更新 A 中比自己新的数据</li><li>Pull：A 仅将数据 key, version 推送给 B，B 将本地比 A 新的数据（Key, value, version）推送给 A，A 更新本地</li><li>Push/Pull：与 Pull 类似，只是多了一步，A 再将本地比 B 新的数据推送给 B，B 则更新本地</li></ul><p>如果把两个节点数据同步一次定义为一个周期，则在一个周期内，Push 需通信 1 次，Pull 需 2 次，Push/Pull 则需 3 次。虽然消息数增加了，但从效果上来讲，Push/Pull 最好，理论上一个周期内可以使两个节点完全一致。直观上，Push/Pull 的收敛速度也是最快的。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h3><p>对于一个节点数为 N 的网络来说，假设每个 Gossip 周期，新感染的节点都能再感染至少一个新节点，那么 Gossip 协议退化成一个二叉树查找，经过 LogN 个周期之后，感染全网，时间开销是 O(LogN)。由于每个周期，每个节点都会至少发出一次消息，因此，消息复杂度（消息数量 = N * N）是 O(N^2) 。注意，这是 Gossip 理论上最优的收敛速度，但是在实际情况中，最优的收敛速度是很难达到的。</p><p>假设某个节点在第 i 个周期被感染的概率为 pi，第 i+1 个周期被感染的概率为 pi+1 ，</p><p>1）则 Pull 的方式:</p><p><img src="/images/prometheus-alertmanager-4.jpg" alt="img"></p><p>2）Push 方式：</p><p><img src="/images/prometheus-alertmanager-5.jpg" alt="img"></p><p>显然 Pull 的收敛速度大于 Push ，而每个节点在每个周期被感染的概率都是固定的 p (0&lt;p&lt;1)，因此 Gossip 算法是基于 p 的平方收敛，也称为概率收敛，这在众多的一致性算法中是非常独特的。</p><h2 id="高可用方案"><a href="#高可用方案" class="headerlink" title="高可用方案"></a>高可用方案</h2><p>上面我们详细介绍了goosip协议的实现，简单的说，Gossip有两种实现方式分别为Push-based和Pull-based。在Push-based当集群中某一节点A完成一个工作后，随机的从其它节点B并向其发送相应的消息，节点B接收到消息后在重复完成相同的工作，直到传播到集群中的所有节点。而Pull-based的实现中节点A会随机的向节点B发起询问是否有新的状态需要同步，如果有则返回。</p><p>在简单了解了Gossip协议之后，我们来看Alertmanager是如何基于Gossip协议实现集群高可用的。如下所示，当Alertmanager接收到来自Prometheus的告警消息后，会按照以下流程对告警进行处理：</p><p><img src="/images/prometheus-alertmanager-6.png" alt="image-20210906112831633"></p><ul><li>在第一个阶段Silence中，Alertmanager会判断当前通知是否匹配到任何的静默规则，如果没有则进入下一个阶段，否则则中断流水线不发送通知；</li><li>在第二个阶段Wait中，Alertmanager会根据当前Alertmanager在集群中所在的顺序(index)等待index * 5s的时间；</li><li>当前Alertmanager等待阶段结束后，Dedup阶段则会判断当前Alertmanager数据库中该通知是否已经发送，如果已经发送则中断流水线，不发送告警，否则则进入下一阶段Send对外发送告警通知；</li><li>告警发送完成后该Alertmanager进入最后一个阶段Gossip，Gossip会通知其他Alertmanager实例当前告警已经发送。其他实例接收到Gossip消息后，则会在自己的数据库中保存该通知已发送的记录。</li></ul><p>因此如下所示，Gossip机制的关键在于两点：</p><p><img src="/images/prometheus-alertmanager-7.png" alt="image-20210906113513907"></p><ul><li>Silence设置同步：Alertmanager启动阶段基于Pull-based从集群其它节点同步Silence状态，当有新的Silence产生时使用Push-based方式在集群中传播Gossip信息；</li><li>通知发送状态同步：告警通知发送完成后，基于Push-based同步告警发送状态。Wait阶段可以确保集群状态一致。</li></ul><p>Alertmanager基于Gossip实现的集群机制虽然不能保证所有实例上的数据时刻保持一致，但是实现了CAP理论中的AP系统，即可用性和分区容错性。同时对于Prometheus Server而言保持了配置了简单性，Promthues Server之间不需要任何的状态同步。</p><h2 id="高可用源码分析"><a href="#高可用源码分析" class="headerlink" title="高可用源码分析"></a>高可用源码分析</h2><h3 id="集群启动"><a href="#集群启动" class="headerlink" title="集群启动"></a>集群启动</h3><p>下面是从main.go中摘录的一些关于alertmanager组件集群的代码流程：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码来自alertmanager/cmd/alertmanager/main.go</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化集群</span></span><br><span class="line"><span class="keyword">var</span> peer *cluster.Peer</span><br><span class="line"><span class="keyword">if</span> *clusterBindAddr != <span class="string">""</span> &#123;</span><br><span class="line">peer, err = cluster.Create(</span><br><span class="line">log.With(logger, <span class="string">"component"</span>, <span class="string">"cluster"</span>),</span><br><span class="line">prometheus.DefaultRegisterer,</span><br><span class="line">*clusterBindAddr,</span><br><span class="line">*clusterAdvertiseAddr,</span><br><span class="line">*peers,</span><br><span class="line"><span class="literal">true</span>,</span><br><span class="line">*pushPullInterval,</span><br><span class="line">*gossipInterval,</span><br><span class="line">*tcpTimeout,</span><br><span class="line">*probeTimeout,</span><br><span class="line">*probeInterval,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">level.Error(logger).Log(<span class="string">"msg"</span>, <span class="string">"unable to initialize gossip mesh"</span>, <span class="string">"err"</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置普罗米修斯集群指标，为已启用</span></span><br><span class="line">clusterEnabled.Set(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> peer != <span class="literal">nil</span> &#123;</span><br><span class="line">c := peer.AddState(<span class="string">"nfl"</span>, notificationLog, prometheus.DefaultRegisterer)</span><br><span class="line">notificationLog.SetBroadcast(c.Broadcast)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> peer != <span class="literal">nil</span> &#123;</span><br><span class="line">c := peer.AddState(<span class="string">"sil"</span>, silences, prometheus.DefaultRegisterer)</span><br><span class="line">silences.SetBroadcast(c.Broadcast)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 集群peer的状态监听器已经进行注册成功，现在可以进行加入集群和初始化状态。</span></span><br><span class="line"><span class="comment">// Peer state listeners have been registered, now we can join and get the initial state.</span></span><br><span class="line"><span class="keyword">if</span> peer != <span class="literal">nil</span> &#123;</span><br><span class="line">err = peer.Join(</span><br><span class="line">*reconnectInterval,</span><br><span class="line">*peerReconnectTimeout,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">level.Warn(logger).Log(<span class="string">"msg"</span>, <span class="string">"unable to join gossip mesh"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), *settleTimeout)</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">cancel()</span><br><span class="line"><span class="keyword">if</span> err := peer.Leave(<span class="number">10</span> * time.Second); err != <span class="literal">nil</span> &#123;</span><br><span class="line">level.Warn(logger).Log(<span class="string">"msg"</span>, <span class="string">"unable to leave gossip mesh"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">go</span> peer.Settle(ctx, *gossipInterval*<span class="number">10</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">waitFunc := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line"><span class="keyword">if</span> peer != <span class="literal">nil</span> &#123;</span><br><span class="line">waitFunc = clusterWait(peer, *peerTimeout)</span><br><span class="line">&#125;</span><br><span class="line">timeoutFunc := <span class="function"><span class="keyword">func</span><span class="params">(d time.Duration)</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> d &lt; notify.MinTimeout &#123;</span><br><span class="line">d = notify.MinTimeout</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d + waitFunc()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">pipeline := pipelineBuilder.New(</span><br><span class="line">receivers,</span><br><span class="line">waitFunc,</span><br><span class="line">inhibitor,</span><br><span class="line">silencer,</span><br><span class="line">notificationLog,</span><br><span class="line">peer,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  disp = dispatch.NewDispatcher(alerts, routes, pipeline, marker, timeoutFunc, logger, dispMetrics)</span><br></pre></td></tr></table></figure><p>在<code>cluster.Create</code>中主要就是一些初始化集群的工作，里面比较重要的就是用到了<code>ml, err := memberlist.Create(cfg)</code>，这里用到了一个基于Gossip协议来传播消息，用来管理分布式集群内节点发现、 节点失效探测、节点列表的软件包<code>memberlist</code>，关于这个包，有必要分析一下，没兴趣的可以跳过这一节：</p><h3 id="memberlist"><a href="#memberlist" class="headerlink" title="memberlist"></a>memberlist</h3><p>memberlist 是HashiCorp公司出品的go语言开发库，使用基于Gossip协议管理集群成员和成员失败检测。咱们本文的主题就是memberlist。严格说起来，memberlist是基于Gossip协议变种实现的，它的指导论文是康奈尔大学计算机科学系Abhinandan Das, Indranil Gupta, Ashish Motivala在2002年发表的《SWIM:Scalable Weakly-consistent/Infection-styleProcess Group Membership Protocol》。</p><p>Membership协议中文名是 可伸缩最终一致性感染成员组协议。原理通过一个有效的点对点随机探测机制进行监控协议成员的故障检测、更新传播。Memberlist 构建在SWIM Membership之上，跟原始gossip协议有了一些补充和调整。咱们接下去从项目介绍、节点状态、消息类型、数据通讯来解说下。</p><p>项目结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">total 536</span><br><span class="line">-rw-r--r--  1 stark  staff  15977  6  2 15:34 LICENSE</span><br><span class="line">-rw-r--r--  1 stark  staff    670  6  2 15:34 Makefile</span><br><span class="line">-rw-r--r--  1 stark  staff   3195  6  2 15:34 README.md</span><br><span class="line">-rw-r--r--  1 stark  staff    591  6  2 15:34 alive_delegate.go</span><br><span class="line">-rw-r--r--  1 stark  staff   1745  6  2 15:34 awareness.go</span><br><span class="line">-rw-r--r--  1 stark  staff   3311  6  2 15:34 broadcast.go # 广播模块</span><br><span class="line">-rw-r--r--  1 stark  staff  15003  6  2 15:34 config.go</span><br><span class="line">-rw-r--r--  1 stark  staff    376  6  2 15:34 conflict_delegate.go</span><br><span class="line">-rw-r--r--  1 stark  staff   1851  6  2 15:34 delegate.go</span><br><span class="line">-rw-r--r--  1 stark  staff   1870  6  2 15:34 event_delegate.go</span><br><span class="line">-rw-r--r--  1 stark  staff    666  6  2 15:34 go.mod</span><br><span class="line">-rw-r--r--  1 stark  staff   4720  6  2 15:34 go.sum</span><br><span class="line">-rw-r--r--  1 stark  staff   4505  6  2 15:34 keyring.go</span><br><span class="line">-rw-r--r--  1 stark  staff    454  6  2 15:34 logging.go</span><br><span class="line">-rw-r--r--  1 stark  staff  22474  6  2 15:34 memberlist.go # 主体模块</span><br><span class="line">-rw-r--r--  1 stark  staff    570  6  2 15:34 merge_delegate.go</span><br><span class="line">-rw-r--r--  1 stark  staff   4390  6  2 15:34 mock_transport.go</span><br><span class="line">-rw-r--r--  1 stark  staff  35144  6  2 15:34 net.go # 通信模块</span><br><span class="line">-rw-r--r--  1 stark  staff  10031  6  2 15:34 net_transport.go</span><br><span class="line">-rw-r--r--  1 stark  staff    645  6  2 15:34 ping_delegate.go</span><br><span class="line">-rw-r--r--  1 stark  staff  11384  6  2 15:34 queue.go</span><br><span class="line">-rw-r--r--  1 stark  staff   5074  6  2 15:34 security.go</span><br><span class="line">-rw-r--r--  1 stark  staff  37938  6  2 15:34 state.go # 状态模块</span><br><span class="line">-rw-r--r--  1 stark  staff   4298  6  2 15:34 suspicion.go</span><br><span class="line">-rw-r--r--  1 stark  staff    399  6  2 15:34 tag.sh</span><br><span class="line">-rw-r--r--  1 stark  staff    211  6  2 15:34 todo.md</span><br><span class="line">-rw-r--r--  1 stark  staff   4579  6  2 15:34 transport.go</span><br><span class="line">-rw-r--r--  1 stark  staff   8170  6  2 15:34 util.go</span><br></pre></td></tr></table></figure><p>项目基本流程如下：</p><ul><li><p>项目在memberlist.go 函数Create启动，调用sate.go中函数schedule</p></li><li><p>Schedule函数开启probe协程、pushpull协程、gossip协程</p></li><li><p>probe协程：进行节点状态维护</p></li><li><p>push/pull协程：进行节点状态、用户数据同步</p></li><li><p>gossip协程：进行udp广播发送消息。</p></li></ul><h4 id="Memberlist-结构体"><a href="#Memberlist-结构体" class="headerlink" title="Memberlist 结构体"></a>Memberlist 结构体</h4><p>在结构体Memberlist中，成员变量也是按照功能不同分隔</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码来自 github.com/hashicorp/memberlist/memberlist.go</span></span><br><span class="line"><span class="keyword">type</span> Memberlist <span class="keyword">struct</span> &#123;</span><br><span class="line">sequenceNum <span class="keyword">uint32</span> <span class="comment">// Local sequence number</span></span><br><span class="line">incarnation <span class="keyword">uint32</span> <span class="comment">// Local incarnation number</span></span><br><span class="line">numNodes    <span class="keyword">uint32</span> <span class="comment">// Number of known nodes (estimate)</span></span><br><span class="line">pushPullReq <span class="keyword">uint32</span> <span class="comment">// Number of push/pull requests</span></span><br><span class="line"></span><br><span class="line">advertiseLock sync.RWMutex</span><br><span class="line">advertiseAddr net.IP</span><br><span class="line">advertisePort <span class="keyword">uint16</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//配置</span></span><br><span class="line">config         *Config </span><br><span class="line">  <span class="comment">//本地服务关闭的标志位</span></span><br><span class="line">shutdown       <span class="keyword">int32</span> <span class="comment">// Used as an atomic boolean value</span></span><br><span class="line">shutdownCh     <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">  <span class="comment">//本节点退出的标志位</span></span><br><span class="line">leave          <span class="keyword">int32</span> <span class="comment">// Used as an atomic boolean value</span></span><br><span class="line">leaveBroadcast <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">shutdownLock sync.Mutex <span class="comment">// Serializes calls to Shutdown</span></span><br><span class="line">leaveLock    sync.Mutex <span class="comment">// Serializes calls to Leave</span></span><br><span class="line"></span><br><span class="line">transport NodeAwareTransport</span><br><span class="line"></span><br><span class="line">handoffCh            <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">highPriorityMsgQueue *list.List</span><br><span class="line">lowPriorityMsgQueue  *list.List</span><br><span class="line">msgQueueLock         sync.Mutex</span><br><span class="line"></span><br><span class="line">nodeLock   sync.RWMutex</span><br><span class="line">nodes      []*nodeState          <span class="comment">// Known nodes</span></span><br><span class="line">nodeMap    <span class="keyword">map</span>[<span class="keyword">string</span>]*nodeState <span class="comment">// Maps Node.Name -&gt; NodeState</span></span><br><span class="line">nodeTimers <span class="keyword">map</span>[<span class="keyword">string</span>]*suspicion <span class="comment">// Maps Node.Name -&gt; suspicion timer</span></span><br><span class="line">awareness  *awareness</span><br><span class="line"></span><br><span class="line">tickerLock sync.Mutex</span><br><span class="line">tickers    []*time.Ticker</span><br><span class="line">stopTick   <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">probeIndex <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">ackLock     sync.Mutex</span><br><span class="line">ackHandlers <span class="keyword">map</span>[<span class="keyword">uint32</span>]*ackHandler</span><br><span class="line"></span><br><span class="line">broadcasts *TransmitLimitedQueue</span><br><span class="line"></span><br><span class="line">logger *log.Logger</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Config-结构体"><a href="#Config-结构体" class="headerlink" title="Config 结构体"></a>Config 结构体</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// The name of this node. This must be unique in the cluster.</span></span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Transport is a hook for providing custom code to communicate with</span></span><br><span class="line"><span class="comment">// other nodes. If this is left nil, then memberlist will by default</span></span><br><span class="line"><span class="comment">// make a NetTransport using BindAddr and BindPort from this structure.</span></span><br><span class="line">Transport Transport</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configuration related to what address to bind to and ports to</span></span><br><span class="line"><span class="comment">// listen on. The port is used for both UDP and TCP gossip. It is</span></span><br><span class="line"><span class="comment">// assumed other nodes are running on this port, but they do not need</span></span><br><span class="line"><span class="comment">// to.</span></span><br><span class="line">BindAddr <span class="keyword">string</span></span><br><span class="line">BindPort <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Configuration related to what address to advertise to other</span></span><br><span class="line"><span class="comment">// cluster members. Used for nat traversal.</span></span><br><span class="line">AdvertiseAddr <span class="keyword">string</span></span><br><span class="line">AdvertisePort <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ProtocolVersion is the configured protocol version that we</span></span><br><span class="line"><span class="comment">// will _speak_. This must be between ProtocolVersionMin and</span></span><br><span class="line"><span class="comment">// ProtocolVersionMax.</span></span><br><span class="line">ProtocolVersion <span class="keyword">uint8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TCPTimeout is the timeout for establishing a stream connection with</span></span><br><span class="line"><span class="comment">// a remote node for a full state sync, and for stream read and write</span></span><br><span class="line"><span class="comment">// operations. This is a legacy name for backwards compatibility, but</span></span><br><span class="line"><span class="comment">// should really be called StreamTimeout now that we have generalized</span></span><br><span class="line"><span class="comment">// the transport.</span></span><br><span class="line">TCPTimeout time.Duration</span><br><span class="line"></span><br><span class="line"><span class="comment">// IndirectChecks is the number of nodes that will be asked to perform</span></span><br><span class="line"><span class="comment">// an indirect probe of a node in the case a direct probe fails. Memberlist</span></span><br><span class="line"><span class="comment">// waits for an ack from any single indirect node, so increasing this</span></span><br><span class="line"><span class="comment">// number will increase the likelihood that an indirect probe will succeed</span></span><br><span class="line"><span class="comment">// at the expense of bandwidth.</span></span><br><span class="line">IndirectChecks <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RetransmitMult is the multiplier for the number of retransmissions</span></span><br><span class="line"><span class="comment">// that are attempted for messages broadcasted over gossip. The actual</span></span><br><span class="line"><span class="comment">// count of retransmissions is calculated using the formula:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   Retransmits = RetransmitMult * log(N+1)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This allows the retransmits to scale properly with cluster size. The</span></span><br><span class="line"><span class="comment">// higher the multiplier, the more likely a failed broadcast is to converge</span></span><br><span class="line"><span class="comment">// at the expense of increased bandwidth.</span></span><br><span class="line">RetransmitMult <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SuspicionMult is the multiplier for determining the time an</span></span><br><span class="line"><span class="comment">// inaccessible node is considered suspect before declaring it dead.</span></span><br><span class="line"><span class="comment">// The actual timeout is calculated using the formula:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   SuspicionTimeout = SuspicionMult * log(N+1) * ProbeInterval</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This allows the timeout to scale properly with expected propagation</span></span><br><span class="line"><span class="comment">// delay with a larger cluster size. The higher the multiplier, the longer</span></span><br><span class="line"><span class="comment">// an inaccessible node is considered part of the cluster before declaring</span></span><br><span class="line"><span class="comment">// it dead, giving that suspect node more time to refute if it is indeed</span></span><br><span class="line"><span class="comment">// still alive.</span></span><br><span class="line">SuspicionMult <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SuspicionMaxTimeoutMult is the multiplier applied to the</span></span><br><span class="line"><span class="comment">// SuspicionTimeout used as an upper bound on detection time. This max</span></span><br><span class="line"><span class="comment">// timeout is calculated using the formula:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// SuspicionMaxTimeout = SuspicionMaxTimeoutMult * SuspicionTimeout</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If everything is working properly, confirmations from other nodes will</span></span><br><span class="line"><span class="comment">// accelerate suspicion timers in a manner which will cause the timeout</span></span><br><span class="line"><span class="comment">// to reach the base SuspicionTimeout before that elapses, so this value</span></span><br><span class="line"><span class="comment">// will typically only come into play if a node is experiencing issues</span></span><br><span class="line"><span class="comment">// communicating with other nodes. It should be set to a something fairly</span></span><br><span class="line"><span class="comment">// large so that a node having problems will have a lot of chances to</span></span><br><span class="line"><span class="comment">// recover before falsely declaring other nodes as failed, but short</span></span><br><span class="line"><span class="comment">// enough for a legitimately isolated node to still make progress marking</span></span><br><span class="line"><span class="comment">// nodes failed in a reasonable amount of time.</span></span><br><span class="line">SuspicionMaxTimeoutMult <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PushPullInterval is the interval between complete state syncs.</span></span><br><span class="line"><span class="comment">// Complete state syncs are done with a single node over TCP and are</span></span><br><span class="line"><span class="comment">// quite expensive relative to standard gossiped messages. Setting this</span></span><br><span class="line"><span class="comment">// to zero will disable state push/pull syncs completely.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Setting this interval lower (more frequent) will increase convergence</span></span><br><span class="line"><span class="comment">// speeds across larger clusters at the expense of increased bandwidth</span></span><br><span class="line"><span class="comment">// usage.</span></span><br><span class="line">PushPullInterval time.Duration</span><br><span class="line"></span><br><span class="line"><span class="comment">// ProbeInterval and ProbeTimeout are used to configure probing</span></span><br><span class="line"><span class="comment">// behavior for memberlist.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ProbeInterval is the interval between random node probes. Setting</span></span><br><span class="line"><span class="comment">// this lower (more frequent) will cause the memberlist cluster to detect</span></span><br><span class="line"><span class="comment">// failed nodes more quickly at the expense of increased bandwidth usage.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ProbeTimeout is the timeout to wait for an ack from a probed node</span></span><br><span class="line"><span class="comment">// before assuming it is unhealthy. This should be set to 99-percentile</span></span><br><span class="line"><span class="comment">// of RTT (round-trip time) on your network.</span></span><br><span class="line">ProbeInterval time.Duration</span><br><span class="line">ProbeTimeout  time.Duration</span><br><span class="line"></span><br><span class="line"><span class="comment">// DisableTcpPings will turn off the fallback TCP pings that are attempted</span></span><br><span class="line"><span class="comment">// if the direct UDP ping fails. These get pipelined along with the</span></span><br><span class="line"><span class="comment">// indirect UDP pings.</span></span><br><span class="line">DisableTcpPings <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DisableTcpPingsForNode is like DisableTcpPings, but lets you control</span></span><br><span class="line"><span class="comment">// whether to perform TCP pings on a node-by-node basis.</span></span><br><span class="line">DisableTcpPingsForNode <span class="function"><span class="keyword">func</span><span class="params">(nodeName <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">AwarenessMaxMultiplier</span> <span class="title">will</span> <span class="title">increase</span> <span class="title">the</span> <span class="title">probe</span> <span class="title">interval</span> <span class="title">if</span> <span class="title">the</span> <span class="title">node</span></span></span><br><span class="line"><span class="function">// <span class="title">becomes</span> <span class="title">aware</span> <span class="title">that</span> <span class="title">it</span> <span class="title">might</span> <span class="title">be</span> <span class="title">degraded</span> <span class="title">and</span> <span class="title">not</span> <span class="title">meeting</span> <span class="title">the</span> <span class="title">soft</span> <span class="title">real</span></span></span><br><span class="line"><span class="function">// <span class="title">time</span> <span class="title">requirements</span> <span class="title">to</span> <span class="title">reliably</span> <span class="title">probe</span> <span class="title">other</span> <span class="title">nodes</span>.</span></span><br><span class="line"><span class="function"><span class="title">AwarenessMaxMultiplier</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">GossipInterval</span> <span class="title">and</span> <span class="title">GossipNodes</span> <span class="title">are</span> <span class="title">used</span> <span class="title">to</span> <span class="title">configure</span> <span class="title">the</span> <span class="title">gossip</span></span></span><br><span class="line"><span class="function">// <span class="title">behavior</span> <span class="title">of</span> <span class="title">memberlist</span>.</span></span><br><span class="line"><span class="function">//</span></span><br><span class="line"><span class="function">// <span class="title">GossipInterval</span> <span class="title">is</span> <span class="title">the</span> <span class="title">interval</span> <span class="title">between</span> <span class="title">sending</span> <span class="title">messages</span> <span class="title">that</span> <span class="title">need</span></span></span><br><span class="line"><span class="function">// <span class="title">to</span> <span class="title">be</span> <span class="title">gossiped</span> <span class="title">that</span> <span class="title">haven</span>'<span class="title">t</span> <span class="title">been</span> <span class="title">able</span> <span class="title">to</span> <span class="title">piggyback</span> <span class="title">on</span> <span class="title">probing</span> <span class="title">messages</span>.</span></span><br><span class="line"><span class="function">// <span class="title">If</span> <span class="title">this</span> <span class="title">is</span> <span class="title">set</span> <span class="title">to</span> <span class="title">zero</span>, <span class="title">non</span>-<span class="title">piggyback</span> <span class="title">gossip</span> <span class="title">is</span> <span class="title">disabled</span>. <span class="title">By</span> <span class="title">lowering</span></span></span><br><span class="line"><span class="function">// <span class="title">this</span> <span class="title">value</span> <span class="params">(more frequent)</span> <span class="title">gossip</span> <span class="title">messages</span> <span class="title">are</span> <span class="title">propagated</span> <span class="title">across</span></span></span><br><span class="line"><span class="function">// <span class="title">the</span> <span class="title">cluster</span> <span class="title">more</span> <span class="title">quickly</span> <span class="title">at</span> <span class="title">the</span> <span class="title">expense</span> <span class="title">of</span> <span class="title">increased</span> <span class="title">bandwidth</span>.</span></span><br><span class="line"><span class="function">//</span></span><br><span class="line"><span class="function">// <span class="title">GossipNodes</span> <span class="title">is</span> <span class="title">the</span> <span class="title">number</span> <span class="title">of</span> <span class="title">random</span> <span class="title">nodes</span> <span class="title">to</span> <span class="title">send</span> <span class="title">gossip</span> <span class="title">messages</span> <span class="title">to</span></span></span><br><span class="line"><span class="function">// <span class="title">per</span> <span class="title">GossipInterval</span>. <span class="title">Increasing</span> <span class="title">this</span> <span class="title">number</span> <span class="title">causes</span> <span class="title">the</span> <span class="title">gossip</span> <span class="title">messages</span></span></span><br><span class="line"><span class="function">// <span class="title">to</span> <span class="title">propagate</span> <span class="title">across</span> <span class="title">the</span> <span class="title">cluster</span> <span class="title">more</span> <span class="title">quickly</span> <span class="title">at</span> <span class="title">the</span> <span class="title">expense</span> <span class="title">of</span></span></span><br><span class="line"><span class="function">// <span class="title">increased</span> <span class="title">bandwidth</span>.</span></span><br><span class="line"><span class="function">//</span></span><br><span class="line"><span class="function">// <span class="title">GossipToTheDeadTime</span> <span class="title">is</span> <span class="title">the</span> <span class="title">interval</span> <span class="title">after</span> <span class="title">which</span> <span class="title">a</span> <span class="title">node</span> <span class="title">has</span> <span class="title">died</span> <span class="title">that</span></span></span><br><span class="line"><span class="function">// <span class="title">we</span> <span class="title">will</span> <span class="title">still</span> <span class="title">try</span> <span class="title">to</span> <span class="title">gossip</span> <span class="title">to</span> <span class="title">it</span>. <span class="title">This</span> <span class="title">gives</span> <span class="title">it</span> <span class="title">a</span> <span class="title">chance</span> <span class="title">to</span> <span class="title">refute</span>.</span></span><br><span class="line"><span class="function"><span class="title">GossipInterval</span>      <span class="title">time</span>.<span class="title">Duration</span></span></span><br><span class="line"><span class="function"><span class="title">GossipNodes</span>         <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">GossipToTheDeadTime</span> <span class="title">time</span>.<span class="title">Duration</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">GossipVerifyIncoming</span> <span class="title">controls</span> <span class="title">whether</span> <span class="title">to</span> <span class="title">enforce</span> <span class="title">encryption</span> <span class="title">for</span> <span class="title">incoming</span></span></span><br><span class="line"><span class="function">// <span class="title">gossip</span>. <span class="title">It</span> <span class="title">is</span> <span class="title">used</span> <span class="title">for</span> <span class="title">upshifting</span> <span class="title">from</span> <span class="title">unencrypted</span> <span class="title">to</span> <span class="title">encrypted</span> <span class="title">gossip</span> <span class="title">on</span></span></span><br><span class="line"><span class="function">// <span class="title">a</span> <span class="title">running</span> <span class="title">cluster</span>.</span></span><br><span class="line"><span class="function"><span class="title">GossipVerifyIncoming</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">GossipVerifyOutgoing</span> <span class="title">controls</span> <span class="title">whether</span> <span class="title">to</span> <span class="title">enforce</span> <span class="title">encryption</span> <span class="title">for</span> <span class="title">outgoing</span></span></span><br><span class="line"><span class="function">// <span class="title">gossip</span>. <span class="title">It</span> <span class="title">is</span> <span class="title">used</span> <span class="title">for</span> <span class="title">upshifting</span> <span class="title">from</span> <span class="title">unencrypted</span> <span class="title">to</span> <span class="title">encrypted</span> <span class="title">gossip</span> <span class="title">on</span></span></span><br><span class="line"><span class="function">// <span class="title">a</span> <span class="title">running</span> <span class="title">cluster</span>.</span></span><br><span class="line"><span class="function"><span class="title">GossipVerifyOutgoing</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">EnableCompression</span> <span class="title">is</span> <span class="title">used</span> <span class="title">to</span> <span class="title">control</span> <span class="title">message</span> <span class="title">compression</span>. <span class="title">This</span> <span class="title">can</span></span></span><br><span class="line"><span class="function">// <span class="title">be</span> <span class="title">used</span> <span class="title">to</span> <span class="title">reduce</span> <span class="title">bandwidth</span> <span class="title">usage</span> <span class="title">at</span> <span class="title">the</span> <span class="title">cost</span> <span class="title">of</span> <span class="title">slightly</span> <span class="title">more</span> <span class="title">CPU</span></span></span><br><span class="line"><span class="function">// <span class="title">utilization</span>. <span class="title">This</span> <span class="title">is</span> <span class="title">only</span> <span class="title">available</span> <span class="title">starting</span> <span class="title">at</span> <span class="title">protocol</span> <span class="title">version</span> 1.</span></span><br><span class="line"><span class="function"><span class="title">EnableCompression</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">SecretKey</span> <span class="title">is</span> <span class="title">used</span> <span class="title">to</span> <span class="title">initialize</span> <span class="title">the</span> <span class="title">primary</span> <span class="title">encryption</span> <span class="title">key</span> <span class="title">in</span> <span class="title">a</span> <span class="title">keyring</span>.</span></span><br><span class="line"><span class="function">// <span class="title">The</span> <span class="title">primary</span> <span class="title">encryption</span> <span class="title">key</span> <span class="title">is</span> <span class="title">the</span> <span class="title">only</span> <span class="title">key</span> <span class="title">used</span> <span class="title">to</span> <span class="title">encrypt</span> <span class="title">messages</span> <span class="title">and</span></span></span><br><span class="line"><span class="function">// <span class="title">the</span> <span class="title">first</span> <span class="title">key</span> <span class="title">used</span> <span class="title">while</span> <span class="title">attempting</span> <span class="title">to</span> <span class="title">decrypt</span> <span class="title">messages</span>. <span class="title">Providing</span> <span class="title">a</span></span></span><br><span class="line"><span class="function">// <span class="title">value</span> <span class="title">for</span> <span class="title">this</span> <span class="title">primary</span> <span class="title">key</span> <span class="title">will</span> <span class="title">enable</span> <span class="title">message</span>-<span class="title">level</span> <span class="title">encryption</span> <span class="title">and</span></span></span><br><span class="line"><span class="function">// <span class="title">verification</span>, <span class="title">and</span> <span class="title">automatically</span> <span class="title">install</span> <span class="title">the</span> <span class="title">key</span> <span class="title">onto</span> <span class="title">the</span> <span class="title">keyring</span>.</span></span><br><span class="line"><span class="function">// <span class="title">The</span> <span class="title">value</span> <span class="title">should</span> <span class="title">be</span> <span class="title">either</span> 16, 24, <span class="title">or</span> 32 <span class="title">bytes</span> <span class="title">to</span> <span class="title">select</span> <span class="title">AES</span>-128,</span></span><br><span class="line"><span class="function">// <span class="title">AES</span>-192, <span class="title">or</span> <span class="title">AES</span>-256.</span></span><br><span class="line"><span class="function"><span class="title">SecretKey</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">The</span> <span class="title">keyring</span> <span class="title">holds</span> <span class="title">all</span> <span class="title">of</span> <span class="title">the</span> <span class="title">encryption</span> <span class="title">keys</span> <span class="title">used</span> <span class="title">internally</span>. <span class="title">It</span> <span class="title">is</span></span></span><br><span class="line"><span class="function">// <span class="title">automatically</span> <span class="title">initialized</span> <span class="title">using</span> <span class="title">the</span> <span class="title">SecretKey</span> <span class="title">and</span> <span class="title">SecretKeys</span> <span class="title">values</span>.</span></span><br><span class="line"><span class="function"><span class="title">Keyring</span> *<span class="title">Keyring</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">Delegate</span> <span class="title">and</span> <span class="title">Events</span> <span class="title">are</span> <span class="title">delegates</span> <span class="title">for</span> <span class="title">receiving</span> <span class="title">and</span> <span class="title">providing</span></span></span><br><span class="line"><span class="function">// <span class="title">data</span> <span class="title">to</span> <span class="title">memberlist</span> <span class="title">via</span> <span class="title">callback</span> <span class="title">mechanisms</span>. <span class="title">For</span> <span class="title">Delegate</span>, <span class="title">see</span></span></span><br><span class="line"><span class="function">// <span class="title">the</span> <span class="title">Delegate</span> <span class="title">interface</span>. <span class="title">For</span> <span class="title">Events</span>, <span class="title">see</span> <span class="title">the</span> <span class="title">EventDelegate</span> <span class="title">interface</span>.</span></span><br><span class="line"><span class="function">//</span></span><br><span class="line"><span class="function">// <span class="title">The</span> <span class="title">DelegateProtocolMin</span>/<span class="title">Max</span> <span class="title">are</span> <span class="title">used</span> <span class="title">to</span> <span class="title">guarantee</span> <span class="title">protocol</span>-<span class="title">compatibility</span></span></span><br><span class="line"><span class="function">// <span class="title">for</span> <span class="title">any</span> <span class="title">custom</span> <span class="title">messages</span> <span class="title">that</span> <span class="title">the</span> <span class="title">delegate</span> <span class="title">might</span> <span class="title">do</span> <span class="params">(broadcasts,</span></span></span><br><span class="line"><span class="function"><span class="params">// local/remote state, etc.)</span>. <span class="title">If</span> <span class="title">you</span> <span class="title">don</span>'<span class="title">t</span> <span class="title">set</span> <span class="title">these</span>, <span class="title">then</span> <span class="title">the</span> <span class="title">protocol</span></span></span><br><span class="line"><span class="function">// <span class="title">versions</span> <span class="title">will</span> <span class="title">just</span> <span class="title">be</span> <span class="title">zero</span>, <span class="title">and</span> <span class="title">version</span> <span class="title">compliance</span> <span class="title">won</span>'<span class="title">t</span> <span class="title">be</span> <span class="title">done</span>.</span></span><br><span class="line"><span class="function"><span class="title">Delegate</span>                <span class="title">Delegate</span></span></span><br><span class="line"><span class="function"><span class="title">DelegateProtocolVersion</span> <span class="title">uint8</span></span></span><br><span class="line"><span class="function"><span class="title">DelegateProtocolMin</span>     <span class="title">uint8</span></span></span><br><span class="line"><span class="function"><span class="title">DelegateProtocolMax</span>     <span class="title">uint8</span></span></span><br><span class="line"><span class="function"><span class="title">Events</span>                  <span class="title">EventDelegate</span></span></span><br><span class="line"><span class="function"><span class="title">Conflict</span>                <span class="title">ConflictDelegate</span></span></span><br><span class="line"><span class="function"><span class="title">Merge</span>                   <span class="title">MergeDelegate</span></span></span><br><span class="line"><span class="function"><span class="title">Ping</span>                    <span class="title">PingDelegate</span></span></span><br><span class="line"><span class="function"><span class="title">Alive</span>                   <span class="title">AliveDelegate</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">DNSConfigPath</span> <span class="title">points</span> <span class="title">to</span> <span class="title">the</span> <span class="title">system</span>'<span class="title">s</span> <span class="title">DNS</span> <span class="title">config</span> <span class="title">file</span>, <span class="title">usually</span> <span class="title">located</span></span></span><br><span class="line"><span class="function">// <span class="title">at</span> /<span class="title">etc</span>/<span class="title">resolv</span>.<span class="title">conf</span>. <span class="title">It</span> <span class="title">can</span> <span class="title">be</span> <span class="title">overridden</span> <span class="title">via</span> <span class="title">config</span> <span class="title">for</span> <span class="title">easier</span> <span class="title">testing</span>.</span></span><br><span class="line"><span class="function"><span class="title">DNSConfigPath</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">LogOutput</span> <span class="title">is</span> <span class="title">the</span> <span class="title">writer</span> <span class="title">where</span> <span class="title">logs</span> <span class="title">should</span> <span class="title">be</span> <span class="title">sent</span>. <span class="title">If</span> <span class="title">this</span> <span class="title">is</span> <span class="title">not</span></span></span><br><span class="line"><span class="function">// <span class="title">set</span>, <span class="title">logging</span> <span class="title">will</span> <span class="title">go</span> <span class="title">to</span> <span class="title">stderr</span> <span class="title">by</span> <span class="title">default</span>. <span class="title">You</span> <span class="title">cannot</span> <span class="title">specify</span> <span class="title">both</span> <span class="title">LogOutput</span></span></span><br><span class="line"><span class="function">// <span class="title">and</span> <span class="title">Logger</span> <span class="title">at</span> <span class="title">the</span> <span class="title">same</span> <span class="title">time</span>.</span></span><br><span class="line"><span class="function"><span class="title">LogOutput</span> <span class="title">io</span>.<span class="title">Writer</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">Logger</span> <span class="title">is</span> <span class="title">a</span> <span class="title">custom</span> <span class="title">logger</span> <span class="title">which</span> <span class="title">you</span> <span class="title">provide</span>. <span class="title">If</span> <span class="title">Logger</span> <span class="title">is</span> <span class="title">set</span>, <span class="title">it</span> <span class="title">will</span> <span class="title">use</span></span></span><br><span class="line"><span class="function">// <span class="title">this</span> <span class="title">for</span> <span class="title">the</span> <span class="title">internal</span> <span class="title">logger</span>. <span class="title">If</span> <span class="title">Logger</span> <span class="title">is</span> <span class="title">not</span> <span class="title">set</span>, <span class="title">it</span> <span class="title">will</span> <span class="title">fall</span> <span class="title">back</span> <span class="title">to</span> <span class="title">the</span></span></span><br><span class="line"><span class="function">// <span class="title">behavior</span> <span class="title">for</span> <span class="title">using</span> <span class="title">LogOutput</span>. <span class="title">You</span> <span class="title">cannot</span> <span class="title">specify</span> <span class="title">both</span> <span class="title">LogOutput</span> <span class="title">and</span> <span class="title">Logger</span></span></span><br><span class="line"><span class="function">// <span class="title">at</span> <span class="title">the</span> <span class="title">same</span> <span class="title">time</span>.</span></span><br><span class="line"><span class="function"><span class="title">Logger</span> *<span class="title">log</span>.<span class="title">Logger</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">Size</span> <span class="title">of</span> <span class="title">Memberlist</span>'<span class="title">s</span> <span class="title">internal</span> <span class="title">channel</span> <span class="title">which</span> <span class="title">handles</span> <span class="title">UDP</span> <span class="title">messages</span>. <span class="title">The</span></span></span><br><span class="line"><span class="function">// <span class="title">size</span> <span class="title">of</span> <span class="title">this</span> <span class="title">determines</span> <span class="title">the</span> <span class="title">size</span> <span class="title">of</span> <span class="title">the</span> <span class="title">queue</span> <span class="title">which</span> <span class="title">Memberlist</span> <span class="title">will</span> <span class="title">keep</span></span></span><br><span class="line"><span class="function">// <span class="title">while</span> <span class="title">UDP</span> <span class="title">messages</span> <span class="title">are</span> <span class="title">handled</span>.</span></span><br><span class="line"><span class="function"><span class="title">HandoffQueueDepth</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">Maximum</span> <span class="title">number</span> <span class="title">of</span> <span class="title">bytes</span> <span class="title">that</span> <span class="title">memberlist</span> <span class="title">will</span> <span class="title">put</span> <span class="title">in</span> <span class="title">a</span> <span class="title">packet</span> <span class="params">(this</span></span></span><br><span class="line"><span class="function"><span class="params">// will be <span class="keyword">for</span> UDP packets by <span class="keyword">default</span> with a NetTransport)</span>. <span class="title">A</span> <span class="title">safe</span> <span class="title">value</span></span></span><br><span class="line"><span class="function">// <span class="title">for</span> <span class="title">this</span> <span class="title">is</span> <span class="title">typically</span> 1400 <span class="title">bytes</span> <span class="params">(which is the <span class="keyword">default</span>)</span>. <span class="title">However</span>,</span></span><br><span class="line"><span class="function">// <span class="title">depending</span> <span class="title">on</span> <span class="title">your</span> <span class="title">network</span>'<span class="title">s</span> <span class="title">MTU</span> <span class="params">(Maximum Transmission Unit)</span> <span class="title">you</span> <span class="title">may</span></span></span><br><span class="line"><span class="function">// <span class="title">be</span> <span class="title">able</span> <span class="title">to</span> <span class="title">increase</span> <span class="title">this</span> <span class="title">to</span> <span class="title">get</span> <span class="title">more</span> <span class="title">content</span> <span class="title">into</span> <span class="title">each</span> <span class="title">gossip</span> <span class="title">packet</span>.</span></span><br><span class="line"><span class="function">// <span class="title">This</span> <span class="title">is</span> <span class="title">a</span> <span class="title">legacy</span> <span class="title">name</span> <span class="title">for</span> <span class="title">backward</span> <span class="title">compatibility</span> <span class="title">but</span> <span class="title">should</span> <span class="title">really</span> <span class="title">be</span></span></span><br><span class="line"><span class="function">// <span class="title">called</span> <span class="title">PacketBufferSize</span> <span class="title">now</span> <span class="title">that</span> <span class="title">we</span> <span class="title">have</span> <span class="title">generalized</span> <span class="title">the</span> <span class="title">transport</span>.</span></span><br><span class="line"><span class="function"><span class="title">UDPBufferSize</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">DeadNodeReclaimTime</span> <span class="title">controls</span> <span class="title">the</span> <span class="title">time</span> <span class="title">before</span> <span class="title">a</span> <span class="title">dead</span> <span class="title">node</span>'<span class="title">s</span> <span class="title">name</span> <span class="title">can</span> <span class="title">be</span></span></span><br><span class="line"><span class="function">// <span class="title">reclaimed</span> <span class="title">by</span> <span class="title">one</span> <span class="title">with</span> <span class="title">a</span> <span class="title">different</span> <span class="title">address</span> <span class="title">or</span> <span class="title">port</span>. <span class="title">By</span> <span class="title">default</span>, <span class="title">this</span> <span class="title">is</span> 0,</span></span><br><span class="line"><span class="function">// <span class="title">meaning</span> <span class="title">nodes</span> <span class="title">cannot</span> <span class="title">be</span> <span class="title">reclaimed</span> <span class="title">this</span> <span class="title">way</span>.</span></span><br><span class="line"><span class="function"><span class="title">DeadNodeReclaimTime</span> <span class="title">time</span>.<span class="title">Duration</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">RequireNodeNames</span> <span class="title">controls</span> <span class="title">if</span> <span class="title">the</span> <span class="title">name</span> <span class="title">of</span> <span class="title">a</span> <span class="title">node</span> <span class="title">is</span> <span class="title">required</span> <span class="title">when</span> <span class="title">sending</span></span></span><br><span class="line"><span class="function">// <span class="title">a</span> <span class="title">message</span> <span class="title">to</span> <span class="title">that</span> <span class="title">node</span>.</span></span><br><span class="line"><span class="function"><span class="title">RequireNodeNames</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function">// <span class="title">CIDRsAllowed</span> <span class="title">If</span> <span class="title">nil</span>, <span class="title">allow</span> <span class="title">any</span> <span class="title">connection</span> <span class="params">(<span class="keyword">default</span>)</span>, <span class="title">otherwise</span> <span class="title">specify</span> <span class="title">all</span> <span class="title">networks</span></span></span><br><span class="line"><span class="function">// <span class="title">allowed</span> <span class="title">to</span> <span class="title">connect</span> <span class="params">(you must specify IPv6/IPv4 separately)</span></span></span><br><span class="line"><span class="function">// <span class="title">Using</span> [] <span class="title">will</span> <span class="title">block</span> <span class="title">all</span> <span class="title">connections</span>.</span></span><br><span class="line"><span class="function"><span class="title">CIDRsAllowed</span> []<span class="title">net</span>.<span class="title">IPNet</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="从create开始"><a href="#从create开始" class="headerlink" title="从create开始"></a>从create开始</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码来自github.com/hashicorp/memberlist/memberlist.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span><span class="params">(conf *Config)</span> <span class="params">(*Memberlist, error)</span></span> &#123;</span><br><span class="line">m, err := newMemberlist(conf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := m.setAlive(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">m.Shutdown()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">m.schedule()</span><br><span class="line"><span class="keyword">return</span> m, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面有两个重要步骤：</p><ul><li>newMemberlist</li><li>m.schedule</li></ul><h4 id="newMemberlist"><a href="#newMemberlist" class="headerlink" title="newMemberlist"></a>newMemberlist</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码来自github.com/hashicorp/memberlist/memberlist.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newMemberlist</span><span class="params">(conf *Config)</span> <span class="params">(*Memberlist, error)</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">m := &amp;Memberlist&#123;</span><br><span class="line">config:               conf,</span><br><span class="line">shutdownCh:           <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">leaveBroadcast:       <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>),</span><br><span class="line">transport:            nodeAwareTransport,</span><br><span class="line">handoffCh:            <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>),</span><br><span class="line">highPriorityMsgQueue: list.New(),</span><br><span class="line">lowPriorityMsgQueue:  list.New(),</span><br><span class="line">nodeMap:              <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*nodeState),</span><br><span class="line">nodeTimers:           <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*suspicion),</span><br><span class="line">awareness:            newAwareness(conf.AwarenessMaxMultiplier),</span><br><span class="line">ackHandlers:          <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">uint32</span>]*ackHandler),</span><br><span class="line">broadcasts:           &amp;TransmitLimitedQueue&#123;RetransmitMult: conf.RetransmitMult&#125;,</span><br><span class="line">logger:               logger,</span><br><span class="line">&#125;</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">go</span> m.streamListen()</span><br><span class="line"><span class="keyword">go</span> m.packetListen()</span><br><span class="line"><span class="keyword">go</span> m.packetHandler()</span><br><span class="line"><span class="keyword">return</span> m, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在newMemberlist中，最主要的动作就是开启了tcp服务(<code>m.streamListen()</code>)和udp服务(<code>m.packetListen()</code>)，那么就看看net服务（tcp和udp）：</p><h5 id="TCP-处理"><a href="#TCP-处理" class="headerlink" title="TCP 处理"></a>TCP 处理</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码来自github.com/hashicorp/memberlist/net.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Memberlist)</span> <span class="title">streamListen</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> conn := &lt;-m.transport.StreamCh(): <span class="comment">//tcp accept</span></span><br><span class="line">      <span class="comment">// 每个链接都有一个处理部分handleConn</span></span><br><span class="line"><span class="keyword">go</span> m.handleConn(conn)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> &lt;-m.shutdownCh:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看下处理函数 <code>m.handleConn(conn)</code></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码来自github.com/hashicorp/memberlist/net.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Memberlist)</span> <span class="title">handleConn</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line">m.logger.Printf(<span class="string">"[DEBUG] memberlist: Stream connection %s"</span>, LogConn(conn))</span><br><span class="line"></span><br><span class="line">metrics.IncrCounter([]<span class="keyword">string</span>&#123;<span class="string">"memberlist"</span>, <span class="string">"tcp"</span>, <span class="string">"accept"</span>&#125;, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">conn.SetDeadline(time.Now().Add(m.config.TCPTimeout))</span><br><span class="line">msgType, bufConn, dec, err := m.readStream(conn)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != io.EOF &#123;</span><br><span class="line">m.logger.Printf(<span class="string">"[ERR] memberlist: failed to receive: %s %s"</span>, err, LogConn(conn))</span><br><span class="line"></span><br><span class="line">resp := errResp&#123;err.Error()&#125;</span><br><span class="line">out, err := encode(errMsg, &amp;resp)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">m.logger.Printf(<span class="string">"[ERR] memberlist: Failed to encode error response: %s"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = m.rawSendMsgStream(conn, out.Bytes())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">m.logger.Printf(<span class="string">"[ERR] memberlist: Failed to send error: %s %s"</span>, err, LogConn(conn))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> msgType &#123;</span><br><span class="line"><span class="keyword">case</span> userMsg:</span><br><span class="line"><span class="keyword">if</span> err := m.readUserMsg(bufConn, dec); err != <span class="literal">nil</span> &#123;</span><br><span class="line">m.logger.Printf(<span class="string">"[ERR] memberlist: Failed to receive user message: %s %s"</span>, err, LogConn(conn))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> pushPullMsg:</span><br><span class="line"><span class="comment">// Increment counter of pending push/pulls</span></span><br><span class="line">numConcurrent := atomic.AddUint32(&amp;m.pushPullReq, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">defer</span> atomic.AddUint32(&amp;m.pushPullReq, ^<span class="keyword">uint32</span>(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if we have too many open push/pull requests</span></span><br><span class="line"><span class="keyword">if</span> numConcurrent &gt;= maxPushPullRequests &#123;</span><br><span class="line">m.logger.Printf(<span class="string">"[ERR] memberlist: Too many pending push/pull requests"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">join, remoteNodes, userState, err := m.readRemoteState(bufConn, dec)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">m.logger.Printf(<span class="string">"[ERR] memberlist: Failed to read remote state: %s %s"</span>, err, LogConn(conn))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := m.sendLocalState(conn, join); err != <span class="literal">nil</span> &#123;</span><br><span class="line">m.logger.Printf(<span class="string">"[ERR] memberlist: Failed to push local state: %s %s"</span>, err, LogConn(conn))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := m.mergeRemoteState(join, remoteNodes, userState); err != <span class="literal">nil</span> &#123;</span><br><span class="line">m.logger.Printf(<span class="string">"[ERR] memberlist: Failed push/pull merge: %s %s"</span>, err, LogConn(conn))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> pingMsg:</span><br><span class="line"><span class="keyword">var</span> p ping</span><br><span class="line"><span class="keyword">if</span> err := dec.Decode(&amp;p); err != <span class="literal">nil</span> &#123;</span><br><span class="line">m.logger.Printf(<span class="string">"[ERR] memberlist: Failed to decode ping: %s %s"</span>, err, LogConn(conn))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> p.Node != <span class="string">""</span> &amp;&amp; p.Node != m.config.Name &#123;</span><br><span class="line">m.logger.Printf(<span class="string">"[WARN] memberlist: Got ping for unexpected node %s %s"</span>, p.Node, LogConn(conn))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ack := ackResp&#123;p.SeqNo, <span class="literal">nil</span>&#125;</span><br><span class="line">out, err := encode(ackRespMsg, &amp;ack)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">m.logger.Printf(<span class="string">"[ERR] memberlist: Failed to encode ack: %s"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = m.rawSendMsgStream(conn, out.Bytes())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">m.logger.Printf(<span class="string">"[ERR] memberlist: Failed to send ack: %s %s"</span>, err, LogConn(conn))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">m.logger.Printf(<span class="string">"[ERR] memberlist: Received invalid msgType (%d) %s"</span>, msgType, LogConn(conn))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体来看，这个方法就是读取TCP流数据，然后对数据进行判断类型，进行相应的处理，ping包和user包暂时不看，看下pullPush的类型的处理，分为三步：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码来自github.com/hashicorp/memberlist/net.go</span></span><br><span class="line">    <span class="comment">// 读取Remote的状态</span></span><br><span class="line">    join, remoteNodes, userState, err := m.readRemoteState(bufConn, dec)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">m.logger.Printf(<span class="string">"[ERR] memberlist: Failed to read remote state: %s %s"</span>, err, LogConn(conn))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送本地节点的状态</span></span><br><span class="line"><span class="keyword">if</span> err := m.sendLocalState(conn, join); err != <span class="literal">nil</span> &#123;</span><br><span class="line">m.logger.Printf(<span class="string">"[ERR] memberlist: Failed to push local state: %s %s"</span>, err, LogConn(conn))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将收到的Remote状态进行更新</span></span><br><span class="line"><span class="keyword">if</span> err := m.mergeRemoteState(join, remoteNodes, userState); err != <span class="literal">nil</span> &#123;</span><br><span class="line">m.logger.Printf(<span class="string">"[ERR] memberlist: Failed push/pull merge: %s %s"</span>, err, LogConn(conn))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>可以看到tcp服务提供的功能就是：同步节点状态。</strong></p><p>分别砍下这三个步骤的处理</p><h6 id="readRemoteState"><a href="#readRemoteState" class="headerlink" title="readRemoteState"></a>readRemoteState</h6><p>读取节点状态信息，并返回</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码来自github.com/hashicorp/memberlist/net.go</span></span><br><span class="line"><span class="comment">// readRemoteState is used to read the remote state from a connection</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Memberlist)</span> <span class="title">readRemoteState</span><span class="params">(bufConn io.Reader, dec *codec.Decoder)</span> <span class="params">(<span class="keyword">bool</span>, []pushNodeState, []<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// Read the push/pull header</span></span><br><span class="line">  <span class="comment">// 读取数据</span></span><br><span class="line"><span class="keyword">var</span> header pushPullHeader</span><br><span class="line"><span class="keyword">if</span> err := dec.Decode(&amp;header); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate space for the transfer</span></span><br><span class="line">  <span class="comment">// 解码所有的节点信息</span></span><br><span class="line">remoteNodes := <span class="built_in">make</span>([]pushNodeState, header.Nodes)</span><br><span class="line"><span class="comment">// Try to decode all the states</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; header.Nodes; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> err := dec.Decode(&amp;remoteNodes[i]); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read the remote user state into a buffer</span></span><br><span class="line"><span class="keyword">var</span> userBuf []<span class="keyword">byte</span></span><br><span class="line"><span class="keyword">if</span> header.UserStateLen &gt; <span class="number">0</span> &#123;</span><br><span class="line">userBuf = <span class="built_in">make</span>([]<span class="keyword">byte</span>, header.UserStateLen)</span><br><span class="line">bytes, err := io.ReadAtLeast(bufConn, userBuf, header.UserStateLen)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; bytes != header.UserStateLen &#123;</span><br><span class="line">err = fmt.Errorf(</span><br><span class="line"><span class="string">"Failed to read full user state (%d / %d)"</span>,</span><br><span class="line">bytes, header.UserStateLen)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// For proto versions &lt; 2, there is no port provided. Mask old</span></span><br><span class="line"><span class="comment">// behavior by using the configured port</span></span><br><span class="line"><span class="keyword">for</span> idx := <span class="keyword">range</span> remoteNodes &#123;</span><br><span class="line"><span class="keyword">if</span> m.ProtocolVersion() &lt; <span class="number">2</span> || remoteNodes[idx].Port == <span class="number">0</span> &#123;</span><br><span class="line">remoteNodes[idx].Port = <span class="keyword">uint16</span>(m.config.BindPort)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回节点状态信息</span></span><br><span class="line"><span class="keyword">return</span> header.Join, remoteNodes, userBuf, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="sendLocalState"><a href="#sendLocalState" class="headerlink" title="sendLocalState"></a>sendLocalState</h6><p>发送本地存储的节点状态信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">// 代码来自github.com/hashicorp/memberlist/net.go</span><br><span class="line">// sendLocalState <span class="keyword">is</span> invoked to send our local state over a stream connection.</span><br><span class="line">func (m *Memberlist) sendLocalState(conn net.Conn, join bool) error &#123;</span><br><span class="line">// Setup a deadline</span><br><span class="line">conn.SetDeadline(time.Now().Add(m.config.TCPTimeout))</span><br><span class="line"></span><br><span class="line">// Prepare the local node state</span><br><span class="line">  // 收集本地存储的节点状态信息</span><br><span class="line">m.nodeLock.RLock()</span><br><span class="line">localNodes := make([]pushNodeState, len(m.nodes))</span><br><span class="line"><span class="keyword">for</span> idx, n := range m.nodes &#123;</span><br><span class="line">localNodes[idx].Name = n.Name</span><br><span class="line">localNodes[idx].Addr = n.Addr</span><br><span class="line">localNodes[idx].Port = n.Port</span><br><span class="line">localNodes[idx].Incarnation = n.Incarnation</span><br><span class="line">localNodes[idx].State = n.State</span><br><span class="line">localNodes[idx].Meta = n.Meta</span><br><span class="line">localNodes[idx].Vsn = []uint8&#123;</span><br><span class="line">n.PMin, n.PMax, n.PCur,</span><br><span class="line">n.DMin, n.DMax, n.DCur,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">m.nodeLock.RUnlock()</span><br><span class="line"></span><br><span class="line">// Get the delegate state</span><br><span class="line">var userData []byte</span><br><span class="line"><span class="keyword">if</span> m.config.Delegate != nil &#123;</span><br><span class="line">userData = m.config.Delegate.LocalState(join)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Create a bytes buffer writer</span><br><span class="line">bufConn := bytes.NewBuffer(nil)</span><br><span class="line"></span><br><span class="line">// Send our node state</span><br><span class="line">  // 添加头部信息</span><br><span class="line">header := pushPullHeader&#123;Nodes: len(localNodes), UserStateLen: len(userData), Join: join&#125;</span><br><span class="line">hd := codec.MsgpackHandle&#123;&#125;</span><br><span class="line">enc := codec.NewEncoder(bufConn, &amp;hd)</span><br><span class="line"></span><br><span class="line">// Begin state push</span><br><span class="line"><span class="keyword">if</span> _, err := bufConn.Write([]byte&#123;byte(pushPullMsg)&#125;); err != nil &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  // 编码并发送</span><br><span class="line"><span class="keyword">if</span> err := enc.Encode(&amp;header); err != nil &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; header.Nodes; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> err := enc.Encode(&amp;localNodes[i]); err != nil &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Write the user state <span class="keyword">as</span> well</span><br><span class="line"><span class="keyword">if</span> userData != nil &#123;</span><br><span class="line"><span class="keyword">if</span> _, err := bufConn.Write(userData); err != nil &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Get the send buffer</span><br><span class="line"><span class="keyword">return</span> m.rawSendMsgStream(conn, bufConn.Bytes())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="mergeRemoteState"><a href="#mergeRemoteState" class="headerlink" title="mergeRemoteState"></a>mergeRemoteState</h6><p>更新节点状态</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码来自github.com/hashicorp/memberlist/net.go</span></span><br><span class="line"><span class="comment">// mergeRemoteState is used to merge the remote state with our local state</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Memberlist)</span> <span class="title">mergeRemoteState</span><span class="params">(join <span class="keyword">bool</span>, remoteNodes []pushNodeState, userBuf []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := m.verifyProtocol(remoteNodes); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoke the merge delegate if any</span></span><br><span class="line"><span class="keyword">if</span> join &amp;&amp; m.config.Merge != <span class="literal">nil</span> &#123;</span><br><span class="line">nodes := <span class="built_in">make</span>([]*Node, <span class="built_in">len</span>(remoteNodes))</span><br><span class="line"><span class="keyword">for</span> idx, n := <span class="keyword">range</span> remoteNodes &#123;</span><br><span class="line">nodes[idx] = &amp;Node&#123;</span><br><span class="line">Name:  n.Name,</span><br><span class="line">Addr:  n.Addr,</span><br><span class="line">Port:  n.Port,</span><br><span class="line">Meta:  n.Meta,</span><br><span class="line">State: n.State,</span><br><span class="line">PMin:  n.Vsn[<span class="number">0</span>],</span><br><span class="line">PMax:  n.Vsn[<span class="number">1</span>],</span><br><span class="line">PCur:  n.Vsn[<span class="number">2</span>],</span><br><span class="line">DMin:  n.Vsn[<span class="number">3</span>],</span><br><span class="line">DMax:  n.Vsn[<span class="number">4</span>],</span><br><span class="line">DCur:  n.Vsn[<span class="number">5</span>],</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := m.config.Merge.NotifyMerge(nodes); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Merge the membership state</span></span><br><span class="line">m.mergeState(remoteNodes)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoke the delegate for user state</span></span><br><span class="line"><span class="keyword">if</span> userBuf != <span class="literal">nil</span> &amp;&amp; m.config.Delegate != <span class="literal">nil</span> &#123;</span><br><span class="line">m.config.Delegate.MergeRemoteState(userBuf, join)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码来自github.com/hashicorp/memberlist/state.go</span></span><br><span class="line"><span class="comment">// mergeState is invoked by the network layer when we get a Push/Pull</span></span><br><span class="line"><span class="comment">// state transfer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Memberlist)</span> <span class="title">mergeState</span><span class="params">(remote []pushNodeState)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> remote &#123;</span><br><span class="line"><span class="keyword">switch</span> r.State &#123;</span><br><span class="line"><span class="keyword">case</span> StateAlive:</span><br><span class="line">a := alive&#123;</span><br><span class="line">Incarnation: r.Incarnation,</span><br><span class="line">Node:        r.Name,</span><br><span class="line">Addr:        r.Addr,</span><br><span class="line">Port:        r.Port,</span><br><span class="line">Meta:        r.Meta,</span><br><span class="line">Vsn:         r.Vsn,</span><br><span class="line">&#125;</span><br><span class="line">m.aliveNode(&amp;a, <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> StateLeft:</span><br><span class="line">d := dead&#123;Incarnation: r.Incarnation, Node: r.Name, From: r.Name&#125;</span><br><span class="line">m.deadNode(&amp;d)</span><br><span class="line"><span class="keyword">case</span> StateDead:</span><br><span class="line"><span class="comment">// If the remote node believes a node is dead, we prefer to</span></span><br><span class="line"><span class="comment">// suspect that node instead of declaring it dead instantly</span></span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> StateSuspect:</span><br><span class="line">s := suspect&#123;Incarnation: r.Incarnation, Node: r.Name, From: m.config.Name&#125;</span><br><span class="line">m.suspectNode(&amp;s)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在四种状态处理：</p><ul><li>StateAlive</li><li>StateLeft</li><li>StateDead/StateSuspect</li></ul><p>这几种状态的处理在后面说</p><p><strong>到这里小结一下，tcp链接，主要处理节点状态信息的同步与更新。</strong></p><h5 id="UDP-处理"><a href="#UDP-处理" class="headerlink" title="UDP 处理"></a>UDP 处理</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码来自github.com/hashicorp/memberlist/net.go</span></span><br><span class="line"><span class="comment">// packetListen is a long running goroutine that pulls packets out of the</span></span><br><span class="line"><span class="comment">// transport and hands them off for processing.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Memberlist)</span> <span class="title">packetListen</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> packet := &lt;-m.transport.PacketCh():</span><br><span class="line">m.ingestPacket(packet.Buf, packet.From, packet.Timestamp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> &lt;-m.shutdownCh:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Memberlist)</span> <span class="title">ingestPacket</span><span class="params">(buf []<span class="keyword">byte</span>, from net.Addr, timestamp time.Time)</span></span> &#123;</span><br><span class="line"><span class="comment">// Check if encryption is enabled</span></span><br><span class="line"><span class="keyword">if</span> m.config.EncryptionEnabled() &#123;</span><br><span class="line"><span class="comment">// Decrypt the payload</span></span><br><span class="line">    <span class="comment">// 读取数据</span></span><br><span class="line">plain, err := decryptPayload(m.config.Keyring.GetKeys(), buf, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> !m.config.GossipVerifyIncoming &#123;</span><br><span class="line"><span class="comment">// Treat the message as plaintext</span></span><br><span class="line">plain = buf</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">m.logger.Printf(<span class="string">"[ERR] memberlist: Decrypt packet failed: %v %s"</span>, err, LogAddress(from))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Continue processing the plaintext buffer</span></span><br><span class="line">buf = plain</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// See if there's a checksum included to verify the contents of the message</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(buf) &gt;= <span class="number">5</span> &amp;&amp; messageType(buf[<span class="number">0</span>]) == hasCrcMsg &#123;</span><br><span class="line">crc := crc32.ChecksumIEEE(buf[<span class="number">5</span>:])</span><br><span class="line">expected := binary.BigEndian.Uint32(buf[<span class="number">1</span>:<span class="number">5</span>])</span><br><span class="line"><span class="keyword">if</span> crc != expected &#123;</span><br><span class="line">m.logger.Printf(<span class="string">"[WARN] memberlist: Got invalid checksum for UDP packet: %x, %x"</span>, crc, expected)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 处理函数</span></span><br><span class="line">m.handleCommand(buf[<span class="number">5</span>:], from, timestamp)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">m.handleCommand(buf, from, timestamp)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="handleCommand"><a href="#handleCommand" class="headerlink" title="handleCommand"></a>handleCommand</h6><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Memberlist)</span> <span class="title">handleCommand</span><span class="params">(buf []<span class="keyword">byte</span>, from net.Addr, timestamp time.Time)</span></span> &#123;</span><br><span class="line"><span class="comment">// Decode the message type</span></span><br><span class="line">  <span class="comment">// 解码消息类型</span></span><br><span class="line">msgType := messageType(buf[<span class="number">0</span>])</span><br><span class="line">buf = buf[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment">// Switch on the msgType</span></span><br><span class="line">  <span class="comment">// 根据消息不同消息类型，进行不同的处理</span></span><br><span class="line"><span class="keyword">switch</span> msgType &#123;</span><br><span class="line"><span class="keyword">case</span> compoundMsg:</span><br><span class="line">m.handleCompound(buf, from, timestamp)</span><br><span class="line"><span class="keyword">case</span> compressMsg:</span><br><span class="line">m.handleCompressed(buf, from, timestamp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> pingMsg:</span><br><span class="line">m.handlePing(buf, from)</span><br><span class="line"><span class="keyword">case</span> indirectPingMsg:</span><br><span class="line">m.handleIndirectPing(buf, from)</span><br><span class="line"><span class="keyword">case</span> ackRespMsg:</span><br><span class="line">m.handleAck(buf, from, timestamp)</span><br><span class="line"><span class="keyword">case</span> nackRespMsg:</span><br><span class="line">m.handleNack(buf, from)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> suspectMsg:</span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> aliveMsg:</span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> deadMsg:</span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> userMsg:</span><br><span class="line"><span class="comment">// Determine the message queue, prioritize alive</span></span><br><span class="line">queue := m.lowPriorityMsgQueue</span><br><span class="line"><span class="keyword">if</span> msgType == aliveMsg &#123;</span><br><span class="line">queue = m.highPriorityMsgQueue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for overflow and append if not full</span></span><br><span class="line">m.msgQueueLock.Lock()</span><br><span class="line"><span class="keyword">if</span> queue.Len() &gt;= m.config.HandoffQueueDepth &#123;</span><br><span class="line">m.logger.Printf(<span class="string">"[WARN] memberlist: handler queue full, dropping message (%d) %s"</span>, msgType, LogAddress(from))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">queue.PushBack(msgHandoff&#123;msgType, buf, from&#125;)</span><br><span class="line">&#125;</span><br><span class="line">m.msgQueueLock.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Notify of pending message</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> m.handoffCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">m.logger.Printf(<span class="string">"[ERR] memberlist: msg type (%d) not supported %s"</span>, msgType, LogAddress(from))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>compoundMsg：处理函数为handleCompound，多个消息聚合在一起，进行分割，然后再重新调用handleCommand.</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Memberlist)</span> <span class="title">handleCompound</span><span class="params">(buf []<span class="keyword">byte</span>, from net.Addr, timestamp time.Time)</span></span> &#123;</span><br><span class="line"><span class="comment">// Decode the parts</span></span><br><span class="line">  <span class="comment">// 消息分割</span></span><br><span class="line">trunc, parts, err := decodeCompoundMessage(buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">m.logger.Printf(<span class="string">"[ERR] memberlist: Failed to decode compound request: %s %s"</span>, err, LogAddress(from))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Log any truncation</span></span><br><span class="line"><span class="keyword">if</span> trunc &gt; <span class="number">0</span> &#123;</span><br><span class="line">m.logger.Printf(<span class="string">"[WARN] memberlist: Compound request had %d truncated messages %s"</span>, trunc, LogAddress(from))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle each message</span></span><br><span class="line"><span class="keyword">for</span> _, part := <span class="keyword">range</span> parts &#123;</span><br><span class="line">    <span class="comment">// 分割的消息重新调用handleCommand</span></span><br><span class="line">m.handleCommand(part, from, timestamp)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>pingMsg：处理函数为：handlePing;</p></li><li><p>indirectPingMsg: 处理函数为handleindirectPing;</p></li><li><p>ackRespMsg: 处理函数为handleAck</p></li><li><p>suspectMsg/aliveMsg/deadMsg/userMsg: 处理函数为：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Determine the message queue, prioritize alive</span></span><br><span class="line">queue := m.lowPriorityMsgQueue</span><br><span class="line"><span class="keyword">if</span> msgType == aliveMsg &#123;</span><br><span class="line">queue = m.highPriorityMsgQueue</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// Check for overflow and append if not full</span></span><br><span class="line">m.msgQueueLock.Lock()</span><br><span class="line"><span class="keyword">if</span> queue.Len() &gt;= m.config.HandoffQueueDepth &#123;</span><br><span class="line">m.logger.Printf(<span class="string">"[WARN] memberlist: handler queue full, dropping message (%d) %s"</span>, msgType, LogAddress(from))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">queue.PushBack(msgHandoff&#123;msgType, buf, from&#125;)</span><br><span class="line">&#125;</span><br><span class="line">m.msgQueueLock.Unlock()</span><br><span class="line">  </span><br><span class="line"><span class="comment">// Notify of pending message</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> m.handoffCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">m.logger.Printf(<span class="string">"[ERR] memberlist: msg type (%d) not supported %s"</span>, msgType, LogAddress(from))</span><br></pre></td></tr></table></figure><p>m.handoffCh &lt;- struct{}{}，是否还记得上面开启TCP和UDP的时候，还有一个协程运行着：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> m.streamListen()</span><br><span class="line"><span class="keyword">go</span> m.packetListen()</span><br><span class="line"><span class="keyword">go</span> m.packetHandler()</span><br></pre></td></tr></table></figure><p><code>go m.packetHandler()</code></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packetHandler is a long running goroutine that processes messages received</span></span><br><span class="line"><span class="comment">// over the packet interface, but is decoupled from the listener to avoid</span></span><br><span class="line"><span class="comment">// blocking the listener which may cause ping/ack messages to be delayed.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Memberlist)</span> <span class="title">packetHandler</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-m.handoffCh:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">msg, ok := m.getNextMessage()</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">msgType := msg.msgType</span><br><span class="line">buf := msg.buf</span><br><span class="line">from := msg.from</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> msgType &#123;</span><br><span class="line"><span class="keyword">case</span> suspectMsg:</span><br><span class="line">m.handleSuspect(buf, from)</span><br><span class="line"><span class="keyword">case</span> aliveMsg:</span><br><span class="line">m.handleAlive(buf, from)</span><br><span class="line"><span class="keyword">case</span> deadMsg:</span><br><span class="line">m.handleDead(buf, from)</span><br><span class="line"><span class="keyword">case</span> userMsg:</span><br><span class="line">m.handleUser(buf, from)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">m.logger.Printf(<span class="string">"[ERR] memberlist: Message type (%d) not supported %s (packet handler)"</span>, msgType, LogAddress(from))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> &lt;-m.shutdownCh:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里监听 m.handoffCh，当UDP有消息传过来时，分别处理以下类型的消息，就不展开了</p></li><li><p>suspectMsg</p></li><li><p>aliveMsg</p></li><li><p>deadMsg</p></li><li><p>userMsg</p></li></ul><p><strong>udp服务提供了一些基本的Command操作</strong></p><h4 id="schedule"><a href="#schedule" class="headerlink" title="schedule"></a>schedule</h4><ul><li>Schedule函数开启probe协程、pushpull协程、gossip协程</li><li>probe协程：进行节点状态维护</li><li>push/pull协程：进行节点状态、用户数据同步</li><li>gossip协程：进行udp广播发送消息。</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Schedule is used to ensure the Tick is performed periodically. This</span></span><br><span class="line"><span class="comment">// function is safe to call multiple times. If the memberlist is already</span></span><br><span class="line"><span class="comment">// scheduled, then it won't do anything.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Memberlist)</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line">m.tickerLock.Lock()</span><br><span class="line"><span class="keyword">defer</span> m.tickerLock.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// If we already have tickers, then don't do anything, since we're</span></span><br><span class="line"><span class="comment">// scheduled</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(m.tickers) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the stop tick channel, a blocking channel. We close this</span></span><br><span class="line"><span class="comment">// when we should stop the tickers.</span></span><br><span class="line">stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new probeTicker</span></span><br><span class="line">  <span class="comment">// 开启了probe协程</span></span><br><span class="line"><span class="keyword">if</span> m.config.ProbeInterval &gt; <span class="number">0</span> &#123;</span><br><span class="line">t := time.NewTicker(m.config.ProbeInterval)</span><br><span class="line"><span class="keyword">go</span> m.triggerFunc(m.config.ProbeInterval, t.C, stopCh, m.probe)</span><br><span class="line">m.tickers = <span class="built_in">append</span>(m.tickers, t)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a push pull ticker if needed</span></span><br><span class="line">  <span class="comment">// 开启了pushpull协程</span></span><br><span class="line"><span class="keyword">if</span> m.config.PushPullInterval &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">go</span> m.pushPullTrigger(stopCh)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a gossip ticker if needed</span></span><br><span class="line">  <span class="comment">// 开启了gossip协程</span></span><br><span class="line"><span class="keyword">if</span> m.config.GossipInterval &gt; <span class="number">0</span> &amp;&amp; m.config.GossipNodes &gt; <span class="number">0</span> &#123;</span><br><span class="line">t := time.NewTicker(m.config.GossipInterval)</span><br><span class="line"><span class="keyword">go</span> m.triggerFunc(m.config.GossipInterval, t.C, stopCh, m.gossip)</span><br><span class="line">m.tickers = <span class="built_in">append</span>(m.tickers, t)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If we made any tickers, then record the stopTick channel for</span></span><br><span class="line"><span class="comment">// later.</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(m.tickers) &gt; <span class="number">0</span> &#123;</span><br><span class="line">m.stopTick = stopCh</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里面一共开启了三个定时任务，probe、pushpull、gossip</p><h5 id="probe"><a href="#probe" class="headerlink" title="probe"></a>probe</h5><blockquote><p>当节点启动后，每隔一定时间间隔，会选取一个节点对其发送PING消息，当PING消息失败后，会随机选取 IndirectChecks 个节点发起间接PING的请求和直接更其再发起一个tcp PING消息。 收到间接PING请求的节点会根据请求中的地址发起一个PING消息，将PING的结果返回给间接请求的源节点。 如果探测超时之间内，本节点没有收到任何一个要探测节点的ACK消息，则标记要探测的节点状态为suspect。</p><p><a href="https://www.colabug.com/1010287.html" target="_blank" rel="external">https://www.colabug.com/1010287.html</a></p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tick is used to perform a single round of failure detection and gossip</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Memberlist)</span> <span class="title">probe</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Track the number of indexes we've considered probing</span></span><br><span class="line">numCheck := <span class="number">0</span></span><br><span class="line">START:</span><br><span class="line">m.nodeLock.RLock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make sure we don't wrap around infinitely</span></span><br><span class="line"><span class="keyword">if</span> numCheck &gt;= <span class="built_in">len</span>(m.nodes) &#123;</span><br><span class="line">m.nodeLock.RUnlock()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle the wrap around case</span></span><br><span class="line">  <span class="comment">// probeIndex是node索引，循环进行探测</span></span><br><span class="line"><span class="keyword">if</span> m.probeIndex &gt;= <span class="built_in">len</span>(m.nodes) &#123;</span><br><span class="line">m.nodeLock.RUnlock()</span><br><span class="line">m.resetNodes()</span><br><span class="line">m.probeIndex = <span class="number">0</span></span><br><span class="line">numCheck++</span><br><span class="line"><span class="keyword">goto</span> START</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Determine if we should probe this node</span></span><br><span class="line">skip := <span class="literal">false</span></span><br><span class="line"><span class="keyword">var</span> node nodeState</span><br><span class="line"></span><br><span class="line">node = *m.nodes[m.probeIndex]</span><br><span class="line"><span class="keyword">if</span> node.Name == m.config.Name &#123;</span><br><span class="line">skip = <span class="literal">true</span> <span class="comment">//当node在配置文件中</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> node.DeadOrLeft() &#123;</span><br><span class="line">skip = <span class="literal">true</span> <span class="comment">//当node为dead时候</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Potentially skip</span></span><br><span class="line">m.nodeLock.RUnlock()</span><br><span class="line">m.probeIndex++</span><br><span class="line"><span class="keyword">if</span> skip &#123; <span class="comment">//node在配置文件中或者为dead时候则跳过</span></span><br><span class="line">numCheck++</span><br><span class="line"><span class="keyword">goto</span> START</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Probe the specific node</span></span><br><span class="line">m.probeNode(&amp;node)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// probeNode handles a single round of failure checking on a node.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Memberlist)</span> <span class="title">probeNode</span><span class="params">(node *nodeState)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> metrics.MeasureSince([]<span class="keyword">string</span>&#123;<span class="string">"memberlist"</span>, <span class="string">"probeNode"</span>&#125;, time.Now())</span><br><span class="line"></span><br><span class="line"><span class="comment">// We use our health awareness to scale the overall probe interval, so we</span></span><br><span class="line"><span class="comment">// slow down if we detect problems. The ticker that calls us can handle</span></span><br><span class="line"><span class="comment">// us running over the base interval, and will skip missed ticks.</span></span><br><span class="line">probeInterval := m.awareness.ScaleTimeout(m.config.ProbeInterval)</span><br><span class="line"><span class="keyword">if</span> probeInterval &gt; m.config.ProbeInterval &#123;</span><br><span class="line">metrics.IncrCounter([]<span class="keyword">string</span>&#123;<span class="string">"memberlist"</span>, <span class="string">"degraded"</span>, <span class="string">"probe"</span>&#125;, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare a ping message and setup an ack handler.</span></span><br><span class="line">selfAddr, selfPort := m.getAdvertise()</span><br><span class="line">ping := ping&#123;</span><br><span class="line">SeqNo:      m.nextSeqNo(),</span><br><span class="line">Node:       node.Name,</span><br><span class="line">SourceAddr: selfAddr,</span><br><span class="line">SourcePort: selfPort,</span><br><span class="line">SourceNode: m.config.Name,</span><br><span class="line">&#125;</span><br><span class="line">ackCh := <span class="built_in">make</span>(<span class="keyword">chan</span> ackMessage, m.config.IndirectChecks+<span class="number">1</span>)</span><br><span class="line">nackCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, m.config.IndirectChecks+<span class="number">1</span>)</span><br><span class="line">m.setProbeChannels(ping.SeqNo, ackCh, nackCh, probeInterval)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mark the sent time here, which should be after any pre-processing but</span></span><br><span class="line"><span class="comment">// before system calls to do the actual send. This probably over-reports</span></span><br><span class="line"><span class="comment">// a bit, but it's the best we can do. We had originally put this right</span></span><br><span class="line"><span class="comment">// after the I/O, but that would sometimes give negative RTT measurements</span></span><br><span class="line"><span class="comment">// which was not desirable.</span></span><br><span class="line">sent := time.Now()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send a ping to the node. If this node looks like it's suspect or dead,</span></span><br><span class="line"><span class="comment">// also tack on a suspect message so that it has a chance to refute as</span></span><br><span class="line"><span class="comment">// soon as possible.</span></span><br><span class="line">deadline := sent.Add(probeInterval)</span><br><span class="line">addr := node.Address()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Arrange for our self-awareness to get updated.</span></span><br><span class="line"><span class="keyword">var</span> awarenessDelta <span class="keyword">int</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">m.awareness.ApplyDelta(awarenessDelta)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">if</span> node.State == StateAlive &#123;</span><br><span class="line">    <span class="comment">// 发送pingMsg</span></span><br><span class="line"><span class="keyword">if</span> err := m.encodeAndSendMsg(node.FullAddress(), pingMsg, &amp;ping); err != <span class="literal">nil</span> &#123;</span><br><span class="line">m.logger.Printf(<span class="string">"[ERR] memberlist: Failed to send ping: %s"</span>, err)</span><br><span class="line"><span class="keyword">if</span> failedRemote(err) &#123;</span><br><span class="line"><span class="keyword">goto</span> HANDLE_REMOTE_FAILURE</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">HANDLE_REMOTE_FAILURE:</span><br><span class="line"><span class="comment">// Get some random live nodes.</span></span><br><span class="line">m.nodeLock.RLock()</span><br><span class="line">  <span class="comment">// 随机获取一些节点</span></span><br><span class="line">kNodes := kRandomNodes(m.config.IndirectChecks, m.nodes, <span class="function"><span class="keyword">func</span><span class="params">(n *nodeState)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> n.Name == m.config.Name ||</span><br><span class="line">n.Name == node.Name ||</span><br><span class="line">n.State != StateAlive</span><br><span class="line">&#125;)</span><br><span class="line">m.nodeLock.RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Attempt an indirect ping.</span></span><br><span class="line">expectedNacks := <span class="number">0</span></span><br><span class="line">selfAddr, selfPort = m.getAdvertise()</span><br><span class="line">ind := indirectPingReq&#123;</span><br><span class="line">SeqNo:      ping.SeqNo,</span><br><span class="line">Target:     node.Addr,</span><br><span class="line">Port:       node.Port,</span><br><span class="line">Node:       node.Name,</span><br><span class="line">SourceAddr: selfAddr,</span><br><span class="line">SourcePort: selfPort,</span><br><span class="line">SourceNode: m.config.Name,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, peer := <span class="keyword">range</span> kNodes &#123;</span><br><span class="line"><span class="comment">// We only expect nack to be sent from peers who understand</span></span><br><span class="line"><span class="comment">// version 4 of the protocol.</span></span><br><span class="line"><span class="keyword">if</span> ind.Nack = peer.PMax &gt;= <span class="number">4</span>; ind.Nack &#123;</span><br><span class="line">expectedNacks++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送indirectPingMsg</span></span><br><span class="line"><span class="keyword">if</span> err := m.encodeAndSendMsg(peer.FullAddress(), indirectPingMsg, &amp;ind); err != <span class="literal">nil</span> &#123;</span><br><span class="line">m.logger.Printf(<span class="string">"[ERR] memberlist: Failed to send indirect ping: %s"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Also make an attempt to contact the node directly over TCP. This</span></span><br><span class="line"><span class="comment">// helps prevent confused clients who get isolated from UDP traffic</span></span><br><span class="line"><span class="comment">// but can still speak TCP (which also means they can possibly report</span></span><br><span class="line"><span class="comment">// misinformation to other nodes via anti-entropy), avoiding flapping in</span></span><br><span class="line"><span class="comment">// the cluster.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This is a little unusual because we will attempt a TCP ping to any</span></span><br><span class="line"><span class="comment">// member who understands version 3 of the protocol, regardless of</span></span><br><span class="line"><span class="comment">// which protocol version we are speaking. That's why we've included a</span></span><br><span class="line"><span class="comment">// config option to turn this off if desired.</span></span><br><span class="line">fallbackCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">disableTcpPings := m.config.DisableTcpPings ||</span><br><span class="line">(m.config.DisableTcpPingsForNode != <span class="literal">nil</span> &amp;&amp; m.config.DisableTcpPingsForNode(node.Name))</span><br><span class="line"><span class="keyword">if</span> (!disableTcpPings) &amp;&amp; (node.PMax &gt;= <span class="number">3</span>) &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(fallbackCh)</span><br><span class="line">didContact, err := m.sendPingAndWaitForAck(node.FullAddress(), ping, deadline)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">m.logger.Printf(<span class="string">"[ERR] memberlist: Failed fallback ping: %s"</span>, err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fallbackCh &lt;- didContact</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">close</span>(fallbackCh)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait for the acks or timeout. Note that we don't check the fallback</span></span><br><span class="line"><span class="comment">// channel here because we want to issue a warning below if that's the</span></span><br><span class="line"><span class="comment">// *only* way we hear back from the peer, so we have to let this time</span></span><br><span class="line"><span class="comment">// out first to allow the normal UDP-based acks to come in.</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> v := &lt;-ackCh:</span><br><span class="line"><span class="keyword">if</span> v.Complete == <span class="literal">true</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Finally, poll the fallback channel. The timeouts are set such that</span></span><br><span class="line"><span class="comment">// the channel will have something or be closed without having to wait</span></span><br><span class="line"><span class="comment">// any additional time here.</span></span><br><span class="line"><span class="keyword">for</span> didContact := <span class="keyword">range</span> fallbackCh &#123;</span><br><span class="line"><span class="keyword">if</span> didContact &#123;</span><br><span class="line">m.logger.Printf(<span class="string">"[WARN] memberlist: Was able to connect to %s but other probes failed, network may be misconfigured"</span>, node.Name)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update our self-awareness based on the results of this failed probe.</span></span><br><span class="line"><span class="comment">// If we don't have peers who will send nacks then we penalize for any</span></span><br><span class="line"><span class="comment">// failed probe as a simple health metric. If we do have peers to nack</span></span><br><span class="line"><span class="comment">// verify, then we can use that as a more sophisticated measure of self-</span></span><br><span class="line"><span class="comment">// health because we assume them to be working, and they can help us</span></span><br><span class="line"><span class="comment">// decide if the probed node was really dead or if it was something wrong</span></span><br><span class="line"><span class="comment">// with ourselves.</span></span><br><span class="line">awarenessDelta = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> expectedNacks &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> nackCount := <span class="built_in">len</span>(nackCh); nackCount &lt; expectedNacks &#123;</span><br><span class="line">awarenessDelta += (expectedNacks - nackCount)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">awarenessDelta += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// No acks received from target, suspect it as failed.</span></span><br><span class="line">m.logger.Printf(<span class="string">"[INFO] memberlist: Suspect %s has failed, no acks received"</span>, node.Name)</span><br><span class="line">  <span class="comment">//若探测结果失败则将node设置为suspect</span></span><br><span class="line">s := suspect&#123;Incarnation: node.Incarnation, Node: node.Name, From: m.config.Name&#125;</span><br><span class="line">m.suspectNode(&amp;s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="pushpull"><a href="#pushpull" class="headerlink" title="pushpull"></a>pushpull</h5><blockquote><p>每隔一个时间间隔，随机选取一个节点，跟它建立tcp连接，然后将本地的全部节点 状态、用户数据发送过去，然后对端将其掌握的全部节点状态、用户数据发送回来，然后完成2份数据的合并。 此动作可以加速集群内信息的收敛速度。</p><p><a href="https://www.jianshu.com/p/e2173b44db65" target="_blank" rel="external">https://www.jianshu.com/p/e2173b44db65</a></p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Memberlist)</span> <span class="title">pushPullTrigger</span><span class="params">(stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">interval := m.config.PushPullInterval</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use a random stagger to avoid syncronizing</span></span><br><span class="line">randStagger := time.Duration(<span class="keyword">uint64</span>(rand.Int63()) % <span class="keyword">uint64</span>(interval))</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(randStagger):</span><br><span class="line"><span class="keyword">case</span> &lt;-stop:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tick using a dynamic timer</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">tickTime := pushPullScale(interval, m.estNumNodes())</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(tickTime):</span><br><span class="line">m.pushPull()</span><br><span class="line"><span class="keyword">case</span> &lt;-stop:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Memberlist)</span> <span class="title">pushPull</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Get a random live node</span></span><br><span class="line">m.nodeLock.RLock()</span><br><span class="line">  <span class="comment">// 随机选取1个节点</span></span><br><span class="line">nodes := kRandomNodes(<span class="number">1</span>, m.nodes, <span class="function"><span class="keyword">func</span><span class="params">(n *nodeState)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> n.Name == m.config.Name ||</span><br><span class="line">n.State != StateAlive</span><br><span class="line">&#125;)</span><br><span class="line">m.nodeLock.RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// If no nodes, bail</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nodes) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">node := nodes[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// Attempt a push pull</span></span><br><span class="line">  <span class="comment">// 调用pushPullNode</span></span><br><span class="line"><span class="keyword">if</span> err := m.pushPullNode(node.FullAddress(), <span class="literal">false</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">m.logger.Printf(<span class="string">"[ERR] memberlist: Push/Pull with %s failed: %s"</span>, node.Name, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面随机选取一个节点</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pushPullNode does a complete state exchange with a specific node.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Memberlist)</span> <span class="title">pushPullNode</span><span class="params">(a Address, join <span class="keyword">bool</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> metrics.MeasureSince([]<span class="keyword">string</span>&#123;<span class="string">"memberlist"</span>, <span class="string">"pushPullNode"</span>&#125;, time.Now())</span><br><span class="line"></span><br><span class="line"><span class="comment">// Attempt to send and receive with the node</span></span><br><span class="line">  <span class="comment">// 发送并获取状态信息</span></span><br><span class="line">remote, userState, err := m.sendAndReceiveState(a, join)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 合并更新节点状态信息</span></span><br><span class="line"><span class="keyword">if</span> err := m.mergeRemoteState(join, remote, userState); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sendAndReceiveState is used to initiate a push/pull over a stream with a</span></span><br><span class="line"><span class="comment">// remote host.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Memberlist)</span> <span class="title">sendAndReceiveState</span><span class="params">(a Address, join <span class="keyword">bool</span>)</span> <span class="params">([]pushNodeState, []<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a.Name == <span class="string">""</span> &amp;&amp; m.config.RequireNodeNames &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, errNodeNamesAreRequired</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Attempt to connect</span></span><br><span class="line">  <span class="comment">// 创建tcp client链接</span></span><br><span class="line">conn, err := m.transport.DialAddressTimeout(a, m.config.TCPTimeout)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line">m.logger.Printf(<span class="string">"[DEBUG] memberlist: Initiating push/pull sync with: %s %s"</span>, a.Name, conn.RemoteAddr())</span><br><span class="line">metrics.IncrCounter([]<span class="keyword">string</span>&#123;<span class="string">"memberlist"</span>, <span class="string">"tcp"</span>, <span class="string">"connect"</span>&#125;, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send our state</span></span><br><span class="line">  <span class="comment">// 发送本地节点状态信息</span></span><br><span class="line"><span class="keyword">if</span> err := m.sendLocalState(conn, join); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">conn.SetDeadline(time.Now().Add(m.config.TCPTimeout))</span><br><span class="line">msgType, bufConn, dec, err := m.readStream(conn)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> msgType == errMsg &#123;</span><br><span class="line"><span class="keyword">var</span> resp errResp</span><br><span class="line"><span class="keyword">if</span> err := dec.Decode(&amp;resp); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">"remote error: %v"</span>, resp.Error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Quit if not push/pull</span></span><br><span class="line"><span class="keyword">if</span> msgType != pushPullMsg &#123;</span><br><span class="line">err := fmt.Errorf(<span class="string">"received invalid msgType (%d), expected pushPullMsg (%d) %s"</span>, msgType, pushPullMsg, LogConn(conn))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read remote state</span></span><br><span class="line">  <span class="comment">// 读取Remote节点状态信息并返回</span></span><br><span class="line">_, remoteNodes, userState, err := m.readRemoteState(bufConn, dec)</span><br><span class="line"><span class="keyword">return</span> remoteNodes, userState, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="gossip"><a href="#gossip" class="headerlink" title="gossip"></a>gossip</h5><blockquote><p>节点通过udp协议向K个节点发送消息，节点从广播队列里面获取消息，广播队列里的消息发送失败超过一定次数后，消息就会被丢弃。发送次数参考Config 里的 RetransmitMul的注释。</p><p><a href="https://www.jianshu.com/p/e2173b44db65" target="_blank" rel="external">https://www.jianshu.com/p/e2173b44db65</a></p></blockquote><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gossip is invoked every GossipInterval period to broadcast our gossip</span></span><br><span class="line"><span class="comment">// messages to a few random nodes.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Memberlist)</span> <span class="title">gossip</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> metrics.MeasureSince([]<span class="keyword">string</span>&#123;<span class="string">"memberlist"</span>, <span class="string">"gossip"</span>&#125;, time.Now())</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get some random live, suspect, or recently dead nodes</span></span><br><span class="line">m.nodeLock.RLock()</span><br><span class="line">  <span class="comment">// 随机获取gossipNodes配置项个数的节点</span></span><br><span class="line">kNodes := kRandomNodes(m.config.GossipNodes, m.nodes, <span class="function"><span class="keyword">func</span><span class="params">(n *nodeState)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> n.Name == m.config.Name &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> n.State &#123;</span><br><span class="line"><span class="keyword">case</span> StateAlive, StateSuspect:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> StateDead:</span><br><span class="line"><span class="keyword">return</span> time.Since(n.StateChange) &gt; m.config.GossipToTheDeadTime</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">m.nodeLock.RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compute the bytes available</span></span><br><span class="line">bytesAvail := m.config.UDPBufferSize - compoundHeaderOverhead</span><br><span class="line"><span class="keyword">if</span> m.config.EncryptionEnabled() &#123;</span><br><span class="line">bytesAvail -= encryptOverhead(m.encryptionVersion())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, node := <span class="keyword">range</span> kNodes &#123;</span><br><span class="line"><span class="comment">// Get any pending broadcasts</span></span><br><span class="line">    <span class="comment">// 获取能够广播消息大小</span></span><br><span class="line">msgs := m.getBroadcasts(compoundOverhead, bytesAvail)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(msgs) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addr := node.Address()</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(msgs) == <span class="number">1</span> &#123;</span><br><span class="line"><span class="comment">// Send single message as is</span></span><br><span class="line"><span class="keyword">if</span> err := m.rawSendMsgPacket(node.FullAddress(), &amp;node.Node, msgs[<span class="number">0</span>]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">m.logger.Printf(<span class="string">"[ERR] memberlist: Failed to send gossip to %s: %s"</span>, addr, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Otherwise create and send a compound message</span></span><br><span class="line">      <span class="comment">// 创建一个合并的消息</span></span><br><span class="line">compound := makeCompoundMessage(msgs)</span><br><span class="line">      <span class="comment">// 发送消息</span></span><br><span class="line"><span class="keyword">if</span> err := m.rawSendMsgPacket(node.FullAddress(), &amp;node.Node, compound.Bytes()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">m.logger.Printf(<span class="string">"[ERR] memberlist: Failed to send gossip to %s: %s"</span>, addr, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此将节点的状态分为3种</p><ul><li><p>alive: 用于标识活跃节点</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// aliveNode is invoked by the network layer when we get a message about a</span></span><br><span class="line"><span class="comment">// live node.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Memberlist)</span> <span class="title">aliveNode</span><span class="params">(a *alive, notify <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, bootstrap <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">m.nodeLock.Lock()</span><br><span class="line"><span class="keyword">defer</span> m.nodeLock.Unlock()</span><br><span class="line">state, ok := m.nodeMap[a.Node]</span><br><span class="line"></span><br><span class="line"><span class="comment">// It is possible that during a Leave(), there is already an aliveMsg</span></span><br><span class="line"><span class="comment">// in-queue to be processed but blocked by the locks above. If we let</span></span><br><span class="line"><span class="comment">// that aliveMsg process, it'll cause us to re-join the cluster. This</span></span><br><span class="line"><span class="comment">// ensures that we don't.</span></span><br><span class="line"><span class="keyword">if</span> m.hasLeft() &amp;&amp; a.Node == m.config.Name &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(a.Vsn) &gt;= <span class="number">3</span> &#123;</span><br><span class="line">pMin := a.Vsn[<span class="number">0</span>]</span><br><span class="line">pMax := a.Vsn[<span class="number">1</span>]</span><br><span class="line">pCur := a.Vsn[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">if</span> pMin == <span class="number">0</span> || pMax == <span class="number">0</span> || pMin &gt; pMax &#123;</span><br><span class="line">m.logger.Printf(<span class="string">"[WARN] memberlist: Ignoring an alive message for '%s' (%v:%d) because protocol version(s) are wrong: %d &lt;= %d &lt;= %d should be &gt;0"</span>, a.Node, net.IP(a.Addr), a.Port, pMin, pCur, pMax)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoke the Alive delegate if any. This can be used to filter out</span></span><br><span class="line"><span class="comment">// alive messages based on custom logic. For example, using a cluster name.</span></span><br><span class="line"><span class="comment">// Using a merge delegate is not enough, as it is possible for passive</span></span><br><span class="line"><span class="comment">// cluster merging to still occur.</span></span><br><span class="line"><span class="keyword">if</span> m.config.Alive != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(a.Vsn) &lt; <span class="number">6</span> &#123;</span><br><span class="line">m.logger.Printf(<span class="string">"[WARN] memberlist: ignoring alive message for '%s' (%v:%d) because Vsn is not present"</span>,</span><br><span class="line">a.Node, net.IP(a.Addr), a.Port)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">node := &amp;Node&#123;</span><br><span class="line">Name: a.Node,</span><br><span class="line">Addr: a.Addr,</span><br><span class="line">Port: a.Port,</span><br><span class="line">Meta: a.Meta,</span><br><span class="line">PMin: a.Vsn[<span class="number">0</span>],</span><br><span class="line">PMax: a.Vsn[<span class="number">1</span>],</span><br><span class="line">PCur: a.Vsn[<span class="number">2</span>],</span><br><span class="line">DMin: a.Vsn[<span class="number">3</span>],</span><br><span class="line">DMax: a.Vsn[<span class="number">4</span>],</span><br><span class="line">DCur: a.Vsn[<span class="number">5</span>],</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := m.config.Alive.NotifyAlive(node); err != <span class="literal">nil</span> &#123;</span><br><span class="line">m.logger.Printf(<span class="string">"[WARN] memberlist: ignoring alive message for '%s': %s"</span>,</span><br><span class="line">a.Node, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if we've never seen this node before, and if not, then</span></span><br><span class="line"><span class="comment">// store this node in our node map.</span></span><br><span class="line"><span class="keyword">var</span> updatesNode <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">errCon := m.config.IPAllowed(a.Addr)</span><br><span class="line"><span class="keyword">if</span> errCon != <span class="literal">nil</span> &#123;</span><br><span class="line">m.logger.Printf(<span class="string">"[WARN] memberlist: Rejected node %s (%v): %s"</span>, a.Node, net.IP(a.Addr), errCon)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">state = &amp;nodeState&#123;</span><br><span class="line">Node: Node&#123;</span><br><span class="line">Name: a.Node,</span><br><span class="line">Addr: a.Addr,</span><br><span class="line">Port: a.Port,</span><br><span class="line">Meta: a.Meta,</span><br><span class="line">&#125;,</span><br><span class="line">State: StateDead,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(a.Vsn) &gt; <span class="number">5</span> &#123;</span><br><span class="line">state.PMin = a.Vsn[<span class="number">0</span>]</span><br><span class="line">state.PMax = a.Vsn[<span class="number">1</span>]</span><br><span class="line">state.PCur = a.Vsn[<span class="number">2</span>]</span><br><span class="line">state.DMin = a.Vsn[<span class="number">3</span>]</span><br><span class="line">state.DMax = a.Vsn[<span class="number">4</span>]</span><br><span class="line">state.DCur = a.Vsn[<span class="number">5</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add to map</span></span><br><span class="line">m.nodeMap[a.Node] = state</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get a random offset. This is important to ensure</span></span><br><span class="line"><span class="comment">// the failure detection bound is low on average. If all</span></span><br><span class="line"><span class="comment">// nodes did an append, failure detection bound would be</span></span><br><span class="line"><span class="comment">// very high.</span></span><br><span class="line">n := <span class="built_in">len</span>(m.nodes)</span><br><span class="line">offset := randomOffset(n)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add at the end and swap with the node at the offset</span></span><br><span class="line">m.nodes = <span class="built_in">append</span>(m.nodes, state)</span><br><span class="line">m.nodes[offset], m.nodes[n] = m.nodes[n], m.nodes[offset]</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update numNodes after we've added a new node</span></span><br><span class="line">atomic.AddUint32(&amp;m.numNodes, <span class="number">1</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Check if this address is different than the existing node unless the old node is dead.</span></span><br><span class="line"><span class="keyword">if</span> !bytes.Equal([]<span class="keyword">byte</span>(state.Addr), a.Addr) || state.Port != a.Port &#123;</span><br><span class="line">errCon := m.config.IPAllowed(a.Addr)</span><br><span class="line"><span class="keyword">if</span> errCon != <span class="literal">nil</span> &#123;</span><br><span class="line">m.logger.Printf(<span class="string">"[WARN] memberlist: Rejected IP update from %v to %v for node %s: %s"</span>, a.Node, state.Addr, net.IP(a.Addr), errCon)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// If DeadNodeReclaimTime is configured, check if enough time has elapsed since the node died.</span></span><br><span class="line">canReclaim := (m.config.DeadNodeReclaimTime &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">time.Since(state.StateChange) &gt; m.config.DeadNodeReclaimTime)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow the address to be updated if a dead node is being replaced.</span></span><br><span class="line"><span class="keyword">if</span> state.State == StateLeft || (state.State == StateDead &amp;&amp; canReclaim) &#123;</span><br><span class="line">m.logger.Printf(<span class="string">"[INFO] memberlist: Updating address for left or failed node %s from %v:%d to %v:%d"</span>,</span><br><span class="line">state.Name, state.Addr, state.Port, net.IP(a.Addr), a.Port)</span><br><span class="line">updatesNode = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">m.logger.Printf(<span class="string">"[ERR] memberlist: Conflicting address for %s. Mine: %v:%d Theirs: %v:%d Old state: %v"</span>,</span><br><span class="line">state.Name, state.Addr, state.Port, net.IP(a.Addr), a.Port, state.State)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inform the conflict delegate if provided</span></span><br><span class="line"><span class="keyword">if</span> m.config.Conflict != <span class="literal">nil</span> &#123;</span><br><span class="line">other := Node&#123;</span><br><span class="line">Name: a.Node,</span><br><span class="line">Addr: a.Addr,</span><br><span class="line">Port: a.Port,</span><br><span class="line">Meta: a.Meta,</span><br><span class="line">&#125;</span><br><span class="line">m.config.Conflict.NotifyConflict(&amp;state.Node, &amp;other)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bail if the incarnation number is older, and this is not about us</span></span><br><span class="line">isLocalNode := state.Name == m.config.Name</span><br><span class="line"><span class="keyword">if</span> a.Incarnation &lt;= state.Incarnation &amp;&amp; !isLocalNode &amp;&amp; !updatesNode &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bail if strictly less and this is about us</span></span><br><span class="line"><span class="keyword">if</span> a.Incarnation &lt; state.Incarnation &amp;&amp; isLocalNode &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clear out any suspicion timer that may be in effect.</span></span><br><span class="line"><span class="built_in">delete</span>(m.nodeTimers, a.Node)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Store the old state and meta data</span></span><br><span class="line">oldState := state.State</span><br><span class="line">oldMeta := state.Meta</span><br><span class="line"></span><br><span class="line"><span class="comment">// If this is us we need to refute, otherwise re-broadcast</span></span><br><span class="line"><span class="keyword">if</span> !bootstrap &amp;&amp; isLocalNode &#123;</span><br><span class="line"><span class="comment">// Compute the version vector</span></span><br><span class="line">versions := []<span class="keyword">uint8</span>&#123;</span><br><span class="line">state.PMin, state.PMax, state.PCur,</span><br><span class="line">state.DMin, state.DMax, state.DCur,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If the Incarnation is the same, we need special handling, since it</span></span><br><span class="line"><span class="comment">// possible for the following situation to happen:</span></span><br><span class="line"><span class="comment">// 1) Start with configuration C, join cluster</span></span><br><span class="line"><span class="comment">// 2) Hard fail / Kill / Shutdown</span></span><br><span class="line"><span class="comment">// 3) Restart with configuration C', join cluster</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// In this case, other nodes and the local node see the same incarnation,</span></span><br><span class="line"><span class="comment">// but the values may not be the same. For this reason, we always</span></span><br><span class="line"><span class="comment">// need to do an equality check for this Incarnation. In most cases,</span></span><br><span class="line"><span class="comment">// we just ignore, but we may need to refute.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> a.Incarnation == state.Incarnation &amp;&amp;</span><br><span class="line">bytes.Equal(a.Meta, state.Meta) &amp;&amp;</span><br><span class="line">bytes.Equal(a.Vsn, versions) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">m.refute(state, a.Incarnation)</span><br><span class="line">m.logger.Printf(<span class="string">"[WARN] memberlist: Refuting an alive message for '%s' (%v:%d) meta:(%v VS %v), vsn:(%v VS %v)"</span>, a.Node, net.IP(a.Addr), a.Port, a.Meta, state.Meta, a.Vsn, versions)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">m.encodeBroadcastNotify(a.Node, aliveMsg, a, notify)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update protocol versions if it arrived</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(a.Vsn) &gt; <span class="number">0</span> &#123;</span><br><span class="line">state.PMin = a.Vsn[<span class="number">0</span>]</span><br><span class="line">state.PMax = a.Vsn[<span class="number">1</span>]</span><br><span class="line">state.PCur = a.Vsn[<span class="number">2</span>]</span><br><span class="line">state.DMin = a.Vsn[<span class="number">3</span>]</span><br><span class="line">state.DMax = a.Vsn[<span class="number">4</span>]</span><br><span class="line">state.DCur = a.Vsn[<span class="number">5</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update the state and incarnation number</span></span><br><span class="line">state.Incarnation = a.Incarnation</span><br><span class="line">state.Meta = a.Meta</span><br><span class="line">state.Addr = a.Addr</span><br><span class="line">state.Port = a.Port</span><br><span class="line"><span class="keyword">if</span> state.State != StateAlive &#123;</span><br><span class="line">state.State = StateAlive</span><br><span class="line">state.StateChange = time.Now()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update metrics</span></span><br><span class="line">metrics.IncrCounter([]<span class="keyword">string</span>&#123;<span class="string">"memberlist"</span>, <span class="string">"msg"</span>, <span class="string">"alive"</span>&#125;, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Notify the delegate of any relevant updates</span></span><br><span class="line"><span class="keyword">if</span> m.config.Events != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> oldState == StateDead || oldState == StateLeft &#123;</span><br><span class="line"><span class="comment">// if Dead/Left -&gt; Alive, notify of join</span></span><br><span class="line">m.config.Events.NotifyJoin(&amp;state.Node)</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> !bytes.Equal(oldMeta, state.Meta) &#123;</span><br><span class="line"><span class="comment">// if Meta changed, trigger an update notification</span></span><br><span class="line">m.config.Events.NotifyUpdate(&amp;state.Node)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>suspect: 当探测一些节点失败时，或者suspect某个节点的信息时，会将本地对应的信息标记为suspect，然后启动一个 定时器，并发出一个suspect广播，此期间内如果收到其他节点发来的相同的suspect信息时，将本地suspect的 确认数+1，当定时器超时后，该节点信息仍然不是alive的，且确认数达到要求，会将该节点标记为dead。 当本节点收到别的节点发来的suspect消息时，会发送alive广播，从而清除其他节点上的suspect标记。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// suspectNode is invoked by the network layer when we get a message</span></span><br><span class="line"><span class="comment">// about a suspect node</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Memberlist)</span> <span class="title">suspectNode</span><span class="params">(s *suspect)</span></span> &#123;</span><br><span class="line">m.nodeLock.Lock()</span><br><span class="line"><span class="keyword">defer</span> m.nodeLock.Unlock()</span><br><span class="line">state, ok := m.nodeMap[s.Node]</span><br><span class="line"></span><br><span class="line"><span class="comment">// If we've never heard about this node before, ignore it</span></span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ignore old incarnation numbers</span></span><br><span class="line"><span class="keyword">if</span> s.Incarnation &lt; state.Incarnation &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// See if there's a suspicion timer we can confirm. If the info is new</span></span><br><span class="line"><span class="comment">// to us we will go ahead and re-gossip it. This allows for multiple</span></span><br><span class="line"><span class="comment">// independent confirmations to flow even when a node probes a node</span></span><br><span class="line"><span class="comment">// that's already suspect.</span></span><br><span class="line"><span class="keyword">if</span> timer, ok := m.nodeTimers[s.Node]; ok &#123;</span><br><span class="line"><span class="keyword">if</span> timer.Confirm(s.From) &#123;</span><br><span class="line">m.encodeAndBroadcast(s.Node, suspectMsg, s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ignore non-alive nodes</span></span><br><span class="line"><span class="keyword">if</span> state.State != StateAlive &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If this is us we need to refute, otherwise re-broadcast</span></span><br><span class="line"><span class="keyword">if</span> state.Name == m.config.Name &#123;</span><br><span class="line">m.refute(state, s.Incarnation)</span><br><span class="line">m.logger.Printf(<span class="string">"[WARN] memberlist: Refuting a suspect message (from: %s)"</span>, s.From)</span><br><span class="line"><span class="keyword">return</span> <span class="comment">// Do not mark ourself suspect</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">m.encodeAndBroadcast(s.Node, suspectMsg, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update metrics</span></span><br><span class="line">metrics.IncrCounter([]<span class="keyword">string</span>&#123;<span class="string">"memberlist"</span>, <span class="string">"msg"</span>, <span class="string">"suspect"</span>&#125;, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update the state</span></span><br><span class="line">state.Incarnation = s.Incarnation</span><br><span class="line">state.State = StateSuspect</span><br><span class="line">changeTime := time.Now()</span><br><span class="line">state.StateChange = changeTime</span><br><span class="line"></span><br><span class="line"><span class="comment">// Setup a suspicion timer. Given that we don't have any known phase</span></span><br><span class="line"><span class="comment">// relationship with our peers, we set up k such that we hit the nominal</span></span><br><span class="line"><span class="comment">// timeout two probe intervals short of what we expect given the suspicion</span></span><br><span class="line"><span class="comment">// multiplier.</span></span><br><span class="line">k := m.config.SuspicionMult - <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// If there aren't enough nodes to give the expected confirmations, just</span></span><br><span class="line"><span class="comment">// set k to 0 to say that we don't expect any. Note we subtract 2 from n</span></span><br><span class="line"><span class="comment">// here to take out ourselves and the node being probed.</span></span><br><span class="line">n := m.estNumNodes()</span><br><span class="line"><span class="keyword">if</span> n<span class="number">-2</span> &lt; k &#123;</span><br><span class="line">k = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compute the timeouts based on the size of the cluster.</span></span><br><span class="line">min := suspicionTimeout(m.config.SuspicionMult, n, m.config.ProbeInterval)</span><br><span class="line">max := time.Duration(m.config.SuspicionMaxTimeoutMult) * min</span><br><span class="line">fn := <span class="function"><span class="keyword">func</span><span class="params">(numConfirmations <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">m.nodeLock.Lock()</span><br><span class="line">state, ok := m.nodeMap[s.Node]</span><br><span class="line">timeout := ok &amp;&amp; state.State == StateSuspect &amp;&amp; state.StateChange == changeTime</span><br><span class="line">m.nodeLock.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> timeout &#123;</span><br><span class="line"><span class="keyword">if</span> k &gt; <span class="number">0</span> &amp;&amp; numConfirmations &lt; k &#123;</span><br><span class="line">metrics.IncrCounter([]<span class="keyword">string</span>&#123;<span class="string">"memberlist"</span>, <span class="string">"degraded"</span>, <span class="string">"timeout"</span>&#125;, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m.logger.Printf(<span class="string">"[INFO] memberlist: Marking %s as failed, suspect timeout reached (%d peer confirmations)"</span>,</span><br><span class="line">state.Name, numConfirmations)</span><br><span class="line">d := dead&#123;Incarnation: state.Incarnation, Node: state.Name, From: m.config.Name&#125;</span><br><span class="line">m.deadNode(&amp;d)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">m.nodeTimers[s.Node] = newSuspicion(s.From, k, min, max, fn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>dead: 当本节点离开集群时或者本地探测的其他节点超时被标记死亡，会向集群发送本节点dead广播。收到dead广播 消息的节点会跟本地的记录比较，当本地记录也是dead时会忽略消息，当本地的记录不是dead时，会删除本地 的记录再将dead消息再次广播出去，形成再次传播。 如果从其他节点收到自身的dead广播消息时，说明本节点相对于其他节点网络分区，此时会发起一个alive广播 以修正其他节点上存储的本节点数据。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// deadNode is invoked by the network layer when we get a message</span></span><br><span class="line"><span class="comment">// about a dead node</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Memberlist)</span> <span class="title">deadNode</span><span class="params">(d *dead)</span></span> &#123;</span><br><span class="line">m.nodeLock.Lock()</span><br><span class="line"><span class="keyword">defer</span> m.nodeLock.Unlock()</span><br><span class="line">state, ok := m.nodeMap[d.Node]</span><br><span class="line"></span><br><span class="line"><span class="comment">// If we've never heard about this node before, ignore it</span></span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ignore old incarnation numbers</span></span><br><span class="line"><span class="keyword">if</span> d.Incarnation &lt; state.Incarnation &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clear out any suspicion timer that may be in effect.</span></span><br><span class="line"><span class="built_in">delete</span>(m.nodeTimers, d.Node)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ignore if node is already dead</span></span><br><span class="line"><span class="keyword">if</span> state.DeadOrLeft() &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if this is us</span></span><br><span class="line"><span class="keyword">if</span> state.Name == m.config.Name &#123;</span><br><span class="line"><span class="comment">// If we are not leaving we need to refute</span></span><br><span class="line"><span class="keyword">if</span> !m.hasLeft() &#123;</span><br><span class="line">m.refute(state, d.Incarnation)</span><br><span class="line">m.logger.Printf(<span class="string">"[WARN] memberlist: Refuting a dead message (from: %s)"</span>, d.From)</span><br><span class="line"><span class="keyword">return</span> <span class="comment">// Do not mark ourself dead</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If we are leaving, we broadcast and wait</span></span><br><span class="line">m.encodeBroadcastNotify(d.Node, deadMsg, d, m.leaveBroadcast)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">m.encodeAndBroadcast(d.Node, deadMsg, d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update metrics</span></span><br><span class="line">metrics.IncrCounter([]<span class="keyword">string</span>&#123;<span class="string">"memberlist"</span>, <span class="string">"msg"</span>, <span class="string">"dead"</span>&#125;, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update the state</span></span><br><span class="line">state.Incarnation = d.Incarnation</span><br><span class="line"></span><br><span class="line"><span class="comment">// If the dead message was send by the node itself, mark it is left</span></span><br><span class="line"><span class="comment">// instead of dead.</span></span><br><span class="line"><span class="keyword">if</span> d.Node == d.From &#123;</span><br><span class="line">state.State = StateLeft</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">state.State = StateDead</span><br><span class="line">&#125;</span><br><span class="line">state.StateChange = time.Now()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Notify of death</span></span><br><span class="line"><span class="keyword">if</span> m.config.Events != <span class="literal">nil</span> &#123;</span><br><span class="line">m.config.Events.NotifyLeave(&amp;state.Node)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="broadcast模块"><a href="#broadcast模块" class="headerlink" title="broadcast模块"></a>broadcast模块</h4><p>broadcast模块是广播模块，提供了三个函数，最主要的函数是 getBroadcasts，返回一个广播的最大size，主要是用于填充udp包。很简单代码如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getBroadcasts is used to return a slice of broadcasts to send up to</span></span><br><span class="line"><span class="comment">// a maximum byte size, while imposing a per-broadcast overhead. This is used</span></span><br><span class="line"><span class="comment">// to fill a UDP packet with piggybacked data</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Memberlist)</span> <span class="title">getBroadcasts</span><span class="params">(overhead, limit <span class="keyword">int</span>)</span> [][]<span class="title">byte</span></span> &#123;</span><br><span class="line"><span class="comment">// Get memberlist messages first</span></span><br><span class="line">toSend := m.broadcasts.GetBroadcasts(overhead, limit)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if the user has anything to broadcast</span></span><br><span class="line">d := m.config.Delegate</span><br><span class="line"><span class="keyword">if</span> d != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Determine the bytes used already</span></span><br><span class="line">bytesUsed := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, msg := <span class="keyword">range</span> toSend &#123;</span><br><span class="line">bytesUsed += <span class="built_in">len</span>(msg) + overhead</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check space remaining for user messages</span></span><br><span class="line">avail := limit - bytesUsed</span><br><span class="line"><span class="keyword">if</span> avail &gt; overhead+userMsgOverhead &#123;</span><br><span class="line">userMsgs := d.GetBroadcasts(overhead+userMsgOverhead, avail)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Frame each user message</span></span><br><span class="line"><span class="keyword">for</span> _, msg := <span class="keyword">range</span> userMsgs &#123;</span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1</span>, <span class="built_in">len</span>(msg)+<span class="number">1</span>)</span><br><span class="line">buf[<span class="number">0</span>] = <span class="keyword">byte</span>(userMsg)</span><br><span class="line">buf = <span class="built_in">append</span>(buf, msg...)</span><br><span class="line">toSend = <span class="built_in">append</span>(toSend, buf)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> toSend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>回忆一下总体流程：</p><ul><li><p>项目在memberlist.go 函数Create启动，调用sate.go中函数schedule</p></li><li><p>Schedule函数开启probe协程、pushpull协程、gossip协程</p></li><li><p>probe协程：进行节点状态维护</p></li><li><p>push/pull协程：进行节点状态、用户数据同步</p></li><li><p>gossip协程：进行udp广播发送消息。</p></li></ul><p>memberlist利用点对点随机探测机制实现成员的故障检测，因此将节点的状态分为3种：</p><ul><li>StateAlive：活动节点</li><li>StateSuspect：可疑节点</li><li>StateDead：死亡节点</li></ul><p>probe协程通过点对点随机探测实现成员的故障检测，强化系统的高可用。整体流程如下：</p><ul><li>随机探测：节点启动后，每隔一定时间间隔，会选取一个节点对其发送PING消息。</li><li>重试与间隔探测请求：PING消息失败后，会随机选取N（由config中IndirectChecks设置）个节点发起间接PING请求和再发起一个TCP PING消息。</li><li>间隔探测：收到间接PING请求的节点会根据请求中的地址发起一个PING消息，将PING的结果返回给间接请求的源节点。</li><li>探测超时标识可疑：如果探测超时之间内，本节点没有收到任何一个要探测节点的ACK消息，则标记要探测的节点状态为suspect。</li><li>可疑节点广播：启动一个定时器用于发出一个suspect广播，此期间内如果收到其他节点发来的相同的suspect信息时，将本地suspect的 确认数+1，当定时器超时后，该节点信息仍然不是alive的，且确认数达到要求，会将该节点标记为dead。</li><li>可疑消除：当本节点收到别的节点发来的suspect消息时，会发送alive广播，从而清除其他节点上的suspect标记。。</li><li>死亡通知:当本节点离开集群时或者本地探测的其他节点超时被标记死亡，会向集群发送本节点dead广播</li><li>死亡消除:如果从其他节点收到自身的dead广播消息时，说明本节点相对于其他节点网络分区，此时会发起一个alive广播以修正其他节点上存储的本节点数据。</li></ul><p>Memberlist在整个生命周期内，总的有两种类型的消息：</p><ul><li><strong>udp**</strong>协议消息：**传输PING消息、间接PING消息、ACK消息、NACK消息、Suspect消息、 Alive消息、Dead消息、消息广播；</li><li><strong>tcp协议消息：</strong>用户数据同步、节点状态同步、PUSH-PULL消息。</li></ul><p>push/pull协程周期性的从已知的alive的集群节点中选1个节点进行push/pull交换信息。交换的信息包含2种：</p><ul><li>集群信息：节点数据</li><li>用户自定义的信息：实现Delegate接口的struct。</li></ul><p>push/pull协程可以加速集群内信息的收敛速度，整体流程为：</p><ul><li>建立TCP链接：每隔一个时间间隔，随机选取一个节点，跟它建立tcp连接，</li><li>将本地的全部节点 状态、用户数据发送过去，</li><li>对端将其掌握的全部节点状态、用户数据发送回来，然后完成2份数据的合并。</li></ul><p>Gossip协程通过udp协议向K个节点发送消息，节点从广播队列里面获取消息，广播队列里的消息发送失败超过一定次数后，消息就会被丢弃。</p><p>参考：</p><p><a href="https://yunlzheng.gitbook.io/prometheus-book/part-ii-prometheus-jin-jie/readmd/alertmanager-high-availability" target="_blank" rel="external">Alertmanager高可用</a></p><p><a href="https://blog.csdn.net/jianxian89/article/details/107482423" target="_blank" rel="external">一致性算法-Gossip协议实践(Memberlist)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p id=&quot;div-border-top-green&quot;&gt;人生不过如此，且行且珍惜，每一次的失败，都是成功的伏笔；每一次的考验，都有一份收获；每一次的泪水，都有一次醒悟；每一次的磨难，都有生命的财富。&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&quot;高可用简介&quot;&gt;&lt;a href=&quot;#高可用简介&quot; class=&quot;headerlink&quot; title=&quot;高可用简介&quot;&gt;&lt;/a&gt;高可用简介&lt;/h2&gt;&lt;p&gt;之前我们主要讨论了Prometheus Server自身的高可用问题。而接下来，重点将放在告警处理也就是Alertmanager部分。如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/prometheus-alertmanager-0.png&quot; alt=&quot;image-20210906110008076&quot;&gt;&lt;/p&gt;
&lt;p&gt;为了提升Promthues的服务可用性，通常用户会部署两个或者两个以上的Promthus Server，它们具有完全相同的配置包括Job配置，以及告警配置等。当某一个Prometheus Server发生故障后可以确保Promthues持续可用。&lt;/p&gt;
    
    </summary>
    
      <category term="Prometheus" scheme="https://magiceses.github.io/categories/Prometheus/"/>
    
    
      <category term="Prometheus" scheme="https://magiceses.github.io/tags/Prometheus/"/>
    
      <category term="Alertmanager" scheme="https://magiceses.github.io/tags/Alertmanager/"/>
    
  </entry>
  
  <entry>
    <title>Alertmanager 高可用总结-下</title>
    <link href="https://magiceses.github.io/2020/12/14/prometheus-alertmanager-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%BB%E7%BB%93-%E4%B8%8B/"/>
    <id>https://magiceses.github.io/2020/12/14/prometheus-alertmanager-高可用总结-下/</id>
    <published>2020-12-13T17:25:24.000Z</published>
    <updated>2021-10-02T07:58:41.106Z</updated>
    
    <content type="html"><![CDATA[<p id="div-border-top-green">我们每个人都不能抱怨自己的出身，没有好的家世，那就去创造好的家世。要知道，那些在雨里奔跑的，从来都是没有伞的孩子。<br></p><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><h3 id="gossip"><a href="#gossip" class="headerlink" title="gossip"></a>gossip</h3><p>先理解一下gossip协议：在一个有界网络中，每个节点都随机地与其他节点通信，经过一番杂乱无章的通信，最终所有节点的状态都会达成一致。每个节点可能知道所有其他节点，也可能仅知道几个邻居节点，只要这些节可以通过网络连通，最终他们的状态都是一致的，当然这也是疫情传播的特点。</p><p>简单的描述下这个协议，首先要传播谣言就要有种子节点。种子节点每秒都会随机向其他节点发送自己所拥有的节点列表，以及需要传播的消息。任何新加入的节点，就在这种传播方式下很快地被全网所知道。这个协议的神奇就在于它从设计开始就没想到信息一定要传递给所有的节点，但是随着时间的增长，在最终的某一时刻，全网会得到相同的信息。当然这个时刻可能仅仅存在于理论，永远不可达。</p><h3 id="memberlist"><a href="#memberlist" class="headerlink" title="memberlist"></a>memberlist</h3><p>回忆一下memberlist的总体流程：</p><a id="more"></a><ul><li><p>项目在memberlist.go 函数Create启动，调用sate.go中函数schedule</p></li><li><p>Schedule函数开启probe协程、pushpull协程、gossip协程</p></li><li><p>probe协程：进行节点状态维护</p></li><li><p>push/pull协程：进行节点状态、用户数据同步</p></li><li><p>gossip协程：进行udp广播发送消息。</p></li></ul><p>memberlist利用点对点随机探测机制实现成员的故障检测，因此将节点的状态分为3种：</p><ul><li>StateAlive：活动节点</li><li>StateSuspect：可疑节点</li><li>StateDead：死亡节点</li></ul><p>probe协程通过点对点随机探测实现成员的故障检测，强化系统的高可用。整体流程如下：</p><ul><li>随机探测：节点启动后，每隔一定时间间隔，会选取一个节点对其发送PING消息。</li><li>重试与间隔探测请求：PING消息失败后，会随机选取N（由config中IndirectChecks设置）个节点发起间接PING请求和再发起一个TCP PING消息。</li><li>间隔探测：收到间接PING请求的节点会根据请求中的地址发起一个PING消息，将PING的结果返回给间接请求的源节点。</li><li>探测超时标识可疑：如果探测超时之间内，本节点没有收到任何一个要探测节点的ACK消息，则标记要探测的节点状态为suspect。</li><li>可疑节点广播：启动一个定时器用于发出一个suspect广播，此期间内如果收到其他节点发来的相同的suspect信息时，将本地suspect的 确认数+1，当定时器超时后，该节点信息仍然不是alive的，且确认数达到要求，会将该节点标记为dead。</li><li>可疑消除：当本节点收到别的节点发来的suspect消息时，会发送alive广播，从而清除其他节点上的suspect标记。。</li><li>死亡通知:当本节点离开集群时或者本地探测的其他节点超时被标记死亡，会向集群发送本节点dead广播</li><li>死亡消除:如果从其他节点收到自身的dead广播消息时，说明本节点相对于其他节点网络分区，此时会发起一个alive广播以修正其他节点上存储的本节点数据。</li></ul><p>Memberlist在整个生命周期内，总的有两种类型的消息：</p><ul><li><strong>udp**</strong>协议消息：**传输PING消息、间接PING消息、ACK消息、NACK消息、Suspect消息、 Alive消息、Dead消息、消息广播；</li><li><strong>tcp协议消息：</strong>用户数据同步、节点状态同步、PUSH-PULL消息。</li></ul><p>push/pull协程周期性的从已知的alive的集群节点中选1个节点进行push/pull交换信息。交换的信息包含2种：</p><ul><li>集群信息：节点数据</li><li>用户自定义的信息：实现Delegate接口的struct。</li></ul><p>push/pull协程可以加速集群内信息的收敛速度，整体流程为：</p><ul><li>建立TCP链接：每隔一个时间间隔，随机选取一个节点，跟它建立tcp连接，</li><li>将本地的全部节点 状态、用户数据发送过去，</li><li>对端将其掌握的全部节点状态、用户数据发送回来，然后完成2份数据的合并。</li></ul><p>Gossip协程通过udp协议向K个节点发送消息，节点从广播队列里面获取消息，广播队列里的消息发送失败超过一定次数后，消息就会被丢弃。</p><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"encoding/json"</span></span><br><span class="line">    <span class="string">"flag"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/hashicorp/memberlist"</span></span><br><span class="line">    <span class="string">"github.com/pborman/uuid"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    mtx        sync.RWMutex</span><br><span class="line">    members    = flag.String(<span class="string">"members"</span>, <span class="string">""</span>, <span class="string">"comma seperated list of members"</span>)</span><br><span class="line">    port       = flag.Int(<span class="string">"port"</span>, <span class="number">4001</span>, <span class="string">"http port"</span>)</span><br><span class="line">    items      = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">    broadcasts *memberlist.TransmitLimitedQueue</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> broadcast <span class="keyword">struct</span> &#123;</span><br><span class="line">    msg    []<span class="keyword">byte</span></span><br><span class="line">    notify <span class="keyword">chan</span>&lt;- <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> delegate <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> update <span class="keyword">struct</span> &#123;</span><br><span class="line">    Action <span class="keyword">string</span> <span class="comment">// add, del</span></span><br><span class="line">    Data   <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    flag.Parse()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *broadcast)</span> <span class="title">Invalidates</span><span class="params">(other memberlist.Broadcast)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *broadcast)</span> <span class="title">Message</span><span class="params">()</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b.msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *broadcast)</span> <span class="title">Finished</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> b.notify != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">close</span>(b.notify)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *delegate)</span> <span class="title">NodeMeta</span><span class="params">(limit <span class="keyword">int</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *delegate)</span> <span class="title">NotifyMsg</span><span class="params">(b []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(b) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> b[<span class="number">0</span>] &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'d'</span>: <span class="comment">// data</span></span><br><span class="line">        <span class="keyword">var</span> updates []*update</span><br><span class="line">        <span class="keyword">if</span> err := json.Unmarshal(b[<span class="number">1</span>:], &amp;updates); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        mtx.Lock()</span><br><span class="line">        <span class="keyword">for</span> _, u := <span class="keyword">range</span> updates &#123;</span><br><span class="line">            <span class="keyword">for</span> k, v := <span class="keyword">range</span> u.Data &#123;</span><br><span class="line">                <span class="keyword">switch</span> u.Action &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"add"</span>:</span><br><span class="line">                    items[k] = v</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"del"</span>:</span><br><span class="line">                    <span class="built_in">delete</span>(items, k)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mtx.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *delegate)</span> <span class="title">GetBroadcasts</span><span class="params">(overhead, limit <span class="keyword">int</span>)</span> [][]<span class="title">byte</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> broadcasts.GetBroadcasts(overhead, limit)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *delegate)</span> <span class="title">LocalState</span><span class="params">(join <span class="keyword">bool</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">    mtx.RLock()</span><br><span class="line">    m := items</span><br><span class="line">    mtx.RUnlock()</span><br><span class="line">    b, _ := json.Marshal(m)</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *delegate)</span> <span class="title">MergeRemoteState</span><span class="params">(buf []<span class="keyword">byte</span>, join <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(buf) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !join &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">    <span class="keyword">if</span> err := json.Unmarshal(buf, &amp;m); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    mtx.Lock()</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        items[k] = v</span><br><span class="line">    &#125;</span><br><span class="line">    mtx.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    r.ParseForm()</span><br><span class="line">    key := r.Form.Get(<span class="string">"key"</span>)</span><br><span class="line">    val := r.Form.Get(<span class="string">"val"</span>)</span><br><span class="line">    mtx.Lock()</span><br><span class="line">    items[key] = val</span><br><span class="line">    mtx.Unlock()</span><br><span class="line"></span><br><span class="line">    b, err := json.Marshal([]*update&#123;</span><br><span class="line">        &amp;update&#123;</span><br><span class="line">            Action: <span class="string">"add"</span>,</span><br><span class="line">            Data: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">                key: val,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        http.Error(w, err.Error(), <span class="number">500</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//广播数据</span></span><br><span class="line">    broadcasts.QueueBroadcast(&amp;broadcast&#123;</span><br><span class="line">        msg:    <span class="built_in">append</span>([]<span class="keyword">byte</span>(<span class="string">"d"</span>), b...),</span><br><span class="line">        notify: <span class="literal">nil</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">delHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    r.ParseForm()</span><br><span class="line">    key := r.Form.Get(<span class="string">"key"</span>)</span><br><span class="line">    mtx.Lock()</span><br><span class="line">    <span class="built_in">delete</span>(items, key)</span><br><span class="line">    mtx.Unlock()</span><br><span class="line"></span><br><span class="line">    b, err := json.Marshal([]*update&#123;</span><br><span class="line">        &amp;update&#123;</span><br><span class="line">            Action: <span class="string">"del"</span>,</span><br><span class="line">            Data: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">                key: <span class="string">""</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        http.Error(w, err.Error(), <span class="number">500</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    broadcasts.QueueBroadcast(&amp;broadcast&#123;</span><br><span class="line">        msg:    <span class="built_in">append</span>([]<span class="keyword">byte</span>(<span class="string">"d"</span>), b...),</span><br><span class="line">        notify: <span class="literal">nil</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    r.ParseForm()</span><br><span class="line">    key := r.Form.Get(<span class="string">"key"</span>)</span><br><span class="line">    mtx.RLock()</span><br><span class="line">    val := items[key]</span><br><span class="line">    mtx.RUnlock()</span><br><span class="line">    w.Write([]<span class="keyword">byte</span>(val))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">start</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    hostname, _ := os.Hostname()</span><br><span class="line">    c := memberlist.DefaultLocalConfig()</span><br><span class="line">    c.Delegate = &amp;delegate&#123;&#125;</span><br><span class="line">    c.BindPort = <span class="number">0</span></span><br><span class="line">    c.Name = hostname + <span class="string">"-"</span> + uuid.NewUUID().String()</span><br><span class="line">    <span class="comment">//创建gossip网络</span></span><br><span class="line">    m, err := memberlist.Create(c)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第一个节点没有member，但从第二个开始就有member了</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(*members) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        parts := strings.Split(*members, <span class="string">","</span>)</span><br><span class="line">        _, err := m.Join(parts)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    broadcasts = &amp;memberlist.TransmitLimitedQueue&#123;</span><br><span class="line">        NumNodes: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m.NumMembers()</span><br><span class="line">        &#125;,</span><br><span class="line">        RetransmitMult: <span class="number">3</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    node := m.LocalNode()</span><br><span class="line">    fmt.Printf(<span class="string">"Local member %s:%d\n"</span>, node.Addr, node.Port)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    http.HandleFunc(<span class="string">"/add"</span>, addHandler)</span><br><span class="line">    http.HandleFunc(<span class="string">"/del"</span>, delHandler)</span><br><span class="line">    http.HandleFunc(<span class="string">"/get"</span>, getHandler)</span><br><span class="line">    fmt.Printf(<span class="string">"Listening on :%d\n"</span>, *port)</span><br><span class="line">    <span class="keyword">if</span> err := http.ListenAndServe(fmt.Sprintf(<span class="string">":%d"</span>, *port), <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过一个简单的http服务查询和插入数据，找两台机器，第一台执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memberlist</span><br></pre></td></tr></table></figure><p>会生成gossip监听的服务ip和端口<br>使用上面的ip和端口在第二台执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memberlist --members=xxx.xxx.xxx.xxx:xxxx</span><br></pre></td></tr></table></figure><p>那么一个gossip的网络就搭建完成了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># add</span><br><span class="line">curl &quot;http://localhost:4001/add?key=foo&amp;val=bar&quot;</span><br><span class="line"></span><br><span class="line"># get</span><br><span class="line">curl &quot;http://另一台机器:4001/get?key=foo&quot;</span><br><span class="line"></span><br><span class="line"># delete</span><br><span class="line">curl &quot;http://localhost:4001/del?key=foo&quot;</span><br></pre></td></tr></table></figure><h2 id="alertmanager-高可用实现"><a href="#alertmanager-高可用实现" class="headerlink" title="alertmanager 高可用实现"></a>alertmanager 高可用实现</h2><p>上文我们说到，alertmanager在初始化时调用了memberlist的create方法，返回了Peer结构体：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Peer is a single peer in a gossip cluster.</span></span><br><span class="line"><span class="keyword">type</span> Peer <span class="keyword">struct</span> &#123;</span><br><span class="line">mlist    *memberlist.Memberlist</span><br><span class="line">delegate *delegate</span><br><span class="line"></span><br><span class="line">resolvedPeers []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">mtx    sync.RWMutex</span><br><span class="line">states <span class="keyword">map</span>[<span class="keyword">string</span>]State</span><br><span class="line">stopc  <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">readyc <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">peerLock    sync.RWMutex</span><br><span class="line">peers       <span class="keyword">map</span>[<span class="keyword">string</span>]peer</span><br><span class="line">failedPeers []peer</span><br><span class="line"></span><br><span class="line">knownPeers    []<span class="keyword">string</span></span><br><span class="line">advertiseAddr <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">failedReconnectionsCounter prometheus.Counter</span><br><span class="line">reconnectionsCounter       prometheus.Counter</span><br><span class="line">failedRefreshCounter       prometheus.Counter</span><br><span class="line">refreshCounter             prometheus.Counter</span><br><span class="line">peerLeaveCounter           prometheus.Counter</span><br><span class="line">peerUpdateCounter          prometheus.Counter</span><br><span class="line">peerJoinCounter            prometheus.Counter</span><br><span class="line"></span><br><span class="line">logger log.Logger</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后加入集群和初始化状态</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 集群peer的状态监听器已经进行注册成功，现在可以进行加入集群和初始化状态。</span></span><br><span class="line"><span class="comment">// Peer state listeners have been registered, now we can join and get the initial state.</span></span><br><span class="line"><span class="keyword">if</span> peer != <span class="literal">nil</span> &#123;</span><br><span class="line">err = peer.Join(</span><br><span class="line">*reconnectInterval,</span><br><span class="line">*peerReconnectTimeout,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">level.Warn(logger).Log(<span class="string">"msg"</span>, <span class="string">"unable to join gossip mesh"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), *settleTimeout)</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">cancel()</span><br><span class="line"><span class="keyword">if</span> err := peer.Leave(<span class="number">10</span> * time.Second); err != <span class="literal">nil</span> &#123;</span><br><span class="line">level.Warn(logger).Log(<span class="string">"msg"</span>, <span class="string">"unable to leave gossip mesh"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">go</span> peer.Settle(ctx, *gossipInterval*<span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Join is used to take an existing Memberlist and attempt to join a cluster</span></span><br><span class="line"><span class="comment">// by contacting all the given hosts and performing a state sync. Initially,</span></span><br><span class="line"><span class="comment">// the Memberlist only contains our own state, so doing this will cause</span></span><br><span class="line"><span class="comment">// remote nodes to become aware of the existence of this node, effectively</span></span><br><span class="line"><span class="comment">// joining the cluster.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This returns the number of hosts successfully contacted and an error if</span></span><br><span class="line"><span class="comment">// none could be reached. If an error is returned, the node did not successfully</span></span><br><span class="line"><span class="comment">// join the cluster.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Memberlist)</span> <span class="title">Join</span><span class="params">(existing []<span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">numSuccess := <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> errs error</span><br><span class="line"><span class="keyword">for</span> _, exist := <span class="keyword">range</span> existing &#123;</span><br><span class="line">addrs, err := m.resolveAddr(exist)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">err = fmt.Errorf(<span class="string">"Failed to resolve %s: %v"</span>, exist, err)</span><br><span class="line">errs = multierror.Append(errs, err)</span><br><span class="line">m.logger.Printf(<span class="string">"[WARN] memberlist: %v"</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, addr := <span class="keyword">range</span> addrs &#123;</span><br><span class="line">hp := joinHostPort(addr.ip.String(), addr.port)</span><br><span class="line">a := Address&#123;Addr: hp, Name: addr.nodeName&#125;</span><br><span class="line"><span class="keyword">if</span> err := m.pushPullNode(a, <span class="literal">true</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">err = fmt.Errorf(<span class="string">"Failed to join %s: %v"</span>, addr.ip, err)</span><br><span class="line">errs = multierror.Append(errs, err)</span><br><span class="line">m.logger.Printf(<span class="string">"[DEBUG] memberlist: %v"</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">numSuccess++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> numSuccess &gt; <span class="number">0</span> &#123;</span><br><span class="line">errs = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> numSuccess, errs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>join的注释很详细了，最后起了一个协程 <code>go peer.Settle(ctx, *gossipInterval*10)</code>，用于同步集群状态，如果同步完成就关闭 <code>channel p.readyc</code>，后面判断集群状态是否OK，都是根据该 <code>channel</code> 判断的。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Settle waits until the mesh is ready (and sets the appropriate internal state when it is).</span></span><br><span class="line"><span class="comment">// The idea is that we don't want to start "working" before we get a chance to know most of the alerts and/or silences.</span></span><br><span class="line"><span class="comment">// Inspired from https://github.com/apache/cassandra/blob/7a40abb6a5108688fb1b10c375bb751cbb782ea4/src/java/org/apache/cassandra/gms/Gossiper.java</span></span><br><span class="line"><span class="comment">// This is clearly not perfect or strictly correct but should prevent the alertmanager to send notification before it is obviously not ready.</span></span><br><span class="line"><span class="comment">// This is especially important for those that do not have persistent storage.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Peer)</span> <span class="title">Settle</span><span class="params">(ctx context.Context, interval time.Duration)</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> NumOkayRequired = <span class="number">3</span></span><br><span class="line">level.Info(p.logger).Log(<span class="string">"msg"</span>, <span class="string">"Waiting for gossip to settle..."</span>, <span class="string">"interval"</span>, interval)</span><br><span class="line">start := time.Now()</span><br><span class="line">nPeers := <span class="number">0</span></span><br><span class="line">nOkay := <span class="number">0</span></span><br><span class="line">totalPolls := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">elapsed := time.Since(start)</span><br><span class="line">level.Info(p.logger).Log(<span class="string">"msg"</span>, <span class="string">"gossip not settled but continuing anyway"</span>, <span class="string">"polls"</span>, totalPolls, <span class="string">"elapsed"</span>, elapsed)</span><br><span class="line"><span class="built_in">close</span>(p.readyc)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(interval):</span><br><span class="line">&#125;</span><br><span class="line">elapsed := time.Since(start)</span><br><span class="line">n := <span class="built_in">len</span>(p.Peers())</span><br><span class="line"><span class="keyword">if</span> nOkay &gt;= NumOkayRequired &#123;</span><br><span class="line">level.Info(p.logger).Log(<span class="string">"msg"</span>, <span class="string">"gossip settled; proceeding"</span>, <span class="string">"elapsed"</span>, elapsed)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> n == nPeers &#123;</span><br><span class="line">nOkay++</span><br><span class="line">level.Debug(p.logger).Log(<span class="string">"msg"</span>, <span class="string">"gossip looks settled"</span>, <span class="string">"elapsed"</span>, elapsed)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">nOkay = <span class="number">0</span></span><br><span class="line">level.Info(p.logger).Log(<span class="string">"msg"</span>, <span class="string">"gossip not settled"</span>, <span class="string">"polls"</span>, totalPolls, <span class="string">"before"</span>, nPeers, <span class="string">"now"</span>, n, <span class="string">"elapsed"</span>, elapsed)</span><br><span class="line">&#125;</span><br><span class="line">nPeers = n</span><br><span class="line">totalPolls++</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(p.readyc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到上面这里是个死循环，实现了一个类似心跳机制，定时检测集群是否已经同步完成，接着往下看</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">waitFunc := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line"><span class="keyword">if</span> peer != <span class="literal">nil</span> &#123;</span><br><span class="line">waitFunc = clusterWait(peer, *peerTimeout)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// clusterWait returns a function that inspects the current peer state and returns</span></span><br><span class="line"><span class="comment">// a duration of one base timeout for each peer with a higher ID than ourselves.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">clusterWait</span><span class="params">(p *cluster.Peer, timeout time.Duration)</span> <span class="title">func</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> time.Duration(p.Position()) * timeout</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">pipeline := pipelineBuilder.New(</span><br><span class="line">receivers,</span><br><span class="line">waitFunc,</span><br><span class="line">inhibitor,</span><br><span class="line">silencer,</span><br><span class="line">notificationLog,</span><br><span class="line">peer,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// New returns a map of receivers to Stages.</span></span><br><span class="line"><span class="comment">// --------------------------------------------------------</span></span><br><span class="line"><span class="comment">// New 返回一个接收人map运行的Stages，每个接收人，都会经历固定的Gossip，</span></span><br><span class="line"><span class="comment">// 抑制和静默阶段。然后根据receiver的不同，创建各自的分组阶段。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pb *PipelineBuilder)</span> <span class="title">New</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">receivers <span class="keyword">map</span>[<span class="keyword">string</span>][]Integration,</span></span></span><br><span class="line"><span class="function"><span class="params">wait <span class="keyword">func</span>()</span> <span class="title">time</span>.<span class="title">Duration</span>,</span></span><br><span class="line"><span class="function"><span class="title">inhibitor</span> *<span class="title">inhibit</span>.<span class="title">Inhibitor</span>,</span></span><br><span class="line"><span class="function"><span class="title">silencer</span> *<span class="title">silence</span>.<span class="title">Silencer</span>,</span></span><br><span class="line"><span class="function"><span class="title">notificationLog</span> <span class="title">NotificationLog</span>,</span></span><br><span class="line"><span class="function"><span class="title">peer</span> *<span class="title">cluster</span>.<span class="title">Peer</span>,</span></span><br><span class="line"><span class="function">) <span class="title">RoutingStage</span></span> &#123;</span><br><span class="line">rs := <span class="built_in">make</span>(RoutingStage, <span class="built_in">len</span>(receivers))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建gossip协议检查就绪阶段，和抑制和静默的静音阶段。</span></span><br><span class="line">ms := NewGossipSettleStage(peer)</span><br><span class="line">is := NewMuteStage(inhibitor)</span><br><span class="line">ss := NewMuteStage(silencer)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据接收人创建，分组等待，去重，重试，通知阶段。</span></span><br><span class="line"><span class="comment">// 这里每个接收人都有一个独立的接收人阶段，并且</span></span><br><span class="line"><span class="comment">// 它们公用gossip就绪和静音阶段。</span></span><br><span class="line"><span class="keyword">for</span> name := <span class="keyword">range</span> receivers &#123;</span><br><span class="line"><span class="comment">// 为每一个接收方式的所有接收人创建扇出的阶段</span></span><br><span class="line">st := createReceiverStage(name, receivers[name], wait, notificationLog, pb.metrics)</span><br><span class="line">rs[name] = MultiStage&#123;ms, is, ss, st&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> rs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里很重要，在pipeline中创建gossip协议检查就绪阶段，<code>ms := NewGossipSettleStage(peer)</code>，和其他一些需要处理message的阶段</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewGossipSettleStage returns a new GossipSettleStage.</span></span><br><span class="line"><span class="comment">// ------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// NewGossipSettleStage 返回一个gossip检查就绪阶段，正如我们所知集群内的节点，</span></span><br><span class="line"><span class="comment">// 通过gossip协议进行通讯。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGossipSettleStage</span><span class="params">(p *cluster.Peer)</span> *<span class="title">GossipSettleStage</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;GossipSettleStage&#123;peer: p&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GossipSettleStage waits until the Gossip has settled to forward alerts.</span></span><br><span class="line"><span class="comment">// ------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// GossipSettleStage 此阶段，一直等待gossip协议准备就绪状态，等待其他的节点就绪。</span></span><br><span class="line"><span class="keyword">type</span> GossipSettleStage <span class="keyword">struct</span> &#123;</span><br><span class="line">peer *cluster.Peer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这个就绪阶段是干嘛的呢？往下看</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> disp.Run()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run starts dispatching alerts incoming via the updates channel.</span></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 运行调度器，初始化分组列表map和普罗米修斯分组计数指标。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dispatcher)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 初始化结束通道</span></span><br><span class="line">d.done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">d.mtx.Lock()</span><br><span class="line">d.aggrGroups = <span class="keyword">map</span>[*Route]<span class="keyword">map</span>[model.Fingerprint]*aggrGroup&#123;&#125;</span><br><span class="line">d.metrics.aggrGroups.Set(<span class="number">0</span>)</span><br><span class="line">d.ctx, d.cancel = context.WithCancel(context.Background())</span><br><span class="line">d.mtx.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行调度器子运行函数</span></span><br><span class="line">d.run(d.alerts.Subscribe())</span><br><span class="line"><span class="built_in">close</span>(d.done)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下这个方法 <code>d.run(d.alerts.Subscribe())</code>，其中 <code>d.alerts.Subscribe()</code> 返回一个告警遍历器接口。遍历器会返回还没有解决和还没有被成功通知出来的告警。遍历器所返回的告警，并不能保证是按照时间顺序来进行排序的。</p><p>看下 <code>run</code> 中的 <code>d.processAlert(alert, r)</code></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dispatcher)</span> <span class="title">processAlert</span><span class="params">(alert *types.Alert, route *Route)</span></span> &#123;</span><br><span class="line"><span class="comment">// 根据分组路由的信息，获得此分组下的匹配中的labels。</span></span><br><span class="line"><span class="comment">// 并根据所得labels得到唯一id(指纹 finger print)。</span></span><br><span class="line">groupLabels := getGroupLabels(alert, route)</span><br><span class="line">fp := groupLabels.Fingerprint()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加锁进行hashmap操作</span></span><br><span class="line">d.mtx.Lock()</span><br><span class="line"><span class="keyword">defer</span> d.mtx.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过分组路由获得分组map，如果分组列表hashmap不存在这个分组，</span></span><br><span class="line"><span class="comment">// 则进行创建。分组map里面key为分组finger print，value为具</span></span><br><span class="line"><span class="comment">// 体唯一标识的分组。</span></span><br><span class="line">group, ok := d.aggrGroups[route]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">group = <span class="keyword">map</span>[model.Fingerprint]*aggrGroup&#123;&#125;</span><br><span class="line">d.aggrGroups[route] = group</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If the group does not exist, create it.</span></span><br><span class="line"><span class="comment">// ----------------------------------------------------</span></span><br><span class="line"><span class="comment">// 假如当前告警的group labels的指纹在这个告警分组map里找不到，</span></span><br><span class="line"><span class="comment">// 则进行分组的创建。</span></span><br><span class="line">ag, ok := group[fp]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">ag = newAggrGroup(d.ctx, groupLabels, route, d.timeout, d.logger)</span><br><span class="line">group[fp] = ag</span><br><span class="line"><span class="comment">// 普罗米修斯的分组数量指标进行加一</span></span><br><span class="line">d.metrics.aggrGroups.Inc()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启新的协成，运行此告警指纹的分组</span></span><br><span class="line"><span class="keyword">go</span> ag.run(<span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, alerts ...*types.Alert)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">// 根据当前context的状态，来进行告警的处理。</span></span><br><span class="line">_, _, err := d.stage.Exec(ctx, d.logger, alerts...)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">lvl := level.Error(d.logger)</span><br><span class="line"><span class="keyword">if</span> ctx.Err() == context.Canceled &#123;</span><br><span class="line"><span class="comment">// It is expected for the context to be canceled on</span></span><br><span class="line"><span class="comment">// configuration reload or shutdown. In this case, the</span></span><br><span class="line"><span class="comment">// message should only be logged at the debug level.</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------</span></span><br><span class="line"><span class="comment">// 假如错误是因为reload或者关闭而导致的，那样日志等级为debug</span></span><br><span class="line">lvl = level.Debug(d.logger)</span><br><span class="line">&#125;</span><br><span class="line">lvl.Log(<span class="string">"msg"</span>, <span class="string">"Notify for alerts failed"</span>, <span class="string">"num_alerts"</span>, <span class="built_in">len</span>(alerts), <span class="string">"err"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err == <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入alert到这个唯一标识的分组里。</span></span><br><span class="line">ag.insert(alert)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要看下这个方法 <code>_, _, err := d.stage.Exec(ctx, d.logger, alerts...)</code></p><blockquote><p>Exec 循环执行 MultiStage 里面的每一个阶段。MultiStage 主要使用两个场景。<br>场景一： RoutingStage 的map[receiver name] MultiStage。<br>       里面有集群Gossip阶段，静默Mute阶段，抑制Mute阶段，Receiver阶段。<br>场景二： FanoutStage 的切片，里面每个元素是一个 MultiStage。<br>       里面有分组等待阶段，去重阶段，重试阶段，设置通知阶段。</p></blockquote><p>也就是说每次有新告警过来的时候都会经历同步集群状态的阶段，保证当前集群状态是OK的。</p><p>同时当有多个prometheus往alertmanager发送消息的时候，可能发生告警重复的情况，在alertmanager中有个去重阶段(DedupStage)是处理这样的情况：</p><p>DedupStage用于管理告警的去重，传递的参数中包含了一个NotificationLog,用来保存告警的发送记录。当有多个机器组成集群的时候，NotificationLog会通过协议去进行通信，传递彼此的记录信息，加入集群中的A如果发送了告警，该记录会传递给B机器，并进行merge操作，这样B机器在发送告警的时候如果查询已经发送，则不再进行告警发送。关于NotificationLog的实现nflog可以查看nflog/nflog.go文件。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DedupStage filters alerts.</span></span><br><span class="line"><span class="comment">// Filtering happens based on a notification log.</span></span><br><span class="line"><span class="keyword">type</span> DedupStage <span class="keyword">struct</span> &#123;</span><br><span class="line">    nflog NotificationLog</span><br><span class="line">    recv  *nflogpb.Receiver</span><br><span class="line">    conf  notifierConfig</span><br><span class="line"></span><br><span class="line">    now  <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Time</span></span></span><br><span class="line"><span class="function">    <span class="title">hash</span> <span class="title">func</span><span class="params">(*types.Alert)</span> <span class="title">uint64</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>具体的处理逻辑如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *DedupStage)</span> <span class="title">Exec</span><span class="params">(ctx context.Context, l log.Logger, alerts ...*types.Alert)</span> <span class="params">(context.Context, []*types.Alert, error)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    entries, err := n.nflog.Query(nflog.QGroupKey(gkey), nflog.QReceiver(n.recv))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err != nflog.ErrNotFound &#123;</span><br><span class="line">        <span class="keyword">return</span> ctx, <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> entry *nflogpb.Entry</span><br><span class="line">    <span class="keyword">switch</span> <span class="built_in">len</span>(entries) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        entry = entries[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> ctx, <span class="literal">nil</span>, fmt.Errorf(<span class="string">"unexpected entry result size %d"</span>, <span class="built_in">len</span>(entries))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n.needsUpdate(entry, firingSet, resolvedSet, repeatInterval) &#123;</span><br><span class="line">        <span class="keyword">return</span> ctx, alerts, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> ctx, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的nflog.Query将根据接收和group key进行查询，一旦查找到，则不再返回对应的alerts. nflog设置了GC用来删除过期的日志记录。防止一直存在log中导致告警无法继续发送.</p><p>这里有个疑问？上面我们看到判断集群状态是否OK的是用的 <code>p.readyc</code> 这个channel，这个channel在 <code>go peer.Settle(ctx, *gossipInterval*10)</code> 同步完成之后就关闭了，也就是说后面读取这个channel的话，都是同步成功的状态，如果中途有个alertmanager实例挂掉了，这个还会是集群组建成功的状态吗？</p><p>参考：</p><p><a href="https://yunlzheng.gitbook.io/prometheus-book/part-ii-prometheus-jin-jie/readmd/alertmanager-high-availability" target="_blank" rel="external">Alertmanager高可用</a></p><p><a href="https://blog.csdn.net/jianxian89/article/details/107482423" target="_blank" rel="external">一致性算法-Gossip协议实践(Memberlist)</a></p><p><a href="https://chenxy.blog.csdn.net/article/details/79698757?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.control" target="_blank" rel="external">gossip协议的原理和实战应用</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p id=&quot;div-border-top-green&quot;&gt;我们每个人都不能抱怨自己的出身，没有好的家世，那就去创造好的家世。要知道，那些在雨里奔跑的，从来都是没有伞的孩子。&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&quot;回顾&quot;&gt;&lt;a href=&quot;#回顾&quot; class=&quot;headerlink&quot; title=&quot;回顾&quot;&gt;&lt;/a&gt;回顾&lt;/h2&gt;&lt;h3 id=&quot;gossip&quot;&gt;&lt;a href=&quot;#gossip&quot; class=&quot;headerlink&quot; title=&quot;gossip&quot;&gt;&lt;/a&gt;gossip&lt;/h3&gt;&lt;p&gt;先理解一下gossip协议：在一个有界网络中，每个节点都随机地与其他节点通信，经过一番杂乱无章的通信，最终所有节点的状态都会达成一致。每个节点可能知道所有其他节点，也可能仅知道几个邻居节点，只要这些节可以通过网络连通，最终他们的状态都是一致的，当然这也是疫情传播的特点。&lt;/p&gt;
&lt;p&gt;简单的描述下这个协议，首先要传播谣言就要有种子节点。种子节点每秒都会随机向其他节点发送自己所拥有的节点列表，以及需要传播的消息。任何新加入的节点，就在这种传播方式下很快地被全网所知道。这个协议的神奇就在于它从设计开始就没想到信息一定要传递给所有的节点，但是随着时间的增长，在最终的某一时刻，全网会得到相同的信息。当然这个时刻可能仅仅存在于理论，永远不可达。&lt;/p&gt;
&lt;h3 id=&quot;memberlist&quot;&gt;&lt;a href=&quot;#memberlist&quot; class=&quot;headerlink&quot; title=&quot;memberlist&quot;&gt;&lt;/a&gt;memberlist&lt;/h3&gt;&lt;p&gt;回忆一下memberlist的总体流程：&lt;/p&gt;
    
    </summary>
    
      <category term="Prometheus" scheme="https://magiceses.github.io/categories/Prometheus/"/>
    
    
      <category term="Prometheus" scheme="https://magiceses.github.io/tags/Prometheus/"/>
    
      <category term="Alertmanager" scheme="https://magiceses.github.io/tags/Alertmanager/"/>
    
  </entry>
  
  <entry>
    <title>Prometheus和Thanos的前生今世</title>
    <link href="https://magiceses.github.io/2020/11/02/prometheus-thanos-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>https://magiceses.github.io/2020/11/02/prometheus-thanos-学习总结/</id>
    <published>2020-11-01T19:25:24.000Z</published>
    <updated>2021-10-11T07:57:07.707Z</updated>
    
    <content type="html"><![CDATA[<p id="div-border-top-green">没有人会为你的贫穷负责，却有人为你的富有而喝彩！所以不要活在别人的嘴巴里，做好自己！有路，就大胆的去走；有梦，就大胆地飞翔；前行的路，不怕万人阻挡，只怕自己投降！<br></p><p>总结thanos之前先来回顾一下prometheus</p><h1 id="prometheus-回顾"><a href="#prometheus-回顾" class="headerlink" title="prometheus 回顾"></a>prometheus 回顾</h1><h2 id="云原生监控的事实标准Promethues"><a href="#云原生监控的事实标准Promethues" class="headerlink" title="云原生监控的事实标准Promethues"></a>云原生监控的事实标准Promethues</h2><p>监控系统的历史悠久，是一个颇为成熟的领域，而Prometheus作为新生代的开源监控系统，慢慢成为了云原生体系的监控事实标准，也证明了其设计得到业界认可。Prometheus启发于Google公司的borgmon监控系统，由google前员工在2012年作为社区开源项目创建和开发，并于2015年正式发布。2016年，Prometheus正式加入Cloud Native Computing Foundation，成为仅次于Kubernetes的第二把交椅的项目。</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="/images/prometheus-thanos-1.png" alt="img"></p><a id="more"></a><h2 id="组件概述"><a href="#组件概述" class="headerlink" title="组件概述"></a>组件概述</h2><ul><li><p>Prometheus server</p><p>核心组件，负责从外部主动抓取指标到内存时序数据库，并定时将内存中的指标同步到磁盘。</p></li><li><p>Alertmanager</p><p>转发来自Prometheus server发送的告警信息至外部的告警接收者。</p></li><li><p>Pushgateway</p><p>被监控对象可主动推送指标至Pushgateway，Pushgateway的指标是被Prometheus server抓取。</p></li><li><p>Promethues web UI</p><p>Prometheus server的界面，输入表达式可查询相关的指标数据。</p></li></ul><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>Prometheus的工作流程核心是，以主动拉取pull的方式搜集被监控对象的metrics数据（监控指标数据），并将这些metrics数据存储到一个内存TSDB（时间序列数据库）中，并定期将内存中的指标同步到本地硬盘。有了这个核心工作流程，其余组件只是为了配合这个工作流程。被监控对象也可向Pushgateway组件推送指标，Prometheus最终也会从Pushgateway组件拉取指标到TSDB。Altermanager组件像是一个路由器，将Prometheus的告警进行转发至外部的接收者。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>Prometheus具有以下引人注意的优点：</p><ul><li>强大的多维度数据模型</li><li>灵活而强大的查询语句（PromQL）：在同一个查询语句，可以对多个metrics进行乘法、加法、连接、取分数位等操作。</li><li>易于管理：Prometheus server是一个单独的二进制文件，可直接在本地工作，不依赖于分布式存储。</li><li>高效：平均每个采样点仅占3 bytes，且一个Prometheus server可以处理数百万的 metrics。</li><li>使用pull模式采集时间序列数据，这样不仅有利于本机测试而且可以避免有问题的服务器推送坏的metrics。</li><li>可以采用push gateway的方式把时间序列数据推送至Prometheus server端。</li><li>可以通过服务发现或者静态配置去获取监控目标。</li><li>有多种可视化图形界面。</li><li>非常多的应用都实现了Prometheus的metrics接口以暴露自身各项数据指标让 Prometheus去采集，很多没有适配的应用也会有第三方 exporter 帮它去适配 Prometheus。</li></ul><h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><h3 id="无集群部署"><a href="#无集群部署" class="headerlink" title="无集群部署"></a>无集群部署</h3><p>Prometheus 本身只支持单机部署，没有自带支持集群部署，对于集群化和水平扩展，官方和社区都没有银弹，需要合理选择Federate、Cortex、Thanos等开源方案或自研方案。</p><h3 id="存储容量"><a href="#存储容量" class="headerlink" title="存储容量"></a>存储容量</h3><p>它的存储空间也受限于单机磁盘容量，磁盘容量决定了单个Prometheus所能存储的数据量，数据量大小又取决于被采集服务的指标数量、服务数量、采集速率以及数据过期时间。在数据量大的情况下，我们可能就需要做很多取舍，比如丢弃不重要的指标、降低采集速率、设置较短的数据过期时间。</p><h3 id="非精确监控系统"><a href="#非精确监控系统" class="headerlink" title="非精确监控系统"></a>非精确监控系统</h3><p>在设计上的权衡：放弃了一部分数据准确性，但放弃一点准确性得到的是更高的可靠性，监控系统一般情况下可用性大于一致性，容忍部分副本数据丢失，保证查询请求成功。Prometheus不一定保证数据准确，这里的非精确来自两个方面：<br>1）rate、histogram_quantile等数学函数。<br>2）来查询范围过长要做降采样，势必会造成数据精度丢失。</p><h2 id="资源消耗"><a href="#资源消耗" class="headerlink" title="资源消耗"></a>资源消耗</h2><p>在一个节点数量为6的kuberntes集群（指标主要来自kubelet服务、node-exporter服务、kube-apiserver、kube-controller等核心服务），单个Prometheus实例消耗0.1-0.4个cpu，2.5G-3G内存。</p><p><img src="/images/prometheus-thanos-2.png" alt="在这里插入图片描述"></p><h1 id="Prometheus高可用方案"><a href="#Prometheus高可用方案" class="headerlink" title="Prometheus高可用方案"></a>Prometheus高可用方案</h1><h2 id="业界Prometheus高可用方案概述"><a href="#业界Prometheus高可用方案概述" class="headerlink" title="业界Prometheus高可用方案概述"></a>业界Prometheus高可用方案概述</h2><ul><li>基本HA：即两套 Prometheus 采集完全一样的数据，外边挂负载均衡；</li><li>HA + 远程存储：除了基础的多副本 Prometheus，还通过 Remote Write 写入到远程存储，解决存储持久化问题；</li><li>联邦集群：即Federation，按照功能进行分区，不同的 Shard 采集不同的数据，由 Global 节点来统一存放，解决监控数据规模的问题。</li></ul><p>使用 Thanos或者Victoriametrics，来解决全局查询、多副本数据 Join 问题。</p><p>就算使用官方建议的多副本+联邦，仍然会遇到一些问题，比如官方建议数据做Shard，然后通过Federation来实现高可用，但是边缘节点和Global节点依然是单点，需要自行决定是否每一层都要使用双节点重复采集进行保活。本质原因是，Prometheus的本地存储没有数据同步能力，要在保证可用性的前提下，再保持数据一致性是比较困难的，基础的HA Proxy满足不了以下要求，比如：集群的后端有A和B两个实例，A和B之间没有数据同步。A 宕机一段时间，丢失了一部分指标数据，如果负载均衡正常轮询，请求打到 A 上时，数据就会异常。</p><h2 id="增强高可用的Prometheus数据一致性的思路"><a href="#增强高可用的Prometheus数据一致性的思路" class="headerlink" title="增强高可用的Prometheus数据一致性的思路"></a>增强高可用的Prometheus数据一致性的思路</h2><p>解决方案是可以从存储、查询两个角度上保证数据的一致。</p><h3 id="存储角度"><a href="#存储角度" class="headerlink" title="存储角度"></a>存储角度</h3><p>如果使用 Remote Write 远程存储， A和B后面可以都加一个Adapter，Adapter做选主逻辑，只有一份数据能推送到 TSDB，这样可以保证一个异常，另一个也能推送成功，数据不丢，同时远程存储只有一份，是共享数据。</p><h3 id="查询角度"><a href="#查询角度" class="headerlink" title="查询角度"></a>查询角度</h3><p>存储角度的解决方案实现很复杂且有一定风险，因此现在的大多数方案在查询层面做文章，比如Thanos或者Victoriametrics，仍然是两份数据，但是查询时做数据去重和Join。只是Thanos是通过Sidecar把数据放在对象存储，Victoriametrics是把数据Remote Write 到自己的Server实例，但查询层Thanos-Query和Victor的Promxy的逻辑基本一致。</p><h1 id="扩展Prometheus的解决方案"><a href="#扩展Prometheus的解决方案" class="headerlink" title="扩展Prometheus的解决方案"></a>扩展Prometheus的解决方案</h1><h2 id="cortext"><a href="#cortext" class="headerlink" title="cortext"></a>cortext</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Cortex（<a href="https://cortexmetrics.io）为Prometheus提供了水平可扩展，高可用性，多租户的长期存储。目前在cncf" target="_blank" rel="external">https://cortexmetrics.io）为Prometheus提供了水平可扩展，高可用性，多租户的长期存储。目前在cncf</a> 沙箱孵化。</p><p>Cortex为Prometheus提供了水平可扩展，高可用性，多租户的长期存储。Cortex是一个CNCF沙箱项目，用于多个生产系统，包括Weave Cloud和Grafana Cloud。Corte主要用作Prometheus的远程写入的存储，它提供与Prometheus兼容的查询API。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>水平可扩展：Cortex可以跨集群中的多台机器运行，超过了单台机器的吞吐量和存储量。这使您能够将指标从多个Prometheus服务器发送到单个Cortex群集，并在单个位置跨所有数据运行“全局聚合”查询；</li><li>高度可用：在集群中运行时，Cortex可以在机器之间复制数据。这样，您就可以在机器故障中幸存下来，而不会在图表中留下空白。</li><li>多租户：Cortex可以将数据和查询与单个群集中的多个不同独立Prometheus源隔离，从而使不受信任的各方共享同一群集；</li><li>长期存储：Cortex支持Amazon DynamoDB，Google Bigtable，Cassandra，S3和GCS来长期存储度量标准数据。这样一来，您可以持久地存储数据，其时间长于任何一台计算机的生命周期，并将此数据用于长期容量规划。</li></ul><h2 id="VictoriaMetrics"><a href="#VictoriaMetrics" class="headerlink" title="VictoriaMetrics"></a>VictoriaMetrics</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>VictoriaMetrics是一种快速，经济高效且可扩展的时间序列数据库。</p><p>它在二进制发行版，Docker映像和源代码中可用。</p><p>VictoriaMetrics也提供付费企业支持。</p><h2 id="Thanos"><a href="#Thanos" class="headerlink" title="Thanos"></a>Thanos</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>诞生于2018年9月，Thanos是一系列组件，基于Prometheus之上的可以组成具有无限存储容量的高可用性指标系统。Thanos是CNCF沙箱项目。Thanos利用Prometheus 2.0存储格式在任何对象存储中经济高效地存储历史指标数据，同时保留快速查询延迟。另外，它提供了所有Prometheus安装的全局查询视图，并且可以即时合并Prometheus HA对中的数据。</p><h3 id="架构-1"><a href="#架构-1" class="headerlink" title="架构"></a>架构</h3><p><img src="/images/prometheus-thanos-3.png" alt="img"></p><p><img src="/images/prometheus-thanos-4.jpeg" alt="img"></p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>提供全局查询视图；</li><li>支持主流对象存储，以提供可靠的历史数据存储；</li><li>支持降准采样，以提供更大时间范围的指标。</li></ul><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>面对大量的存储数据，Thanos有两种横向扩展方式，一种是基于时间的分区(TIME-BASED)，一种是基于标签的分区(LABEL-BASED)。</p><h5 id="基于时间的分区-TIME-BASED"><a href="#基于时间的分区-TIME-BASED" class="headerlink" title="基于时间的分区(TIME-BASED)"></a>基于时间的分区(TIME-BASED)</h5><p>默认情况下，Thanos的存储网关(Store Gateway)查看对象存储(OSS)中的所有数据，并根据查询的时间范围返回这些数据。所有StoreAPI源都会公布可用的最短和最长时间。我们可以使用这些参数来缩小这个分区的范围，此参数可以是相对时间，也可以是具体日期。如</p><ul><li>A: <code>max-time=-6w</code></li><li>B: <code>min-time=-8w</code> and <code>max-time=-2w</code></li><li>C: <code>min-time=-3w</code></li></ul><h5 id="基于标签的分区-LABEL-BASED"><a href="#基于标签的分区-LABEL-BASED" class="headerlink" title="基于标签的分区(LABEL-BASED)"></a>基于标签的分区(LABEL-BASED)</h5><p>基于标签的分区类似于基于时间的分区，所有StoreAPI源都会公布可用的LABEL序列的相关标签，，这些标签来自Prometheus的external标签，并基于Thanos组件显式设置标签。</p><h5 id="重复数据消除-DEDUPLICATION"><a href="#重复数据消除-DEDUPLICATION" class="headerlink" title="重复数据消除(DEDUPLICATION)"></a>重复数据消除(DEDUPLICATION)</h5><p>在Thanos架构中我们可以使用多个相同的Prometheus实例来实现高可用(HA)，以防止Prometheus单点故障。Thanos提供了查询结果的重复数据消除功能，从而可以实现Prometheus查询无缝对接。为了实现这一点，我们只需要在sidecar组件上设置一个或多个副本标签，其余的由query组件完成。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Prometheus + sidecar “A”: cluster=1,env=2,replica=A</span><br><span class="line">Prometheus + sidecar “B”: cluster=1,env=2,replica=B</span><br><span class="line">Prometheus + sidecar “A” in different cluster: cluster=2,env=2,replica=A</span><br></pre></td></tr></table></figure><p>查询示例: <code>up{job=&quot;prometheus&quot;,env=&quot;2&quot;}</code>. <strong>重复数据消除</strong>功能开户后:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">up&#123;job=&quot;prometheus&quot;,env=&quot;2&quot;,cluster=&quot;1&quot;&#125; 1</span><br><span class="line">up&#123;job=&quot;prometheus&quot;,env=&quot;2&quot;,cluster=&quot;2&quot;&#125; 1</span><br></pre></td></tr></table></figure><p>没有开启重复数据消除功能:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">up&#123;job=&quot;prometheus&quot;,env=&quot;2&quot;,cluster=&quot;1&quot;,replica=&quot;A&quot;&#125; 1</span><br><span class="line">up&#123;job=&quot;prometheus&quot;,env=&quot;2&quot;,cluster=&quot;1&quot;,replica=&quot;B&quot;&#125; 1</span><br><span class="line">up&#123;job=&quot;prometheus&quot;,env=&quot;2&quot;,cluster=&quot;2&quot;,replica=&quot;A&quot;&#125; 1</span><br></pre></td></tr></table></figure><h4 id="降采样"><a href="#降采样" class="headerlink" title="降采样"></a>降采样</h4><p>在Thanos中进行降采样(DOWNSAMPLING)的目的不是为了节省磁盘空间。它的主要好处是使长周期范围的数据查询（如数月或数年）变得更快。事实上降采样并不会节省任何空间，它为每个原始块添加多了两个新块，它们略小于或接近原始块的大小。这意味着，降采样稍微增加了存储空间使用量，但在查询长周期范围时，它提供了巨大的性能和带宽占用优势。</p><p>三个粒度的块(chunks)：</p><ul><li>raw — Prometheus的原始metrics块；</li><li>5m — 原始metrics块的5分钟压缩块</li><li>1h —原始metrics块的1小时压缩块</li></ul><p><img src="/images/prometheus-thanos-5.png" alt="img"></p><p>使用压缩块查询的优势对比：</p><p><img src="/images/prometheus-thanos-6.png" alt="img"></p><p>在没有降采样块的情况下查询长周期范围意味着必须下载和处理与范围长度成比例的数据量。在1y示例中，我们将看到，降采样后就不需要下载20亿个样本（2GB，Prometheus默认15秒一个采样数据），而只需要获取和处理800万个样本（9MB），就足以呈现一个年度图表，这将带来很大的性能改进，并减少了很多带宽使用。</p><h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><h4 id="Thanos-sidecar"><a href="#Thanos-sidecar" class="headerlink" title="Thanos sidecar"></a>Thanos sidecar</h4><p>Sidecar作为一个单独的进程和已有的Prometheus实例运行在一个server上，互不影响。Sidecar可以视为一个Proxy组件，所有对Prometheus的访问都通过Sidecar来代理进行。通过Sidecar还可以将采集到的数据直接备份到云端对象存储服务器。</p><p>同时可支持多种对象存储(OSS)，<a href="https://thanos.io/storage.md/#configuration" target="_blank" rel="external">如Aliyun、腾讯云、S3、Google云存储、Azure存储等</a>，可无缝集成在Prometheus operator中进行部署。</p><h4 id="Thanos-store-gateway"><a href="#Thanos-store-gateway" class="headerlink" title="Thanos store gateway"></a>Thanos store gateway</h4><p>Store gateway实现了一套和Sidecar完全一致的API提供给Querier用于查询Sidecar备份到云端对象存储的数据。因为Sidecar在完成数据备份后，Prometheus会清理掉本地数据保证本地空间可用。所以当监控人员需要调取历史数据时只能去对象存储空间获取，而Store就提供了这样一个接口。Store Gateway内部还做了一些加速数据获取的优化逻辑，一是缓存了 TSDB 索引，二是优化了对象存储的远程调用请求 (用尽可能少的请求量拿到所有需要的数据)。</p><ul><li><p><strong>Store</strong></p><ul><li>从对象存储(OSS)中检索块(chunks)，以便查询长周期的监控指标</li><li>支持基于时间(time-based)的分区查询</li><li>支持基于标签(label-based)的分区查询</li></ul></li><li><p><strong>Bucket</strong></p><ul><li>监视对象存储Bucket中存储的监控数据</li></ul></li></ul><h4 id="Thanos-query"><a href="#Thanos-query" class="headerlink" title="Thanos query"></a>Thanos query</h4><p><img src="/images/prometheus-thanos-7.png" alt="img"></p><p>Querier从Sidecar和Store gateway获取指标数据，同时Querier实现了一套Prometheus官方的HTTP API从而保证对外提供与Prometheus一致的数据源接口，Grafana可以通过同一个查询接口请求不同集群的数据，Querier负责找到对应的集群并通过Sidecar获取数据，也能从Store gateway获取指标数据。Querier本身也是无状态的、可水平可扩展的，因而可以实现高可部署。Querier可以实现对高可部署的Prometheus的数据进行合并从而保证多次查询结果的一致性，从而解决全局视图和Prometheus高可用的问题。</p><p><img src="/images/prometheus-thanos-8.png" alt="img"></p><p>Thanos Query查询位于下游的Thanos Sidecar的指标数据，而Thanos Sidecar的指标数据来自与其绑定的Prometheus实例。</p><h4 id="Thanos-ruler"><a href="#Thanos-ruler" class="headerlink" title="Thanos ruler"></a>Thanos ruler</h4><p>对监控数据进行评估和告警，还可以计算出新的监控数据，将这些新指标数据提供给 Thanos Query 查询，上传指标数据到对象存储，以供长期存储。</p><h4 id="Thanos-compactor"><a href="#Thanos-compactor" class="headerlink" title="Thanos compactor"></a>Thanos compactor</h4><p>通常在查看较大时间范围的监控数据时，很多时候并不需要那么详细的数据，更多时候是为了得到数据趋势。compactor读取对象存储的数据，对其进行压缩以及降采样后再上传到对象存储，在查询大时间范围数据时就只读取压缩和降采样后的数据，极大地减少了查询的数据量，从而加速查询。</p><p>注意：Compact 组件并不会减少对象存储的使用空间，而是会增加，因为增加更长采样间隔的指标数据。如此一来，当查询大时间范围的数据时，就自动拉取更长时间间隔采样的数据以减少查询数据的总量，从而加快查询速度（大时间范围的数据不需要很精细的指标，需要的是趋势），当放大往细节查看时 (选择其中一小段时间)，又自动选择拉取更短采样间隔的数据，从而也能显示出小时间范围的监控细节。</p><h1 id="Thanos-部署"><a href="#Thanos-部署" class="headerlink" title="Thanos 部署"></a>Thanos 部署</h1><p>## </p><p>thanos主要使用到sidecar和query，如果需要数据备份至云存储，store组件也得启动。</p><h2 id="Thanos-Sidecar"><a href="#Thanos-Sidecar" class="headerlink" title="Thanos Sidecar"></a>Thanos Sidecar</h2><p>Thanos Sidecar以边车形式和Prometheus处于同一个Pod中，由于Prometheus散落在多个集群中，因此Thanos Sidecar位于多个集群中。prometheus和thanos sidecar是通过prometheus-operator来进行部署。thanos sidecar也通过nodePort方式的暴露（由于一个集群有2个thanos sidecar，因此分为设置nodePort为10901和10902）。thanos sidecar暴露的原因是作为位于其他集群的thanos query组件的后端存储。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">monitoring.coreos.com/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Prometheus</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    prometheus:</span> <span class="string">k8s</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">k8s</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">monitoring</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  alerting:</span></span><br><span class="line"><span class="attr">    alertmanagers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">alertmanager-main</span></span><br><span class="line"><span class="attr">      namespace:</span> <span class="string">monitoring</span></span><br><span class="line"><span class="attr">      port:</span> <span class="string">web</span></span><br><span class="line"><span class="attr">  image:</span> <span class="string">quay.mirrors.ustc.edu.cn/prometheus/prometheus:v2.15.2</span></span><br><span class="line"><span class="attr">  nodeSelector:</span></span><br><span class="line">    <span class="string">kubernetes.io/os:</span> <span class="string">linux</span></span><br><span class="line"><span class="attr">  podMonitorNamespaceSelector:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">  podMonitorSelector:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">  resources:</span></span><br><span class="line"><span class="attr">    requests:</span></span><br><span class="line"><span class="attr">      memory:</span> <span class="number">400</span><span class="string">Mi</span></span><br><span class="line"><span class="attr">  ruleSelector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      prometheus:</span> <span class="string">k8s</span></span><br><span class="line"><span class="attr">      role:</span> <span class="string">alert-rules</span></span><br><span class="line"><span class="attr">  securityContext:</span></span><br><span class="line"><span class="attr">    fsGroup:</span> <span class="number">2000</span></span><br><span class="line"><span class="attr">    runAsNonRoot:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    runAsUser:</span> <span class="number">1000</span></span><br><span class="line"><span class="attr">  serviceAccountName:</span> <span class="string">prometheus-k8s</span></span><br><span class="line"><span class="attr">  serviceMonitorNamespaceSelector:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">  serviceMonitorSelector:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">  version:</span> <span class="string">v2.15.2</span></span><br><span class="line"><span class="attr">  tolerations:</span></span><br><span class="line"><span class="attr">  - effect:</span> <span class="string">NoSchedule</span></span><br><span class="line"><span class="attr">    key:</span> <span class="string">node-role.kubernetes.io/master</span></span><br><span class="line"><span class="attr">  thanos:</span></span><br><span class="line"><span class="attr">    baseImage:</span> <span class="string">quay.mirrors.ustc.edu.cn/thanos/thanos</span></span><br><span class="line"><span class="attr">    version:</span> <span class="string">v0.11.0</span></span><br><span class="line"><span class="attr">    objectStorageConfig:</span></span><br><span class="line"><span class="attr">      key:</span> <span class="string">objectstorage.yaml</span></span><br><span class="line"><span class="attr">     name:</span> <span class="string">thanos-objectstorage</span></span><br><span class="line"><span class="attr">  externalLabels:</span></span><br><span class="line"><span class="attr">    cluster:</span> <span class="string">test</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">thanos-sidecar</span></span><br><span class="line">    <span class="string">statefulset.kubernetes.io/pod-name:</span> <span class="string">prometheus-k8s-0</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">thanos-sidecar-0-external</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">monitoring</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  externalTrafficPolicy:</span> <span class="string">Cluster</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">grpc</span></span><br><span class="line"><span class="attr">    nodePort:</span> <span class="number">10901</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">10901</span></span><br><span class="line"><span class="attr">    protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="string">grpc</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    prometheus:</span> <span class="string">k8s</span></span><br><span class="line">    <span class="string">statefulset.kubernetes.io/pod-name:</span> <span class="string">prometheus-k8s-0</span></span><br><span class="line"><span class="attr">  sessionAffinity:</span> <span class="string">None</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">NodePort</span></span><br><span class="line"><span class="bullet">-</span><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">thanos-sidecar</span></span><br><span class="line">    <span class="string">statefulset.kubernetes.io/pod-name:</span> <span class="string">prometheus-k8s-1</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">thanos-sidecar-1-external</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">monitoring</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  externalTrafficPolicy:</span> <span class="string">Cluster</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">grpc</span></span><br><span class="line"><span class="attr">    nodePort:</span> <span class="number">10902</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">10901</span></span><br><span class="line"><span class="attr">    protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="string">grpc</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    prometheus:</span> <span class="string">k8s</span></span><br><span class="line">    <span class="string">statefulset.kubernetes.io/pod-name:</span> <span class="string">prometheus-k8s-1</span></span><br><span class="line"><span class="attr">  sessionAffinity:</span> <span class="string">None</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">NodePort</span></span><br></pre></td></tr></table></figure><h2 id="Thanos-query-1"><a href="#Thanos-query-1" class="headerlink" title="Thanos query"></a>Thanos query</h2><p>Thanos Query是无状态服务，以Deployment形式、双副本部署在一个独立集群中。通过配置文件的方式指定位于其他集群中的thanos sidecar。</p><p><img src="/images/prometheus-thanos-9.png" alt="在这里插入图片描述"></p><p>说明：</p><ul><li>开启部分响应特性，此时在部分后端 Store API 返回错误或超时的情况下也能查询到正确的监控数据(如果后端 Store API 做了高可用，挂掉一个副本，Query访问挂掉的副本超时，但由于还存在其他可用的副本，于是客户端能获取正确的查询结果；如果挂掉的某个后端本身就不存在客户端需要的数据，挂掉也不影响查询结果的正确性)；</li><li>开启查询时自动降采样的特性，以提供查询效率。</li></ul><h2 id="Thanos-store-gateway-1"><a href="#Thanos-store-gateway-1" class="headerlink" title="Thanos store gateway"></a>Thanos store gateway</h2><p>store gateway以StatefulSet形式、双副本部署在一个独立集群中。为它创建Kubernetes headless service，用于 Thanos Query组件对Store Gateway进行服务发现。</p><h2 id="Thanos-ruler-1"><a href="#Thanos-ruler-1" class="headerlink" title="Thanos ruler"></a>Thanos ruler</h2><p>Thanos ruler以StatefulSet形式、双副本部署在一个独立集群（和thanos query同一个集群）中。为它创建Kubernetes headless service，用于 Thanos Query组件对Thanos Ruler进行集群内的服务发现。另外我制作了一个小镜像用于让ruler组件重载配置文件，在规则文件被修改的时候。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line">    <span class="string">app.kubernetes.io/name:</span> <span class="string">thanos-rule</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">thanos-rule</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">monitoring</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  clusterIP:</span> <span class="string">None</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">grpc</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">10901</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="string">grpc</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">10902</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line">    <span class="string">app.kubernetes.io/name:</span> <span class="string">thanos-rule</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line">    <span class="string">app.kubernetes.io/name:</span> <span class="string">thanos-rule</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">thanos-rule</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">monitoring</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line">      <span class="string">app.kubernetes.io/name:</span> <span class="string">thanos-rule</span></span><br><span class="line"><span class="attr">  serviceName:</span> <span class="string">thanos-rules</span></span><br><span class="line"><span class="attr">  podManagementPolicy:</span> <span class="string">Parallel</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line">        <span class="string">app.kubernetes.io/name:</span> <span class="string">thanos-rule</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      serviceAccount:</span> <span class="string">thanos-rules</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">reloader</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">registry.cn-shenzhen.aliyuncs.com/gzlj/thanos-reloader:v0.1</span></span><br><span class="line"><span class="attr">        imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line"><span class="attr">        resources:</span></span><br><span class="line"><span class="attr">          limits:</span></span><br><span class="line"><span class="attr">            cpu:</span> <span class="number">100</span><span class="string">m</span></span><br><span class="line"><span class="attr">            memory:</span> <span class="number">100</span><span class="string">Mi</span></span><br><span class="line"><span class="attr">      - args:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">rule</span></span><br><span class="line"><span class="bullet">        -</span> <span class="bullet">--grpc-address=0.0.0.0:10901</span></span><br><span class="line"><span class="bullet">        -</span> <span class="bullet">--http-address=0.0.0.0:10902</span></span><br><span class="line"><span class="bullet">        -</span> <span class="bullet">--rule-file=/etc/thanos/rules/*rules.yaml</span></span><br><span class="line"><span class="bullet">        -</span> <span class="bullet">--objstore.config-file=/etc/thanos/objectstorage.yaml</span></span><br><span class="line"><span class="bullet">        -</span> <span class="bullet">--data-dir=/var/thanos/rule</span></span><br><span class="line"><span class="bullet">        -</span> <span class="bullet">--label=rule_replica="$(NAME)"</span></span><br><span class="line"><span class="bullet">        -</span> <span class="bullet">--alert.label-drop="rule_replica"</span></span><br><span class="line"><span class="bullet">        -</span> <span class="bullet">--query=dnssrv+_http._tcp.thanos-query.monitoring.svc.cluster.local</span></span><br><span class="line"><span class="bullet">        -</span> <span class="bullet">--alertmanagers.url=http://alertmanager-main.monitoring.svc.cluster.local:9093</span></span><br><span class="line"><span class="attr">        env:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">NAME</span></span><br><span class="line"><span class="attr">          valueFrom:</span></span><br><span class="line"><span class="attr">            fieldRef:</span></span><br><span class="line"><span class="attr">              fieldPath:</span> <span class="string">metadata.name</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">quay.mirrors.ustc.edu.cn/thanos/thanos:v0.11.0</span></span><br><span class="line"><span class="attr">        livenessProbe:</span></span><br><span class="line"><span class="attr">          failureThreshold:</span> <span class="number">24</span></span><br><span class="line"><span class="attr">          httpGet:</span></span><br><span class="line"><span class="attr">            path:</span> <span class="string">/-/healthy</span></span><br><span class="line"><span class="attr">            port:</span> <span class="number">10902</span></span><br><span class="line"><span class="attr">            scheme:</span> <span class="string">HTTP</span></span><br><span class="line"><span class="attr">          periodSeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">thanos-rule</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">10901</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">grpc</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">10902</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">        readinessProbe:</span></span><br><span class="line"><span class="attr">          failureThreshold:</span> <span class="number">18</span></span><br><span class="line"><span class="attr">          httpGet:</span></span><br><span class="line"><span class="attr">            path:</span> <span class="string">/-/ready</span></span><br><span class="line"><span class="attr">            port:</span> <span class="number">10902</span></span><br><span class="line"><span class="attr">            scheme:</span> <span class="string">HTTP</span></span><br><span class="line"><span class="attr">          initialDelaySeconds:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">          periodSeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">        terminationMessagePolicy:</span> <span class="string">FallbackToLogsOnError</span></span><br><span class="line"><span class="attr">        volumeMounts:</span></span><br><span class="line"><span class="attr">        - mountPath:</span> <span class="string">/var/thanos/rule</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">data</span></span><br><span class="line"><span class="attr">          readOnly:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">thanos-objectstorage</span></span><br><span class="line"><span class="attr">          subPath:</span> <span class="string">objectstorage.yaml</span></span><br><span class="line"><span class="attr">          mountPath:</span> <span class="string">/etc/thanos/objectstorage.yaml</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">thanos-rules</span></span><br><span class="line"><span class="attr">          mountPath:</span> <span class="string">/etc/thanos/rules</span></span><br><span class="line"><span class="attr">      volumes:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">thanos-objectstorage</span></span><br><span class="line"><span class="attr">        secret:</span></span><br><span class="line"><span class="attr">          secretName:</span> <span class="string">thanos-objectstorage</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">thanos-rules</span></span><br><span class="line"><span class="attr">        configMap:</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">thanos-rules</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">data</span></span><br><span class="line"><span class="attr">        emptyDir:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure><h1 id="Thanos-Operator部署"><a href="#Thanos-Operator部署" class="headerlink" title="Thanos Operator部署"></a>Thanos Operator部署</h1><h2 id="Thanos-operator-CRDs"><a href="#Thanos-operator-CRDs" class="headerlink" title="Thanos operator CRDs"></a>Thanos operator CRDs</h2><p><img src="/images/prometheus-thanos-10.png" alt="image-20210905124307681"></p><h3 id="ObjectStore"><a href="#ObjectStore" class="headerlink" title="ObjectStore"></a>ObjectStore</h3><p>该资源负责 bucket 管理。 Thanos 在 bucket 上压缩和采样，强烈建议您每个 bucket 只运行一个 compactor。</p><blockquote><p>一般来说，超过一个部署不是并发安全的，必须针对 bucket 作为单例部署。</p></blockquote><p>此外，还有一个很棒的 bucket 检查工具，称为<code>bucket</code>，它为存储在bucket中的块提供了一个简单的 Web 界面。</p><h3 id="Thanos-amp-StoreEndpoint"><a href="#Thanos-amp-StoreEndpoint" class="headerlink" title="Thanos &amp; StoreEndpoint"></a>Thanos &amp; StoreEndpoint</h3><p>Thanos 是负责查询、存储和规则配置的主要自定义资源。它与代表不同 StoreAPI 端点的 StoreEndpoint 有特殊关系。这些可以是 Sidecar、Store、Rule 或任何其他 Store API 提供程序。 Thanos 资源按 StoreEndpoint 实例化。这意味着您可以为多个 Prometheus 实例或集群使用单个 Thanos 配置。</p><p>现在让我们看一些部署示例，以帮助我们更好地理解 CRD。</p><h2 id="单集群"><a href="#单集群" class="headerlink" title="单集群"></a>单集群</h2><p>在这种情况下，我们将使用 Thanos 的长期存储功能。这意味着我们将安装一个带有 Thanos sidecar 和完整 Thanos 堆栈的 Prometheus 算子。让我们看一个极简主义设置的例子。</p><p><img src="/images/prometheus-thanos-11.png" alt="img"></p><p>可以看到蓝色为无状态服务（stateless），橙色为有状态服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//编辑prometheus-operator的value.ymal文件开启thanos sidecar（待补充）</span><br><span class="line"> </span><br><span class="line">//安装、删除prometheus-operator</span><br><span class="line">helm template ./charts/prometheus-operator --name tpo --namespace monitor | kubectl apply --validate=false -f -</span><br><span class="line">helm template ./charts/prometheus-operator --name tpo --namespace monitor | kubectl delete --ignore-not-found=true -f -</span><br><span class="line"> </span><br><span class="line">//下载Thanos Operator</span><br><span class="line">helm repo add banzaicloud-stable https://kubernetes-charts.banzaicloud.com</span><br><span class="line">helm fetch --untar --untardir ./charts banzaicloud-stable/thanos</span><br><span class="line"> </span><br><span class="line">//编辑value.ymal文件（待补充）</span><br><span class="line"> </span><br><span class="line">//手动安装Thanos</span><br><span class="line">helm template ./charts/thanos --name t-thanos --namespace monitor | kubectl -n monitor apply --validate=false -f -</span><br><span class="line">helm template ./charts/thanos --name t-thanos --namespace monitor | kubectl -n monitor delete --ignore-not-found=true -f -</span><br></pre></td></tr></table></figure><h3 id="objectstore"><a href="#objectstore" class="headerlink" title="objectstore"></a><strong>objectstore</strong></h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">monitoring.banzaicloud.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ObjectStore</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">objectstore-sample</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  config:</span></span><br><span class="line"><span class="attr">    mountFrom:</span></span><br><span class="line"><span class="attr">      secretKeyRef:</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">thanos</span></span><br><span class="line"><span class="attr">        key:</span> <span class="string">object-store.yaml</span></span><br><span class="line"><span class="attr">  bucketWeb:</span></span><br><span class="line"><span class="attr">    label:</span> <span class="string">cluster</span></span><br><span class="line"><span class="attr">  compactor:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="storeendpoint"><a href="#storeendpoint" class="headerlink" title="storeendpoint"></a><strong>storeendpoint</strong></h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">monitoring.banzaicloud.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StoreEndpoint</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">storeendpoint-sample</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># Add fields here</span></span><br><span class="line"><span class="attr">  thanos:</span> <span class="string">thanos-sample</span></span><br><span class="line"><span class="attr">  config:</span></span><br><span class="line"><span class="attr">    mountFrom:</span></span><br><span class="line"><span class="attr">      secretKeyRef:</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">thanos</span></span><br><span class="line"><span class="attr">        key:</span> <span class="string">object-store.yaml</span></span><br><span class="line"><span class="attr">  selector:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="thanos"><a href="#thanos" class="headerlink" title="thanos"></a><strong>thanos</strong></h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">monitoring.banzaicloud.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Thanos</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">thanos-sample</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  query:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">  rule:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">  storeGateway:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="多集群"><a href="#多集群" class="headerlink" title="多集群"></a>多集群</h2><p>根据上面的部署，我们只有一个集群部署，但是如果我们有多个集群并且需要一种查看它们的方法怎么办？我们可以采取几种不同的方法。现在，我们将探索最基本的。我们已经安装了多个安装了 Thanos 的集群。我们需要使用指向这些集群的端点配置 Thanos 自定义资源。</p><p><img src="/images/prometheus-thanos-12.png" alt="img"></p><h3 id="Thanos-1"><a href="#Thanos-1" class="headerlink" title="Thanos"></a><strong>Thanos</strong></h3><p>Thanos with only query definition</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">monitoring.banzaicloud.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Thanos</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">thanos-multi</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  query:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="StoreEndpoint"><a href="#StoreEndpoint" class="headerlink" title="StoreEndpoint"></a>StoreEndpoint</h3><p>store-endpoints per cluster</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">monitoring.banzaicloud.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StoreEndpoint</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">remote-cluster-n</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  thanos:</span> <span class="string">thanos-multi</span></span><br><span class="line"><span class="attr">  url:</span> <span class="attr">http://remote-cluster-n.com</span></span><br></pre></td></tr></table></figure><h2 id="观察者集群部署"><a href="#观察者集群部署" class="headerlink" title="观察者集群部署"></a>观察者集群部署</h2><p>此部署模型从集群中减去额外的工作负载，并将 Thanos 组件移动到专用的观察者集群。</p><p><img src="/images/prometheus-thanos-13.png" alt="Thanos Observer Cluster"></p><h3 id="Thanos-2"><a href="#Thanos-2" class="headerlink" title="Thanos"></a><strong>Thanos</strong></h3><p>thanos with queryDiscovery definition</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">monitoring.banzaicloud.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Thanos</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">query-master</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  query:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">  queryDiscovery:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>thanos definition for the remote clusters</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">monitoring.banzaicloud.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Thanos</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">thanos-generic-n</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  query:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">  rule:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">  storeGateway:</span> <span class="string">&#123;&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">monitoring.banzaicloud.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StoreEndpoint</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">remote-cluster-n</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  thanos:</span> <span class="string">thanos-generic-n</span></span><br><span class="line"><span class="attr">  url:</span> <span class="attr">http://remote-cluster-n.com</span></span><br><span class="line"><span class="attr">  config:</span></span><br><span class="line"><span class="attr">    mountFrom:</span></span><br><span class="line"><span class="attr">      secretKeyRef:</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">thanos</span></span><br><span class="line"><span class="attr">        key:</span> <span class="string">object-store-n.yaml</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：此部署模型也适用于单集群多命名空间部署</p></blockquote><p>参考：</p><p><a href="https://blog.csdn.net/nangonghen/article/details/108597905?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control" target="_blank" rel="external">扩展Prometheus的解决方案thanos</a></p><p><a href="https://blog.csdn.net/weixin_45502294/article/details/114086025?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-15.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-15.control" target="_blank" rel="external">多集群监控组件Thanos</a></p><p><a href="https://www.dazhuanlan.com/kicker114/topics/1679342" target="_blank" rel="external">Deploy Prometheus Operator With Thanos</a></p><p><a href="https://banzaicloud.com/blog/thanos-operator/" target="_blank" rel="external">Introducing the Thanos Operator</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p id=&quot;div-border-top-green&quot;&gt;没有人会为你的贫穷负责，却有人为你的富有而喝彩！所以不要活在别人的嘴巴里，做好自己！有路，就大胆的去走；有梦，就大胆地飞翔；前行的路，不怕万人阻挡，只怕自己投降！&lt;br&gt;&lt;/p&gt;

&lt;p&gt;总结thanos之前先来回顾一下prometheus&lt;/p&gt;
&lt;h1 id=&quot;prometheus-回顾&quot;&gt;&lt;a href=&quot;#prometheus-回顾&quot; class=&quot;headerlink&quot; title=&quot;prometheus 回顾&quot;&gt;&lt;/a&gt;prometheus 回顾&lt;/h1&gt;&lt;h2 id=&quot;云原生监控的事实标准Promethues&quot;&gt;&lt;a href=&quot;#云原生监控的事实标准Promethues&quot; class=&quot;headerlink&quot; title=&quot;云原生监控的事实标准Promethues&quot;&gt;&lt;/a&gt;云原生监控的事实标准Promethues&lt;/h2&gt;&lt;p&gt;监控系统的历史悠久，是一个颇为成熟的领域，而Prometheus作为新生代的开源监控系统，慢慢成为了云原生体系的监控事实标准，也证明了其设计得到业界认可。Prometheus启发于Google公司的borgmon监控系统，由google前员工在2012年作为社区开源项目创建和开发，并于2015年正式发布。2016年，Prometheus正式加入Cloud Native Computing Foundation，成为仅次于Kubernetes的第二把交椅的项目。&lt;/p&gt;
&lt;h2 id=&quot;架构&quot;&gt;&lt;a href=&quot;#架构&quot; class=&quot;headerlink&quot; title=&quot;架构&quot;&gt;&lt;/a&gt;架构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/prometheus-thanos-1.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Prometheus" scheme="https://magiceses.github.io/categories/Prometheus/"/>
    
    
      <category term="Prometheus" scheme="https://magiceses.github.io/tags/Prometheus/"/>
    
      <category term="Thanos" scheme="https://magiceses.github.io/tags/Thanos/"/>
    
  </entry>
  
  <entry>
    <title>Thanos 源码分析</title>
    <link href="https://magiceses.github.io/2020/11/01/prometheus-thanos-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://magiceses.github.io/2020/11/01/prometheus-thanos-源码分析/</id>
    <published>2020-10-31T19:25:24.000Z</published>
    <updated>2021-10-11T07:58:26.003Z</updated>
    
    <content type="html"><![CDATA[<p id="div-border-top-green">不要因为没有掌声，而放弃梦想，我们需要的是坚持，而不是观众。<br></p><p>thanos组件版本：v0.16.0</p><h1 id="Thanos-Query"><a href="#Thanos-Query" class="headerlink" title="Thanos Query"></a>Thanos Query</h1><h2 id="Thanos-Query的作用"><a href="#Thanos-Query的作用" class="headerlink" title="Thanos Query的作用"></a>Thanos Query的作用</h2><p>Thanos Query组件是http服务器 + grpc服务器，它的数据源是位于下游的已发现的实现STORE API的组件（例如Thanos Sidecar组件、Thanos Store组件、Thanos Ruler组件），同时实现了Prometheus官方的HTTP API。Thanos Query组件从下游处获得数据后，能进行合并、去重等操作，最后将结果返回给外部的客户端。因此，Thanos Query就是数据库中间件的角色。</p><p><img src="/images/prometheus-thanos-14.png" alt="在这里插入图片描述"></p><a id="more"></a><p>使用github.com/oklog/run包来启动一组协程，这些协程的逻辑主要是启动了http server、grpc server、动态发现位于下游的实现STORE API的组件等。</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="/images/prometheus-thanos-15.png" alt="在这里插入图片描述"></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="启动参数"><a href="#启动参数" class="headerlink" title="启动参数"></a>启动参数</h3><p>Thanos的启动命令格式如下，格式都是thanos开头（因为是同一个可执行二进制文件）。启动哪个组件，在于第一个参数，在本例子中是query，因此这条命令是启动query组件的逻辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">thanos query \</span><br><span class="line">--log.level=debug \</span><br><span class="line">--query.auto-downsampling \</span><br><span class="line">--grpc-address=0.0.0.0:10901 \</span><br><span class="line">--http-address=0.0.0.0:9090 \</span><br><span class="line">--query.partial-response \</span><br><span class="line">--query.replica-label=prometheus_replica \</span><br><span class="line">--query.replica-label=rule_replica \</span><br><span class="line">--store=dnssrv+_grpc._tcp.prometheus-headless.thanos.svc.cluster.local \</span><br><span class="line">--store=dnssrv+_grpc._tcp.thanos-rule.thanos.svc.cluster.local \</span><br><span class="line">--store=dnssrv+_grpc._tcp.thanos-store.thanos.svc.cluster.local</span><br></pre></td></tr></table></figure><blockquote><p>注意：<br>1、partial-response 一定要加上</p><p>这个flag设立的目的是遵照数据一致性原则<br>如果1、2、3中有某个返回查询数据为空或者超时（默认是2分钟）的情况下，这次整体的结果是否还要保留：<br>开启的情况下 ， 有点儿部分人成虎的感觉<br>不开启，则必须要求每个上游都要有结果才行，真一致性</p><p>2、deduplicate</p><p>不去重的情况下，会看到相同数据了具体来自哪个数据源，尤其是prom和ruler源<br>去重开启，程序后台会对每次响应的数据源做个打分，选择优秀的源作为本次的gRPC对象</p></blockquote><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><h4 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h4><p>来具体看看main方法。创建app对象，app对象包含了所有Thanos组件的启动函数，但真正启动时只从map中取出一个函数进行启动，取出哪个函数取决于启动命令。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">app := extkingpin.NewApp(kingpin.New(filepath.Base(os.Args[<span class="number">0</span>]), <span class="string">"A block storage based long-term storage for Prometheus"</span>).Version(version.Print(<span class="string">"thanos"</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把所有组件的启动逻辑都放进app对象中的setups列表中</span></span><br><span class="line">registerSidecar(app)</span><br><span class="line">registerStore(app)</span><br><span class="line">registerQuery(app)</span><br><span class="line">registerRule(app)</span><br><span class="line">registerCompact(app)</span><br><span class="line">registerTools(app)</span><br><span class="line">registerReceive(app)</span><br><span class="line">registerQueryFrontend(app)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据命令行的信息，从app对象的setups列表中取出一个组件逻辑</span></span><br><span class="line">cmd, setup := app.Parse()</span><br><span class="line">logger := logging.NewLogger(*logLevel, *logFormat, *debugName)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g run.Group</span><br><span class="line"><span class="keyword">var</span> tracer opentracing.Tracer</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">tracing相关的代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">reloadCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动特定的一个组件(sidecar、query、store等组件中的一种)，底层还是执行g.Add(...)</span></span><br><span class="line"><span class="keyword">if</span> err := setup(&amp;g, logger, metrics, tracer, reloadCh, *logLevel == <span class="string">"debug"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听来自系统的杀死信号.</span></span><br><span class="line">&#123;</span><br><span class="line">cancel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">g.Add(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> interrupt(logger, cancel)</span><br><span class="line">&#125;, <span class="function"><span class="keyword">func</span><span class="params">(error)</span></span> &#123;</span><br><span class="line"><span class="built_in">close</span>(cancel)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听来配置重载的信号</span></span><br><span class="line">&#123;</span><br><span class="line">cancel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">g.Add(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> reload(logger, cancel, reloadCh)</span><br><span class="line">&#125;, <span class="function"><span class="keyword">func</span><span class="params">(error)</span></span> &#123;</span><br><span class="line"><span class="built_in">close</span>(cancel)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞地等待所有协程中的退出</span></span><br><span class="line"><span class="comment">// 有一个协程返回，其他协程也会返回</span></span><br><span class="line"><span class="keyword">if</span> err := g.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">level.Error(logger).Log(<span class="string">"err"</span>, fmt.Sprintf(<span class="string">"%+v"</span>, errors.Wrapf(err, <span class="string">"%s command failed"</span>, cmd)))</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 到达此处，说明整个程序结束了。</span></span><br><span class="line">level.Info(logger).Log(<span class="string">"msg"</span>, <span class="string">"exiting"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="registerQuery函数"><a href="#registerQuery函数" class="headerlink" title="registerQuery函数"></a>registerQuery函数</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerQuery</span><span class="params">(app *extkingpin.App)</span></span> &#123;</span><br><span class="line">cmd := app.Command(comp.String(), <span class="string">"query node exposing PromQL enabled Query API with data retrieved from multiple store nodes"</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">解析命令行参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Setup()的参数是一个函数，会被放入app对象的setups列表中</span></span><br><span class="line"><span class="comment">//闭包的使用技巧以及相关堆栈的分析</span></span><br><span class="line"><span class="comment">//最核心的是runQuery()方法</span></span><br><span class="line">cmd.Setup(<span class="function"><span class="keyword">func</span><span class="params">(g *run.Group, logger log.Logger, reg *prometheus.Registry, tracer opentracing.Tracer, _ &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, _ <span class="keyword">bool</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> runQuery(</span><br><span class="line">g,</span><br><span class="line">logger,</span><br><span class="line">reg,</span><br><span class="line">tracer,</span><br><span class="line">*requestLoggingDecision,</span><br><span class="line">*grpcBindAddr,</span><br><span class="line">time.Duration(*grpcGracePeriod),</span><br><span class="line">*grpcCert,</span><br><span class="line">*grpcKey,</span><br><span class="line">*grpcClientCA,</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其他代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="runQuery函数"><a href="#runQuery函数" class="headerlink" title="runQuery函数"></a>runQuery函数</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用run.Group对象来启动http server、grpc server、服务发现协程。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runQuery</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">g *run.Group,//其实来自main()</span>方法</span></span><br><span class="line"><span class="function"><span class="title">logger</span> <span class="title">log</span>.<span class="title">Logger</span>,</span></span><br><span class="line"><span class="function"><span class="title">reg</span> *<span class="title">prometheus</span>.<span class="title">Registry</span>,</span></span><br><span class="line"><span class="function"><span class="title">tracer</span> <span class="title">opentracing</span>.<span class="title">Tracer</span>,</span></span><br><span class="line"><span class="function"><span class="title">requestLoggingDecision</span> <span class="title">string</span>,</span></span><br><span class="line"><span class="function"><span class="title">grpcBindAddr</span> <span class="title">string</span>,</span></span><br><span class="line"><span class="function"><span class="title">grpcGracePeriod</span> <span class="title">time</span>.<span class="title">Duration</span>,</span></span><br><span class="line"><span class="function"><span class="title">grpcCert</span> <span class="title">string</span>,</span></span><br><span class="line"><span class="function"><span class="title">grpcKey</span> <span class="title">string</span>,</span></span><br><span class="line"><span class="function"><span class="title">grpcClientCA</span> <span class="title">string</span>,</span></span><br><span class="line"><span class="function">/*</span></span><br><span class="line"><span class="function">其他代码</span></span><br><span class="line"><span class="function">*/</span></span><br><span class="line"><span class="function">) <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line"><span class="comment">// stores对象的类型StoreSet。它包含了一组store组件</span></span><br><span class="line"><span class="comment">//（位于下游的实现Store API的组件），这一组store组件是可以动态变化的</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">type StoreSet struct &#123;</span></span><br><span class="line"><span class="comment">//其他属性</span></span><br><span class="line"><span class="comment">stores       map[string]*storeRef</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">stores = query.NewStoreSet(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// proxy对象，即下游的Store API组件的代理</span></span><br><span class="line"><span class="comment">// 下游的Store API组件的列表，其实就是构造方法的入参stores.Get这个方法来获取</span></span><br><span class="line">proxy            = store.NewProxyStore(logger, reg, stores.Get, component.Query, selectorLset, storeResponseTimeout)</span><br><span class="line">rulesProxy       = rules.NewProxy(logger, stores.GetRulesClients)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">queryableCreator是一个方法，用于创建一个querier结构体对象;</span></span><br><span class="line"><span class="comment">querier结构体的属性proxy就是proxy对象，它包含了一组会动态变化的thanos store组件(动态变化是因为启动了一些额外的专门的协程来动态地修改这个切片);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">queryableCreator = query.NewQueryableCreator(</span><br><span class="line">logger,</span><br><span class="line">extprom.WrapRegistererWithPrefix(<span class="string">"thanos_query_"</span>, reg),</span><br><span class="line">proxy,</span><br><span class="line">maxConcurrentSelects,</span><br><span class="line">queryTimeout,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这一段代码都是启动一些协程，定时发现和动态发现Store API组件的变化，随即更新stores对象中的类型为map[string]*storeRef的属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建http server，注册http handler，并启动server</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">router := route.New()</span><br><span class="line"><span class="comment">//新建QueryAPI结构体对象</span></span><br><span class="line">api := v1.NewQueryAPI(</span><br><span class="line">logger,</span><br><span class="line">stores,</span><br><span class="line">engine,</span><br><span class="line">queryableCreator,</span><br><span class="line">rules.NewGRPCClientWithDedup(rulesProxy, queryReplicaLabels),</span><br><span class="line">enableAutodownsampling,</span><br><span class="line">enableQueryPartialResponse,</span><br><span class="line">enableRulePartialResponse,</span><br><span class="line">queryReplicaLabels,</span><br><span class="line">flagsMap,</span><br><span class="line">instantDefaultMaxSourceResolution,</span><br><span class="line">defaultMetadataTimeRange,</span><br><span class="line">gate.New(</span><br><span class="line">extprom.WrapRegistererWithPrefix(<span class="string">"thanos_query_concurrent_"</span>, reg),</span><br><span class="line">maxConcurrentQueries,</span><br><span class="line">),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为router对象注册http方法</span></span><br><span class="line">api.Register(router.WithPrefix(<span class="string">"/api/v1"</span>), tracer, logger, ins, logMiddleware)</span><br><span class="line"></span><br><span class="line">srv := httpserver.New(logger, reg, comp, httpProbe,</span><br><span class="line">httpserver.WithListen(httpBindAddr),</span><br><span class="line">httpserver.WithGracePeriod(httpGracePeriod),</span><br><span class="line">)</span><br><span class="line"><span class="comment">// http服务器使用router对象</span></span><br><span class="line">srv.Handle(<span class="string">"/"</span>, router)</span><br><span class="line"></span><br><span class="line">g.Add(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">statusProber.Healthy()</span><br><span class="line"><span class="comment">// 启动http server</span></span><br><span class="line"><span class="keyword">return</span> srv.ListenAndServe()</span><br><span class="line">&#125;, <span class="function"><span class="keyword">func</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line">statusProber.NotReady(err)</span><br><span class="line"><span class="keyword">defer</span> statusProber.NotHealthy(err)</span><br><span class="line">srv.Shutdown(err)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建gprc server，注册grpc handler，并启动server</span></span><br><span class="line"><span class="comment">// 它本身也可以是一个store, 为上层的front做准备</span></span><br><span class="line">&#123;</span><br><span class="line">tlsCfg, err := tls.NewServerConfig(log.With(logger, <span class="string">"protocol"</span>, <span class="string">"gRPC"</span>), grpcCert, grpcKey, grpcClientCA)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.Wrap(err, <span class="string">"setup gRPC server"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s := grpcserver.New(logger, reg, tracer, comp, grpcProbe,</span><br><span class="line">grpcserver.WithServer(store.RegisterStoreServer(proxy)),<span class="comment">// 注册grpc handler</span></span><br><span class="line">grpcserver.WithServer(rules.RegisterRulesServer(rulesProxy)),   <span class="comment">// 注册grpc handler</span></span><br><span class="line">grpcserver.WithListen(grpcBindAddr),</span><br><span class="line">grpcserver.WithGracePeriod(grpcGracePeriod),</span><br><span class="line">grpcserver.WithTLSConfig(tlsCfg),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">g.Add(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">statusProber.Ready()</span><br><span class="line"><span class="comment">// 启动grpc server</span></span><br><span class="line"><span class="keyword">return</span> s.ListenAndServe()</span><br><span class="line">&#125;, <span class="function"><span class="keyword">func</span><span class="params">(error)</span></span> &#123;</span><br><span class="line">statusProber.NotReady(err)</span><br><span class="line">s.Shutdown(err)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 至此，http server和grpc server都启动了。</span></span><br><span class="line">level.Info(logger).Log(<span class="string">"msg"</span>, <span class="string">"starting query node"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="QueryAPI结构体及其方法"><a href="#QueryAPI结构体及其方法" class="headerlink" title="QueryAPI结构体及其方法"></a>QueryAPI结构体及其方法</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// QueryAPI is an API used by Thanos Query.</span></span><br><span class="line"><span class="keyword">type</span> QueryAPI <span class="keyword">struct</span> &#123;</span><br><span class="line">baseAPI         *api.BaseAPI</span><br><span class="line">logger          log.Logger</span><br><span class="line">gate            gate.Gate</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造方法，用于创建一个querier结构体对象</span></span><br><span class="line">queryableCreate query.QueryableCreator</span><br><span class="line"></span><br><span class="line">queryEngine     *promql.Engine</span><br><span class="line">ruleGroups      rules.UnaryClient</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">replicaLabels []<span class="keyword">string</span></span><br><span class="line">storeSet      *query.StoreSet</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(qapi *QueryAPI)</span> <span class="title">Register</span><span class="params">(r *route.Router, tracer opentracing.Tracer, logger log.Logger, ins extpromhttp.InstrumentationMiddleware, logMiddleware *logging.HTTPServerMiddleware)</span></span> &#123;</span><br><span class="line">qapi.baseAPI.Register(r, tracer, logger, ins, logMiddleware)</span><br><span class="line">instr := api.GetInstr(tracer, logger, ins, logMiddleware)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其他代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把qapi.query、qapi.series、 qapi.stores注册到入参r，从而完成http handler的注册</span></span><br><span class="line"><span class="comment">// 不管是/query接口和/series接口，每次请求到达都会创建querier对象，而querier对象内含了一组的Store API组件</span></span><br><span class="line">r.Get(<span class="string">"/query"</span>, instr(<span class="string">"query"</span>, qapi.query))</span><br><span class="line">r.Get(<span class="string">"/series"</span>, instr(<span class="string">"series"</span>, qapi.series))</span><br><span class="line">r.Get(<span class="string">"/stores"</span>, instr(<span class="string">"stores"</span>, qapi.stores))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回指标数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(qapi *QueryAPI)</span> <span class="title">series</span><span class="params">(r *http.Request)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, []error, *api.ApiError)</span></span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其他代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个querier对象</span></span><br><span class="line"><span class="comment">// querier对象的属性proxy则包含了一组thanos store组件</span></span><br><span class="line">q, err := qapi.queryableCreate(enableDedup, replicaLabels, storeDebugMatchers, math.MaxInt64, enablePartialResponse, <span class="literal">true</span>).</span><br><span class="line">Querier(r.Context(), timestamp.FromTime(start), timestamp.FromTime(end))</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其他代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">metrics = []labels.Labels&#123;&#125;</span><br><span class="line">sets    []storage.SeriesSet</span><br><span class="line">)</span><br><span class="line"><span class="keyword">for</span> _, mset := <span class="keyword">range</span> matcherSets &#123;</span><br><span class="line"><span class="comment">// 调用querier对象的Select()方法获取指标</span></span><br><span class="line">sets = <span class="built_in">append</span>(sets, q.Select(<span class="literal">false</span>, <span class="literal">nil</span>, mset...))</span><br><span class="line">&#125;</span><br><span class="line">set := storage.NewMergeSeriesSet(sets, storage.ChainedSeriesMerge)</span><br><span class="line"><span class="keyword">for</span> set.Next() &#123;</span><br><span class="line">metrics = <span class="built_in">append</span>(metrics, set.At().Labels())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> metrics, set.Warnings(), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="querier结构体及其方法"><a href="#querier结构体及其方法" class="headerlink" title="querier结构体及其方法"></a>querier结构体及其方法</h4><p>实现了 Querier接口（github.com/prometheus/prometheus/storage/interface.go），此接口的核心方法是Select(…)，这个方法在/query和/series等接口中都会被使用到。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> querier <span class="keyword">struct</span> &#123;</span><br><span class="line">ctx                 context.Context</span><br><span class="line">logger              log.Logger</span><br><span class="line">cancel              <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">mint</span>, <span class="title">maxt</span>          <span class="title">int64</span></span></span><br><span class="line"><span class="function"><span class="title">replicaLabels</span>       <span class="title">map</span>[<span class="title">string</span>]<span class="title">struct</span></span>&#123;&#125;</span><br><span class="line">storeDebugMatchers  [][]*labels.Matcher</span><br><span class="line"></span><br><span class="line"><span class="comment">// proxy包含了一组动态的thanos store组件</span></span><br><span class="line">proxy               storepb.StoreServer</span><br><span class="line"></span><br><span class="line">deduplicate         <span class="keyword">bool</span></span><br><span class="line">maxResolutionMillis <span class="keyword">int64</span></span><br><span class="line">partialResponse     <span class="keyword">bool</span></span><br><span class="line">skipChunks          <span class="keyword">bool</span></span><br><span class="line">selectGate          gate.Gate</span><br><span class="line">selectTimeout       time.Duration</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *querier)</span> <span class="title">Select</span><span class="params">(_ <span class="keyword">bool</span>, hints *storage.SelectHints, ms ...*labels.Matcher)</span> <span class="title">storage</span>.<span class="title">SeriesSet</span></span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其他代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">promise := <span class="built_in">make</span>(<span class="keyword">chan</span> storage.SeriesSet, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(promise)</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其他代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//获取到指标数据</span></span><br><span class="line">set, err := q.selectFn(ctx, hints, ms...)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 把错误送至管道，并退出本协程</span></span><br><span class="line">promise &lt;- storage.ErrSeriesSet(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将指标数据送至管道</span></span><br><span class="line">promise &lt;- set</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回指标的封装</span></span><br><span class="line"><span class="keyword">return</span> &amp;lazySeriesSet&#123;</span><br><span class="line">create: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(storage.SeriesSet, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其他代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 从管道中读取指标</span></span><br><span class="line">set, ok := &lt;-promise</span><br><span class="line"><span class="keyword">return</span> set, set.Next()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取指标，调用的是属性proxy的Series(...)方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *querier)</span> <span class="title">selectFn</span><span class="params">(ctx context.Context, hints *storage.SelectHints, ms ...*labels.Matcher)</span> <span class="params">(storage.SeriesSet, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其他代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// seriesServer结构体重写了Send()方法，在Sender()方法中将gprc返回的数据数据存储到它的seriesSet属性</span></span><br><span class="line">resp := &amp;seriesServer&#123;ctx: ctx&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// q.proxy的实现是ProxyStore结构体</span></span><br><span class="line"><span class="comment">// q.proxy.Series()是grpc方法(流式)</span></span><br><span class="line"><span class="comment">// q.proxy.Series()调用完毕后，resp的seriesSet属性的值会被填充</span></span><br><span class="line"><span class="keyword">if</span> err := q.proxy.Series(&amp;storepb.SeriesRequest&#123;</span><br><span class="line">MinTime:                 hints.Start,</span><br><span class="line">MaxTime:                 hints.End,</span><br><span class="line">Matchers:                sms,</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其他代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;, resp); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">"proxy Series()"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其他代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">set := &amp;promSeriesSet&#123;</span><br><span class="line">mint:  q.mint,</span><br><span class="line">maxt:  q.maxt,</span><br><span class="line">set:   newStoreSeriesSet(resp.seriesSet),  <span class="comment">// 把resp的seriesSet属性抽出来</span></span><br><span class="line">aggrs: aggrs,</span><br><span class="line">warns: warns,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// set就是指标</span></span><br><span class="line"><span class="keyword">return</span> newDedupSeriesSet(set, q.replicaLabels, <span class="built_in">len</span>(aggrs) == <span class="number">1</span> &amp;&amp; aggrs[<span class="number">0</span>] == storepb.Aggr_COUNTER), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ProxyStore对象"><a href="#ProxyStore对象" class="headerlink" title="ProxyStore对象"></a>ProxyStore对象</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ProxyStore implements the store API that proxies request to all given underlying stores.</span></span><br><span class="line"><span class="keyword">type</span> ProxyStore <span class="keyword">struct</span> &#123;</span><br><span class="line">logger         log.Logger</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回位于下游的实现Store API接口的组件，查询指标时会用到此属性</span></span><br><span class="line">stores         <span class="function"><span class="keyword">func</span><span class="params">()</span> []<span class="title">Client</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">component</span>      <span class="title">component</span>.<span class="title">StoreAPI</span></span></span><br><span class="line"><span class="function"><span class="title">selectorLabels</span> <span class="title">labels</span>.<span class="title">Labels</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">responseTimeout</span> <span class="title">time</span>.<span class="title">Duration</span></span></span><br><span class="line"><span class="function"><span class="title">metrics</span>         *<span class="title">proxyStoreMetrics</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>查询指标时，会从下游的所有的Store API的组件中查询指标以及进行合并、去重(如果设置了)</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">根据客户端的请求，从下游的所有的Store API的组件中查询指标以及进行合并、去重，最后将指标传输给入参srv.</span></span><br><span class="line"><span class="comment">这是一个gprc流式接口。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ProxyStore)</span> <span class="title">Series</span><span class="params">(r *storepb.SeriesRequest, srv storepb.Store_SeriesServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其他代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">g, gctx := errgroup.WithContext(srv.Context())</span><br><span class="line">respSender, respCh := newCancelableRespChannel(gctx, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者协程</span></span><br><span class="line">g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">本协程会从后端的thanos store组件中获取指标，并进行指标合并操作。</span></span><br><span class="line"><span class="comment">本协程的关闭，消费者协程也会关闭。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">seriesSet      []storepb.SeriesSet</span><br><span class="line">storeDebugMsgs []<span class="keyword">string</span></span><br><span class="line">wg = &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">wg.Wait()</span><br><span class="line"><span class="comment">//close()方法会引发消费者协程退出</span></span><br><span class="line"><span class="built_in">close</span>(respCh)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历后端的Store API组件</span></span><br><span class="line"><span class="keyword">for</span> _, st := <span class="keyword">range</span> s.stores() &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其他代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">sc, err := st.Series(seriesCtx, r)</span><br><span class="line">seriesSet = <span class="built_in">append</span>(seriesSet, startStreamSeriesSet(seriesCtx, s.logger, closeSeries,</span><br><span class="line">wg, sc, respSender, st.String(), !r.PartialResponseDisabled, s.responseTimeout, s.metrics.emptyStreamResponses))</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其他代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得合并后的指标，再发送给respCh管道</span></span><br><span class="line">mergedSet := storepb.MergeSeriesSets(seriesSet...)</span><br><span class="line"><span class="keyword">for</span> mergedSet.Next() &#123;</span><br><span class="line">lset, chk := mergedSet.At()</span><br><span class="line"><span class="comment">// respSender.send(...)其实是将指标发送给respCh管道</span></span><br><span class="line">respSender.send(storepb.NewSeriesResponse(&amp;storepb.Series&#123;Labels: labelpb.ZLabelsFromPromLabels(lset), Chunks: chk&#125;))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mergedSet.Err()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者协程</span></span><br><span class="line">g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// 响应(已被merged)被本协程获取，并将响应输送给方法入参srv.</span></span><br><span class="line"><span class="keyword">for</span> resp := <span class="keyword">range</span> respCh &#123;</span><br><span class="line"><span class="keyword">if</span> err := srv.Send(resp); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> status.Error(codes.Unknown, errors.Wrap(err, <span class="string">"send series response"</span>).Error())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待生产者协程和消费者协程结束</span></span><br><span class="line"><span class="keyword">if</span> err := g.Wait(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本文分析了代码的轮廓，还有许多细节没有被提及，但Thanos Query组件的代码结构清晰易懂，使用了github.com/oklog/run包来启动一组协程，编写http server和grpc server的思路、动态发现下游Store API组件的套路都值得模仿。</p><h1 id="Thanos-Sidecar"><a href="#Thanos-Sidecar" class="headerlink" title="Thanos Sidecar"></a>Thanos Sidecar</h1><h2 id="Thanos-Sidecar的作用"><a href="#Thanos-Sidecar的作用" class="headerlink" title="Thanos Sidecar的作用"></a>Thanos Sidecar的作用</h2><p>Thanos Query组件和prometheus实例绑定在一起，三大作用：</p><ul><li>作为访问代理，对客户端暴露grpc接口，业务逻辑是访问其绑定的prometheus实例的http接口，从而获取metrics和rule数据，最终返回给客户端；</li><li>如果开启对象存储功能，会将promethues tsdb目录下的所有block目录上传至指定的对象存储系统中；</li><li>监听promethues配置文件的变化，发现文件变化后也是访问prometheus实例的http接口让prometheus重载配置。</li></ul><p><img src="/images/prometheus-thanos-16.png" alt="在这里插入图片描述"></p><p>使用github.com/oklog/run包来启动一组协程，这些协程的逻辑主要是启动了http server、grpc server、动态发现位于下游的实现STORE API的组件等。</p><h2 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="启动参数-1"><a href="#启动参数-1" class="headerlink" title="启动参数"></a>启动参数</h3><p>Thanos的启动命令格式如下，格式都是thanos开头（因为是同一个可执行二进制文件）。启动哪个组件，在于第一个参数，在本例子中是sidecar，因此这条命令是启动sidecar组件的逻辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thanos sidecar \</span><br><span class="line">--prometheus.url=http://localhost:9090/ \</span><br><span class="line">--tsdb.path=/prometheus \</span><br><span class="line">--grpc-address=[$(POD_IP)]:10901 \</span><br><span class="line">--http-address=[$(POD_IP)]:10902 \</span><br></pre></td></tr></table></figure><h3 id="代码分析-1"><a href="#代码分析-1" class="headerlink" title="代码分析"></a>代码分析</h3><h4 id="main方法-1"><a href="#main方法-1" class="headerlink" title="main方法"></a>main方法</h4><p>来具体看看main方法。创建app对象，app对象包含了所有Thanos组件的启动函数，但真正启动时只从map中取出一个函数进行启动，取出哪个函数取决于启动命令。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其他代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">app := extkingpin.NewApp(kingpin.New(filepath.Base(os.Args[<span class="number">0</span>]), <span class="string">"A block storage based long-term storage for Prometheus"</span>).Version(version.Print(<span class="string">"thanos"</span>)))</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其他代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把所有组件的启动逻辑都放进app对象中的setups列表中</span></span><br><span class="line">registerSidecar(app)</span><br><span class="line">registerStore(app)</span><br><span class="line">registerQuery(app)</span><br><span class="line">registerRule(app)</span><br><span class="line">registerCompact(app)</span><br><span class="line">registerTools(app)</span><br><span class="line">registerReceive(app)</span><br><span class="line">registerQueryFrontend(app)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据命令行的信息，从app对象的setups列表中取出一个组件逻辑</span></span><br><span class="line">cmd, setup := app.Parse()</span><br><span class="line">logger := logging.NewLogger(*logLevel, *logFormat, *debugName)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其他代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g run.Group</span><br><span class="line"><span class="keyword">var</span> tracer opentracing.Tracer</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">tracing相关的代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">reloadCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动特定的一个组件(sidecar、query、store等组件中的一种)，底层还是执行g.Add(...)</span></span><br><span class="line"><span class="keyword">if</span> err := setup(&amp;g, logger, metrics, tracer, reloadCh, *logLevel == <span class="string">"debug"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听来自系统的杀死信号.</span></span><br><span class="line">&#123;</span><br><span class="line">cancel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">g.Add(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> interrupt(logger, cancel)</span><br><span class="line">&#125;, <span class="function"><span class="keyword">func</span><span class="params">(error)</span></span> &#123;</span><br><span class="line"><span class="built_in">close</span>(cancel)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听来配置重载的信号</span></span><br><span class="line">&#123;</span><br><span class="line">cancel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">g.Add(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> reload(logger, cancel, reloadCh)</span><br><span class="line">&#125;, <span class="function"><span class="keyword">func</span><span class="params">(error)</span></span> &#123;</span><br><span class="line"><span class="built_in">close</span>(cancel)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞地等待所有协程中的退出</span></span><br><span class="line"><span class="comment">// 有一个协程返回，其他协程也会返回</span></span><br><span class="line"><span class="keyword">if</span> err := g.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">level.Error(logger).Log(<span class="string">"err"</span>, fmt.Sprintf(<span class="string">"%+v"</span>, errors.Wrapf(err, <span class="string">"%s command failed"</span>, cmd)))</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 到达此处，说明整个程序结束了。</span></span><br><span class="line">level.Info(logger).Log(<span class="string">"msg"</span>, <span class="string">"exiting"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="registerSidecar方法"><a href="#registerSidecar方法" class="headerlink" title="registerSidecar方法"></a>registerSidecar方法</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerSidecar</span><span class="params">(app *extkingpin.App)</span></span> &#123;</span><br><span class="line">cmd := app.Command(component.Sidecar.String(), <span class="string">"Sidecar for Prometheus server"</span>)</span><br><span class="line">conf := &amp;sidecarConfig&#123;&#125;</span><br><span class="line"><span class="comment">// 解析命令行参数</span></span><br><span class="line">conf.registerFlag(cmd)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Setup()的入参方法，会被放入app对象的setups列表中</span></span><br><span class="line"><span class="comment">// 最核心的是runSidecar()方法</span></span><br><span class="line">cmd.Setup(<span class="function"><span class="keyword">func</span><span class="params">(g *run.Group, logger log.Logger, reg *prometheus.Registry, tracer opentracing.Tracer, _ &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, _ <span class="keyword">bool</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">rl := reloader.New(log.With(logger, <span class="string">"component"</span>, <span class="string">"reloader"</span>),</span><br><span class="line">extprom.WrapRegistererWithPrefix(<span class="string">"thanos_sidecar_"</span>, reg),</span><br><span class="line">&amp;reloader.Options&#123;</span><br><span class="line">ReloadURL:     reloader.ReloadURLFromBase(conf.prometheus.url),</span><br><span class="line">CfgFile:       conf.reloader.confFile,</span><br><span class="line">CfgOutputFile: conf.reloader.envVarConfFile,</span><br><span class="line">WatchedDirs:   conf.reloader.ruleDirectories,</span><br><span class="line">WatchInterval: conf.reloader.watchInterval,</span><br><span class="line">RetryInterval: conf.reloader.retryInterval,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> runSidecar(g, logger, reg, tracer, rl, component.Sidecar, *conf)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="runSidecar方法"><a href="#runSidecar方法" class="headerlink" title="runSidecar方法"></a>runSidecar方法</h4><p>使用run.Group对象来启动http server、grpc server、传输block目录至对象存储的协程、监听prometheus配置文件的协程、定期检测prometheus实例存活的协程。</p><p>细节说明：</p><ul><li>查看prometheus实例的心跳机制是通过/api/v1/status/config接口；</li><li>监听prometheus配置文件变化的工具包是github.com/fsnotify/fsnotify；</li><li>开启上传block功能，则每30s遍历prometheus tsdb目录下的所有的block目录（已上传的block或空block会被忽略，默认情况下被压缩过的block也会被忽略），并上传相应的文件至对象存储；</li><li>获取不到prometheus实例的external label或者prometheus没有配置external label，会导致sidecar启动失败。</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runSidecar</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">g *run.Group,</span></span></span><br><span class="line"><span class="function"><span class="params">logger log.Logger,</span></span></span><br><span class="line"><span class="function"><span class="params">reg *prometheus.Registry,</span></span></span><br><span class="line"><span class="function"><span class="params">tracer opentracing.Tracer,</span></span></span><br><span class="line"><span class="function"><span class="params">reloader *reloader.Reloader,</span></span></span><br><span class="line"><span class="function"><span class="params">comp component.Component,</span></span></span><br><span class="line"><span class="function"><span class="params">conf sidecarConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用一个结构体来保存prometheus实例的url、prometheus实例的external label、prometheus client等信息。</span></span><br><span class="line"><span class="keyword">var</span> m = &amp;promMetadata&#123;</span><br><span class="line">promURL: conf.prometheus.url,</span><br><span class="line"></span><br><span class="line">mint: conf.limitMinTime.PrometheusTimestamp(),</span><br><span class="line">maxt: math.MaxInt64,</span><br><span class="line"></span><br><span class="line">limitMinTime: conf.limitMinTime,</span><br><span class="line">client:       promclient.NewWithTracingClient(logger, <span class="string">"thanos-sidecar"</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取对象存储的配置信息，如果有，说明是开启上传block至对象存储的功能。</span></span><br><span class="line">confContentYaml, err := conf.objStore.Content()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.Wrap(err, <span class="string">"getting object store config"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> uploads = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(confContentYaml) == <span class="number">0</span> &#123;</span><br><span class="line">level.Info(logger).Log(<span class="string">"msg"</span>, <span class="string">"no supported bucket was configured, uploads will be disabled"</span>)</span><br><span class="line">uploads = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">grpcProbe := prober.NewGRPC()</span><br><span class="line">httpProbe := prober.NewHTTP()</span><br><span class="line">statusProber := prober.Combine(</span><br><span class="line">httpProbe,</span><br><span class="line">grpcProbe,</span><br><span class="line">prober.NewInstrumentation(comp, logger, extprom.WrapRegistererWithPrefix(<span class="string">"thanos_"</span>, reg)),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建http server，并启动server(只有/metrics、/-/healthy、/-/ready等接口)</span></span><br><span class="line">srv := httpserver.New(logger, reg, comp, httpProbe,</span><br><span class="line">httpserver.WithListen(conf.http.bindAddress),</span><br><span class="line">httpserver.WithGracePeriod(time.Duration(conf.http.gracePeriod)),</span><br><span class="line">)</span><br><span class="line">g.Add(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">statusProber.Healthy()</span><br><span class="line"><span class="keyword">return</span> srv.ListenAndServe()</span><br><span class="line">&#125;, <span class="function"><span class="keyword">func</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line">statusProber.NotReady(err)</span><br><span class="line"><span class="keyword">defer</span> statusProber.NotHealthy(err)</span><br><span class="line">srv.Shutdown(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取promehtues实例的external label，并做心跳</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// promUp记录promehtues是否正常，0表示不正常，1表示正常</span></span><br><span class="line">promUp := promauto.With(reg).NewGauge(prometheus.GaugeOpts&#123;</span><br><span class="line">Name: <span class="string">"thanos_sidecar_prometheus_up"</span>,</span><br><span class="line">Help: <span class="string">"Boolean indicator whether the sidecar can reach its Prometheus peer."</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// lastHeartbeat记录最后一次心跳时间</span></span><br><span class="line">lastHeartbeat := promauto.With(reg).NewGauge(prometheus.GaugeOpts&#123;</span><br><span class="line">Name: <span class="string">"thanos_sidecar_last_heartbeat_success_time_seconds"</span>,</span><br><span class="line">Help: <span class="string">"Timestamp of the last successful heartbeat in seconds."</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="comment">// 获取prometheus实例的external label（/api/v1/status/config接口），并通过定期(30s)做这件事情来做心跳</span></span><br><span class="line">g.Add(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">检查性代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取prometheus实例的external label</span></span><br><span class="line">err := runutil.Retry(<span class="number">2</span>*time.Second, ctx.Done(), <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// m.UpdateLabels(ctx)去访问prometheus实例的/api/v1/status/config接口，并将返回的数据设置到自己的属性labels</span></span><br><span class="line"><span class="keyword">if</span> err := m.UpdateLabels(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">promUp.Set(<span class="number">0</span>)</span><br><span class="line">statusProber.NotReady(err)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">promUp.Set(<span class="number">1</span>)</span><br><span class="line">statusProber.Ready()</span><br><span class="line"><span class="comment">// 记录心跳时间</span></span><br><span class="line">lastHeartbeat.SetToCurrentTime()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拿不到prometheus实例的external label或者prometheus没有配置external label则退出</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.Wrap(err, <span class="string">"initial external labels query"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(m.Labels()) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">"no external labels configured on Prometheus server, uniquely identifying external labels must be configured; see https://thanos.io/tip/thanos/storage.md#external-labels for details."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个30s从prometheus实例获取exterlan label，通过此方式来记录心跳时间</span></span><br><span class="line"><span class="keyword">return</span> runutil.Repeat(<span class="number">30</span>*time.Second, ctx.Done(), <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其他代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := m.UpdateLabels(iterCtx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">level.Warn(logger).Log(<span class="string">"msg"</span>, <span class="string">"heartbeat failed"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">promUp.Set(<span class="number">0</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">promUp.Set(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 记录心跳时间</span></span><br><span class="line">lastHeartbeat.SetToCurrentTime()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;, <span class="function"><span class="keyword">func</span><span class="params">(error)</span></span> &#123;</span><br><span class="line">cancel()</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用github.com/fsnotify/fsnotify包监听prometheus实例的配置文件的变化</span></span><br><span class="line"><span class="comment">// 如果文件发生变化则发送一个POST请求给prometheus实例，让它重新加载配置文件</span></span><br><span class="line">&#123;</span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">g.Add(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> reloader.Watch(ctx)</span><br><span class="line">&#125;, <span class="function"><span class="keyword">func</span><span class="params">(error)</span></span> &#123;</span><br><span class="line">cancel()</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">t := exthttp.NewTransport()</span><br><span class="line">t.MaxIdleConnsPerHost = conf.connection.maxIdleConnsPerHost</span><br><span class="line">t.MaxIdleConns = conf.connection.maxIdleConns</span><br><span class="line">c := promclient.NewClient(&amp;http.Client&#123;Transport: tracing.HTTPTripperware(logger, t)&#125;, logger, thanoshttp.ThanosUserAgent)</span><br><span class="line"></span><br><span class="line">promStore, err := store.NewPrometheusStore(logger, reg, c, conf.prometheus.url, component.Sidecar, m.Labels, m.Timestamps)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.Wrap(err, <span class="string">"create Prometheus store"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tlsCfg, err := tls.NewServerConfig(log.With(logger, <span class="string">"protocol"</span>, <span class="string">"gRPC"</span>),</span><br><span class="line">conf.grpc.tlsSrvCert, conf.grpc.tlsSrvKey, conf.grpc.tlsSrvClientCA)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.Wrap(err, <span class="string">"setup gRPC server"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并grpc server</span></span><br><span class="line">s := grpcserver.New(logger, reg, tracer, comp, grpcProbe,</span><br><span class="line"><span class="comment">// 注册grpc handler(通过http client从prometheus实例中获取指标数据)</span></span><br><span class="line">grpcserver.WithServer(store.RegisterStoreServer(promStore)),</span><br><span class="line"><span class="comment">// 注册grpc handler(通过http client从prometheus实例中获取rule数据)</span></span><br><span class="line">grpcserver.WithServer(rules.RegisterRulesServer(rules.NewPrometheus(conf.prometheus.url, c, m.Labels))), </span><br><span class="line">grpcserver.WithListen(conf.grpc.bindAddress),</span><br><span class="line">grpcserver.WithGracePeriod(time.Duration(conf.grpc.gracePeriod)),</span><br><span class="line">grpcserver.WithTLSConfig(tlsCfg),</span><br><span class="line">)</span><br><span class="line">g.Add(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">statusProber.Ready()</span><br><span class="line"><span class="keyword">return</span> s.ListenAndServe()</span><br><span class="line">&#125;, <span class="function"><span class="keyword">func</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line">statusProber.NotReady(err)</span><br><span class="line">s.Shutdown(err)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若开启了上传block功能，则定期遍历prometehus tsdb目录下的所有block目录并上传文件至对象存储。</span></span><br><span class="line"><span class="keyword">if</span> uploads &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一个对象存储bucket</span></span><br><span class="line">bkt, err := client.NewBucket(logger, confContentYaml, reg, component.Sidecar.String())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其他代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">g.Add(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其他代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">拿不到prometheus实例的external label或者prometheus没有配置external label则退出</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">s := shipper.New(logger, reg, conf.tsdb.path, bkt, m.Labels, metadata.SidecarSource,</span><br><span class="line">conf.shipper.uploadCompacted, conf.shipper.allowOutOfOrderUpload)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每30执行一次s.Sync(ctx)</span></span><br><span class="line"><span class="comment">// s.Sync(ctx)会遍历prometheus tsdb目录下的所有block目录(已上传的block或空block会被忽略，默认情况下被压缩过的block也会被忽略)，并上传相应的文件</span></span><br><span class="line"><span class="keyword">return</span> runutil.Repeat(<span class="number">30</span>*time.Second, ctx.Done(), <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> uploaded, err := s.Sync(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 至少有一个block上传失败，则打印日志</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其他代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;, <span class="function"><span class="keyword">func</span><span class="params">(error)</span></span> &#123;</span><br><span class="line">cancel()</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">level.Info(logger).Log(<span class="string">"msg"</span>, <span class="string">"starting sidecar"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>Thanos Sidecar组件的代码逻辑简单、易懂，通过http协议访问与其绑定的prometheus实例，从prometheus实例中获取到的数据则通过grpc接口对外进行暴露，遍历所有block目录进行文件上传，还有监听promethues配置文件变化的小功能。</p><p>参考：</p><p><a href="https://blog.csdn.net/nangonghen/article/details/110731518?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-5.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-5.control" target="_blank" rel="external">thanos sidecar组件源码简析</a></p><p><a href="https://blog.csdn.net/nangonghen/article/details/110010423?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.control" target="_blank" rel="external">thanos query组件源码简析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p id=&quot;div-border-top-green&quot;&gt;不要因为没有掌声，而放弃梦想，我们需要的是坚持，而不是观众。&lt;br&gt;&lt;/p&gt;

&lt;p&gt;thanos组件版本：v0.16.0&lt;/p&gt;
&lt;h1 id=&quot;Thanos-Query&quot;&gt;&lt;a href=&quot;#Thanos-Query&quot; class=&quot;headerlink&quot; title=&quot;Thanos Query&quot;&gt;&lt;/a&gt;Thanos Query&lt;/h1&gt;&lt;h2 id=&quot;Thanos-Query的作用&quot;&gt;&lt;a href=&quot;#Thanos-Query的作用&quot; class=&quot;headerlink&quot; title=&quot;Thanos Query的作用&quot;&gt;&lt;/a&gt;Thanos Query的作用&lt;/h2&gt;&lt;p&gt;Thanos Query组件是http服务器 + grpc服务器，它的数据源是位于下游的已发现的实现STORE API的组件（例如Thanos Sidecar组件、Thanos Store组件、Thanos Ruler组件），同时实现了Prometheus官方的HTTP API。Thanos Query组件从下游处获得数据后，能进行合并、去重等操作，最后将结果返回给外部的客户端。因此，Thanos Query就是数据库中间件的角色。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/prometheus-thanos-14.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Prometheus" scheme="https://magiceses.github.io/categories/Prometheus/"/>
    
    
      <category term="Prometheus" scheme="https://magiceses.github.io/tags/Prometheus/"/>
    
      <category term="Thanos" scheme="https://magiceses.github.io/tags/Thanos/"/>
    
  </entry>
  
  <entry>
    <title>Prometheus Local storage和Remote storage</title>
    <link href="https://magiceses.github.io/2020/10/08/prometheus-prometheus-7-storage/"/>
    <id>https://magiceses.github.io/2020/10/08/prometheus-prometheus-7-storage/</id>
    <published>2020-10-07T19:25:24.000Z</published>
    <updated>2021-10-02T06:02:12.766Z</updated>
    
    <content type="html"><![CDATA[<p id="div-border-top-green">我们每个人的心中，都有两只老虎。第一只老虎，是善的，它大方、善良、慈悲；第二只老虎，是恶的，它狭隘、邪恶、自私。而且，这两只老虎每天都在我们的心里打架……<br></p><blockquote><p>监控系统的扩展性和高可用性绝大部分是由存储决定的。比如著名的zabbix是支持Es做为后端存储的，这就解决了数据可靠性和存储的扩展。而PrometheUS默认是本地存储在tsdb上，如果考虑存储大量的sample，可以考虑remote storage。</p></blockquote><h4 id="Local-storage-简述"><a href="#Local-storage-简述" class="headerlink" title="Local storage 简述"></a>Local storage 简述</h4><p>本地存储的最小单位是block，每个block是最近两个小时的数据。block里面是多个chunk。chunk里面存储的就是sample。此外block里面还有index，用于索引chunk里面的数据，用于快速查找；还有metadata，用于记录block的元数据（存储的数据的开始时间以及结束时间等）；还有一个tombstones文件，用于标记那些sample已经删除了，这里只是标记不是删除。</p><p>本地存储中还有个WAL日志文件（预写日志）。prometheus抓取的数据不会立即刷盘，而是放在内存中。想象一下如果这时候宕机了，数据岂不丢了。wal日志的作用就是防止这个的。wal日志128M作为一个片段，最少也得有三个片段，这个是硬性规定。因为block里面存储的数据是压缩过的，而wal里面的数据是未压缩的，所以wal日志会比block大。在监控项比较多的prometheus上，会看到多于三个片段，这个是正常的，因为WAL日志中最小也要存储两个小时的数据。</p><a id="more"></a><p><img src="/images/prometheus-prometheus-12.png" alt="在这里插入图片描述"></p><p>我说的可能不清楚，如果想详细了解TSDB，可以去GitHub上看：<a href="https://github.com/prometheus/tsdb/blob/master/docs/format/README.md" target="_blank" rel="external">https://github.com/prometheus/tsdb/blob/master/docs/format/README.md</a></p><ul><li>设置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--storage.tsdb.path 存储位置，默认是data目录</span><br><span class="line">--storage.tsdb.retention.time  sample的保留时间，默认是15天</span><br></pre></td></tr></table></figure><p>官方说我们再算存储的时候，每个sample值就按1~2bytes算，那么我们需要的总存储就是：</p><p><code>needed_disk_space = retention_time_seconds * ingested_samples_per_second * bytes_per_sample</code></p><p>ingested_samples_per_second 是每秒抽取多少个指标。bytes_per_sample是每个指标的值的大小，如果指标的数据类型特别多，我觉得可以按照1~2bytes算，如果指标的数据类型比较单一，我觉得你应该自己评估这个值。</p><h4 id="remote-storage简介"><a href="#remote-storage简介" class="headerlink" title="remote storage简介"></a>remote storage简介</h4><p>对于业务比较大的环境Local storage是绝对满足不了的，那么就要用remote storage了。</p><ul><li>prometheus的remote storage需要借助adapter实现。adapter会提供write url和read url给prometheus，这样prometheus获取到数据后就会先写到本地然后再调用write url写到远端。读数据我理解的不好，这里就不多说，据说remote read 对PromQL 支持不好。不是所有的adapter都提供read url的。</li></ul><p><img src="https://img-blog.csdnimg.cn/20190330170057102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ2ODYzOTk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>prometheus调用adapter都是HTTP结合snappy。在不远的将来可能就是 grpc结合HTTP/2了</p></li><li><p>现在prometheus官方和社区整合很多remote storage的adapter,如下图，不只有这些还有clickhouse等，大家可以网上百度去，也可以自行开发:<img src="/images/prometheus-prometheus-13.png" alt="在这里插入图片描述"></p></li></ul><h4 id="remote-storage-to-Elasticsearch"><a href="#remote-storage-to-Elasticsearch" class="headerlink" title="remote storage to Elasticsearch"></a>remote storage to Elasticsearch</h4><p>由于我知识比较贫穷，就了解个Elasticsearch，所以这里就用Elasticsearch做实验了，在上图可以看到，prometheus只能写到Elasticsearch。</p><ul><li><p>准备prometheusbeat</p><p><a href="https://github.com/infonova/prometheusbeat" target="_blank" rel="external">https://github.com/infonova/prometheusbeat</a> 这个是他的github地址。如果懒得编译可以去QQ群里下载，QQ群的地址在最下面。</p></li><li><p>配置prometheusbeat</p><p>设置监听端口</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prometheusbeat:</span><br><span class="line">  # Listen port of the server. Defaults to :8080</span><br><span class="line">  listen: &quot;:8090&quot;</span><br><span class="line">  # Context path. Defaults to /prometheus</span><br><span class="line">  context: &quot;/prometheus</span><br></pre></td></tr></table></figure><ul><li>设置ES的地址</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#-------------------------- Elasticsearch output ------------------------------</span><br><span class="line">output.elasticsearch:</span><br><span class="line">  # Array of hosts to connect to.</span><br><span class="line">  hosts: [&quot;192.168.0.1:9400&quot;]</span><br><span class="line"></span><br><span class="line">  # Optional protocol and basic auth credentials.</span><br><span class="line">  #protocol: &quot;https&quot;</span><br><span class="line">  #username: &quot;elastic&quot;</span><br><span class="line">  #password: &quot;changeme&quot;</span><br></pre></td></tr></table></figure><ul><li>启动</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#这个正常情况下应该后台启动的</span><br><span class="line">./prometheusbeat -c prometheusbeat.yml</span><br></pre></td></tr></table></figure><ul><li>配置prometheus</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">remote_write:</span><br><span class="line">  - url: &quot;http://10.161.4.63:8090/prometheus&quot;</span><br></pre></td></tr></table></figure><ul><li><p>重新加载配置或者重启</p></li><li><p>静静的过一小会儿，查看ES</p></li></ul><p><img src="/images/prometheus-prometheus-14.png" alt="在这里插入图片描述"></p><p><img src="/images/prometheus-prometheus-15.png" alt="在这里插入图片描述"></p><p><br></p><p>原文：<a href="https://blog.csdn.net/u014686399/article/details/88915195?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.baidujs&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.baidujs" target="_blank" rel="external">prometheus之Local storage和remote storage</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p id=&quot;div-border-top-green&quot;&gt;我们每个人的心中，都有两只老虎。第一只老虎，是善的，它大方、善良、慈悲；第二只老虎，是恶的，它狭隘、邪恶、自私。而且，这两只老虎每天都在我们的心里打架……&lt;br&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;监控系统的扩展性和高可用性绝大部分是由存储决定的。比如著名的zabbix是支持Es做为后端存储的，这就解决了数据可靠性和存储的扩展。而PrometheUS默认是本地存储在tsdb上，如果考虑存储大量的sample，可以考虑remote storage。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;Local-storage-简述&quot;&gt;&lt;a href=&quot;#Local-storage-简述&quot; class=&quot;headerlink&quot; title=&quot;Local storage 简述&quot;&gt;&lt;/a&gt;Local storage 简述&lt;/h4&gt;&lt;p&gt;本地存储的最小单位是block，每个block是最近两个小时的数据。block里面是多个chunk。chunk里面存储的就是sample。此外block里面还有index，用于索引chunk里面的数据，用于快速查找；还有metadata，用于记录block的元数据（存储的数据的开始时间以及结束时间等）；还有一个tombstones文件，用于标记那些sample已经删除了，这里只是标记不是删除。&lt;/p&gt;
&lt;p&gt;本地存储中还有个WAL日志文件（预写日志）。prometheus抓取的数据不会立即刷盘，而是放在内存中。想象一下如果这时候宕机了，数据岂不丢了。wal日志的作用就是防止这个的。wal日志128M作为一个片段，最少也得有三个片段，这个是硬性规定。因为block里面存储的数据是压缩过的，而wal里面的数据是未压缩的，所以wal日志会比block大。在监控项比较多的prometheus上，会看到多于三个片段，这个是正常的，因为WAL日志中最小也要存储两个小时的数据。&lt;/p&gt;
    
    </summary>
    
      <category term="Prometheus" scheme="https://magiceses.github.io/categories/Prometheus/"/>
    
    
      <category term="Prometheus" scheme="https://magiceses.github.io/tags/Prometheus/"/>
    
  </entry>
  
  <entry>
    <title>Prometheus PromQL使用</title>
    <link href="https://magiceses.github.io/2020/10/07/prometheus-prometheus-6-PromQL%E5%88%86%E6%9E%90/"/>
    <id>https://magiceses.github.io/2020/10/07/prometheus-prometheus-6-PromQL分析/</id>
    <published>2020-10-06T19:25:24.000Z</published>
    <updated>2021-10-11T06:57:07.882Z</updated>
    
    <content type="html"><![CDATA[<p id="div-border-top-green">改变，永远不嫌晚。无论你是几岁，也无论你目前所处的境况有多糟，只要立定目标、一步一步往前走，人生随时都有翻盘的可能性。<br></p><p>Prometheus 提供了其它大量的内置函数，可以对时序数据进行丰富的处理。某些函数有默认的参数，例如：<code>year(v=vector(time()) instant-vector)</code>。其中参数 <code>v</code> 是一个瞬时向量，如果不提供该参数，将使用默认值 <code>vector(time())</code>。instant-vector 表示参数类型。</p><h2 id="abs"><a href="#abs" class="headerlink" title="abs()"></a>abs()</h2><p><code>abs(v instant-vector)</code> 返回输入向量的所有样本的绝对值。</p><h2 id="absent"><a href="#absent" class="headerlink" title="absent()"></a>absent()</h2><p><code>absent(v instant-vector)</code>，如果传递给它的向量参数具有样本数据，则返回空向量；如果传递的向量参数没有样本数据，则返回不带度量指标名称且带有标签的时间序列，且样本值为1。</p><p>当监控度量指标时，如果获取到的样本数据是空的， 使用 absent 方法对告警是非常有用的。例如：</p><a id="more"></a><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 这里提供的向量有样本数据absent(http_requests_total&#123;method="get"&#125;)  =&gt; no dataabsent(sum(http_requests_total&#123;method="get"&#125;))  =&gt; no data</span><br><span class="line"># 由于不存在度量指标 nonexistent，所以 返回不带度量指标名称且带有标签的时间序列，且样本值为1absent(nonexistent&#123;job="myjob"&#125;)  =&gt; &#123;job="myjob"&#125;  1# 正则匹配的 instance 不作为返回 labels 中的一部分absent(nonexistent&#123;job="myjob",instance=~".*"&#125;)  =&gt; &#123;job="myjob"&#125;  1</span><br><span class="line"># sum 函数返回的时间序列不带有标签，且没有样本数据absent(sum(nonexistent&#123;job="myjob"&#125;))  =&gt; &#123;&#125;  1</span><br></pre></td></tr></table></figure><h2 id="ceil"><a href="#ceil" class="headerlink" title="ceil()"></a>ceil()</h2><p><code>ceil(v instant-vector)</code> 将 v 中所有元素的样本值向上四舍五入到最接近的整数。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node_load5&#123;instance="192.168.1.75:9100"&#125; # 结果为 2.79</span><br><span class="line">ceil(node_load5&#123;instance="192.168.1.75:9100"&#125;) # 结果为 3</span><br></pre></td></tr></table></figure><h2 id="changes"><a href="#changes" class="headerlink" title="changes()"></a>changes()</h2><p><code>changes(v range-vector)</code> 输入一个区间向量， 返回这个区间向量内每个样本数据值变化的次数（瞬时向量）。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 如果样本数据值没有发生变化，则返回结果为 1</span><br><span class="line">changes(node_load5&#123;instance="192.168.1.75:9100"&#125;[1m]) # 结果为 1</span><br></pre></td></tr></table></figure><h2 id="clamp-max"><a href="#clamp-max" class="headerlink" title="clamp_max()"></a>clamp_max()</h2><p><code>clamp_max(v instant-vector, max scalar)</code> 函数，输入一个瞬时向量和最大值，样本数据值若大于 max，则改为 max，否则不变。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node_load5&#123;instance="192.168.1.75:9100"&#125; # 结果为 2.79</span><br><span class="line">clamp_max(node_load5&#123;instance="192.168.1.75:9100"&#125;, 2) # 结果为 2</span><br><span class="line">1.2.</span><br></pre></td></tr></table></figure><h2 id="clamp-min"><a href="#clamp-min" class="headerlink" title="clamp_min()"></a>clamp_min()</h2><p><code>clamp_min(v instant-vector, min scalar)</code> 函数，输入一个瞬时向量和最小值，样本数据值若小于 min，则改为 min，否则不变。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node_load5&#123;instance="192.168.1.75:9100"&#125; # 结果为 2.79</span><br><span class="line">clamp_min(node_load5&#123;instance="192.168.1.75:9100"&#125;, 3) # 结果为 3</span><br></pre></td></tr></table></figure><h2 id="day-of-month"><a href="#day-of-month" class="headerlink" title="day_of_month()"></a>day_of_month()</h2><p><code>day_of_month(v=vector(time()) instant-vector)</code> 函数，返回被给定 UTC 时间所在月的第几天。返回值范围：1~31。</p><h2 id="day-of-week"><a href="#day-of-week" class="headerlink" title="day_of_week()"></a>day_of_week()</h2><p><code>day_of_week(v=vector(time()) instant-vector)</code> 函数，返回被给定 UTC 时间所在周的第几天。返回值范围：0~6，0 表示星期天。</p><h2 id="days-in-month"><a href="#days-in-month" class="headerlink" title="days_in_month()"></a>days_in_month()</h2><p><code>days_in_month(v=vector(time()) instant-vector)</code> 函数，返回当月一共有多少天。返回值范围：28~31。</p><h2 id="delta"><a href="#delta" class="headerlink" title="delta()"></a>delta()</h2><p><code>delta(v range-vector)</code> 的参数是一个区间向量，返回一个瞬时向量。它计算一个区间向量 v 的第一个元素和最后一个元素之间的差值。由于这个值被外推到指定的整个时间范围，所以即使样本值都是整数，你仍然可能会得到一个非整数值。</p><p>例如，下面的例子返回过去两小时的 CPU 温度差：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delta(cpu_temp_celsius&#123;host="zeus"&#125;[2h])</span><br></pre></td></tr></table></figure><p>这个函数一般只用在 Gauge 类型的时间序列上。</p><h2 id="deriv"><a href="#deriv" class="headerlink" title="deriv()"></a>deriv()</h2><p><code>deriv(v range-vector)</code> 的参数是一个区间向量,返回一个瞬时向量。它使用<a href="http://en.wikipedia.org/wiki/Simple_linear_regression" target="_blank" rel="external">简单的线性回归</a>计算区间向量 v 中各个时间序列的导数。</p><p>这个函数一般只用在 Gauge 类型的时间序列上。</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp()"></a>exp()</h2><p><code>exp(v instant-vector)</code> 函数，输入一个瞬时向量，返回各个样本值的 <code>e</code> 的指数值，即 e 的 N 次方。当 N 的值足够大时会返回 <code>+Inf</code>。特殊情况为：</p><ul><li><code>Exp(+Inf) = +Inf</code></li><li><code>Exp(NaN) = NaN</code></li></ul><h2 id="floor"><a href="#floor" class="headerlink" title="floor()"></a>floor()</h2><p><code>floor(v instant-vector)</code> 函数与 ceil() 函数相反，将 v 中所有元素的样本值向下四舍五入到最接近的整数。</p><h2 id="histogram-quantile"><a href="#histogram-quantile" class="headerlink" title="histogram_quantile()"></a>histogram_quantile()</h2><p><code>histogram_quantile(φ float, b instant-vector)</code> 从 bucket 类型的向量 <code>b</code> 中计算 φ (0 ≤ φ ≤ 1) 分位数（百分位数的一般形式）的样本的最大值。（有关 φ 分位数的详细说明以及直方图指标类型的使用，请参阅<a href="https://prometheus.io/docs/practices/histograms" target="_blank" rel="external">直方图和摘要</a>）。向量 <code>b</code> 中的样本是每个 bucket 的采样点数量。每个样本的 labels 中必须要有 <code>le</code> 这个 label 来表示每个 bucket 的上边界，没有 <code>le</code> 标签的样本会被忽略。直方图指标类型自动提供带有 <code>_bucket</code> 后缀和相应标签的时间序列。</p><p>可以使用 <code>rate()</code> 函数来指定分位数计算的时间窗口。</p><p>例如，一个直方图指标名称为 <code>employee_age_bucket_bucket</code>，要计算过去 10 分钟内 第 90 个百分位数，请使用以下表达式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">histogram_quantile(0.9, rate(employee_age_bucket_bucket[10m]))</span><br></pre></td></tr></table></figure><p>返回：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;instance="10.0.86.71:8080",job="prometheus"&#125; 35.714285714285715</span><br></pre></td></tr></table></figure><p>这表示最近 10 分钟之内 90% 的样本的最大值为 35.714285714285715。</p><p>这个计算结果是每组标签组合成一个时间序列。我们可能不会对所有这些维度（如 <code>job</code>、<code>instance</code> 和 <code>method</code>）感兴趣，并希望将其中的一些维度进行聚合，则可以使用 sum() 函数。例如，以下表达式根据 <code>job</code> 标签来对第 90 个百分位数进行聚合：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># histogram_quantile() 函数必须包含 le 标签</span><br><span class="line">histogram_quantile(0.9, sum(rate(employee_age_bucket_bucket[10m])) by (job, le))</span><br></pre></td></tr></table></figure><p>如果要聚合所有的标签，则使用如下表达式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">histogram_quantile(0.9,sum(rate(employee_age_bucket_bucket[10m])) by (le))</span><br></pre></td></tr></table></figure><blockquote><p><strong>[info] 注意</strong></p><p><code>histogram_quantile</code> 这个函数是根据假定每个区间内的样本分布是线性分布来计算结果值的(也就是说它的结果未必准确)，最高的 bucket 必须是 le=“+Inf” (否则就返回 NaN)。</p><p>如果分位数位于最高的 bucket（+Inf） 中，则返回第二个最高的 bucket 的上边界。如果该 bucket 的上边界大于 0，则假设最低的 bucket 的的下边界为 0，这种情况下在该 bucket 内使用常规的线性插值。</p><p>如果分位数位于最低的 bucket 中，则返回最低 bucket 的上边界。</p></blockquote><p>如果 b 含有少于 2 个 buckets，那么会返回 <code>NaN</code>，如果 φ &lt; 0 会返回 <code>-Inf</code>，如果 φ &gt; 1 会返回 <code>+Inf</code>。</p><h2 id="holt-winters"><a href="#holt-winters" class="headerlink" title="holt_winters()"></a>holt_winters()</h2><p><code>holt_winters(v range-vector, sf scalar, tf scalar)</code> 函数基于区间向量 v，生成时间序列数据平滑值。平滑因子 <code>sf</code> 越低, 对旧数据的重视程度越高。趋势因子 <code>tf</code> 越高，对数据的趋势的考虑就越多。其中，<code>0&lt; sf, tf &lt;=1</code>。</p><p>holt_winters 仅适用于 Gauge 类型的时间序列。</p><h2 id="hour"><a href="#hour" class="headerlink" title="hour()"></a>hour()</h2><p><code>hour(v=vector(time()) instant-vector)</code> 函数返回被给定 UTC 时间的当前第几个小时，时间范围：0~23。</p><h2 id="idelta"><a href="#idelta" class="headerlink" title="idelta()"></a>idelta()</h2><p>idelta(v range-vector) 的参数是一个区间向量, 返回一个瞬时向量。它计算最新的 2 个样本值之间的差值。</p><p>这个函数一般只用在 Gauge 类型的时间序列上。</p><h2 id="increase"><a href="#increase" class="headerlink" title="increase()"></a>increase()</h2><p><code>increase(v range-vector)</code> 函数获取区间向量中的第一个和最后一个样本并返回其增长量, 它会在单调性发生变化时(如由于采样目标重启引起的计数器复位)自动中断。由于这个值被外推到指定的整个时间范围，所以即使样本值都是整数，你仍然可能会得到一个非整数值。</p><p>例如，以下表达式返回区间向量中每个时间序列过去 5 分钟内 HTTP 请求数的增长数：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">increase(http_requests_total&#123;job="apiserver"&#125;[5m])</span><br></pre></td></tr></table></figure><p><code>increase</code> 的返回值类型只能是计数器类型，主要作用是增加图表和数据的可读性。使用 <code>rate</code> 函数记录规则的使用率，以便持续跟踪数据样本值的变化。</p><h2 id="irate"><a href="#irate" class="headerlink" title="irate()"></a>irate()</h2><p><code>irate(v range-vector)</code> 函数用于计算区间向量的增长率，但是其反应出的是瞬时增长率。irate 函数是通过区间向量中最后两个两本数据来计算区间向量的增长速率，它会在单调性发生变化时(如由于采样目标重启引起的计数器复位)自动中断。这种方式可以避免在时间窗口范围内的“长尾问题”，并且体现出更好的灵敏度，通过irate函数绘制的图标能够更好的反应样本数据的瞬时变化状态。</p><p>例如，以下表达式返回区间向量中每个时间序列过去 5 分钟内最后两个样本数据的 HTTP 请求数的增长率：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">irate(http_requests_total&#123;job="api-server"&#125;[5m])</span><br></pre></td></tr></table></figure><p>irate 只能用于绘制快速变化的计数器，在长期趋势分析或者告警中更推荐使用 rate 函数。因为使用 irate 函数时，速率的简短变化会重置 <code>FOR</code> 语句，形成的图形有很多波峰，难以阅读。</p><blockquote><p><strong>[info] 注意</strong></p><p>当将 <code>irate()</code> 函数与<a href="https://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators" target="_blank" rel="external">聚合运算符</a>（例如 <code>sum()</code>）或随时间聚合的函数（任何以 <code>_over_time</code> 结尾的函数）一起使用时，必须先执行 irate 函数，然后再进行聚合操作，否则当采样目标重新启动时 irate() 无法检测到计数器是否被重置。</p></blockquote><h2 id="label-join"><a href="#label-join" class="headerlink" title="label_join()"></a>label_join()</h2><p><code>label_join(v instant-vector, dst_label string, separator string, src_label_1 string, src_label_2 string, ...)</code> 函数可以将时间序列 v 中多个标签 <code>src_label</code> 的值，通过 <code>separator</code> 作为连接符写入到一个新的标签 <code>dst_label</code> 中。可以有多个 src_label 标签。</p><p>例如，以下表达式返回的时间序列多了一个 <code>foo</code> 标签，标签值为 <code>etcd,etcd-k8s</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">up&#123;endpoint="api",instance="192.168.123.248:2379",job="etcd",namespace="monitoring",service="etcd-k8s"&#125;=&gt; up&#123;endpoint="api",instance="192.168.123.248:2379",job="etcd",namespace="monitoring",service="etcd-k8s"&#125;  1</span><br><span class="line">label_join(up&#123;endpoint="api",instance="192.168.123.248:2379",job="etcd",namespace="monitoring",service="etcd-k8s"&#125;, "foo", ",", "job", "service")=&gt; up&#123;endpoint="api",foo="etcd,etcd-k8s",instance="192.168.123.248:2379",job="etcd",namespace="monitoring",service="etcd-k8s"&#125;  1</span><br></pre></td></tr></table></figure><h2 id="label-replace"><a href="#label-replace" class="headerlink" title="label_replace()"></a>label_replace()</h2><p>为了能够让客户端的图标更具有可读性，可以通过 <code>label_replace</code> 函数为时间序列添加额外的标签。label_replace 的具体参数如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label_replace(v instant-vector, dst_label string, replacement string, src_label string, regex string)</span><br></pre></td></tr></table></figure><p>该函数会依次对 v 中的每一条时间序列进行处理，通过 <code>regex</code> 匹配 src_label 的值，并将匹配部分 <code>relacement</code> 写入到 dst_label 标签中。如下所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label_replace(up, "host", "$1", "instance",  "(.*):.*")</span><br></pre></td></tr></table></figure><p>函数处理后，时间序列将包含一个 <code>host</code> 标签，host 标签的值为 Exporter 实例的 IP 地址：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">up&#123;host="localhost",instance="localhost:8080",job="cadvisor"&#125;   1</span><br><span class="line">up&#123;host="localhost",instance="localhost:9090",job="prometheus"&#125;   1</span><br><span class="line">up&#123;host="localhost",instance="localhost:9100",job="node"&#125;   1</span><br></pre></td></tr></table></figure><h2 id="ln"><a href="#ln" class="headerlink" title="ln()"></a>ln()</h2><p><code>ln(v instant-vector)</code> 计算瞬时向量 v 中所有样本数据的自然对数。特殊情况：</p><ul><li><code>ln(+Inf) = +Inf</code></li><li><code>ln(0) = -Inf</code></li><li><code>ln(x &lt; 0) = NaN</code></li><li><code>ln(NaN) = NaN</code></li></ul><h2 id="log2"><a href="#log2" class="headerlink" title="log2()"></a>log2()</h2><p><code>log2(v instant-vector)</code> 函数计算瞬时向量 v 中所有样本数据的二进制对数。特殊情况同上。</p><h2 id="log10"><a href="#log10" class="headerlink" title="log10()"></a>log10()</h2><p><code>log10(v instant-vector)</code> 计算瞬时向量 v 中所有样本数据的十进制对数。特殊情况同上。</p><h2 id="minute"><a href="#minute" class="headerlink" title="minute()"></a>minute()</h2><p><code>minute(v=vector(time()) instant-vector)</code> 函数返回给定 UTC 时间当前小时的第多少分钟。结果范围：0~59。</p><h2 id="month"><a href="#month" class="headerlink" title="month()"></a>month()</h2><p><code>month(v=vector(time()) instant-vector)</code> 函数返回给定 UTC 时间当前属于第几个月，结果范围：0~12。</p><h2 id="predict-linear"><a href="#predict-linear" class="headerlink" title="predict_linear()"></a>predict_linear()</h2><p><code>predict_linear(v range-vector, t scalar)</code> 函数可以预测时间序列 v 在 t 秒后的值。它基于简单线性回归的方式，对时间窗口内的样本数据进行统计，从而可以对时间序列的变化趋势做出预测。该函数的返回结果<strong>不带有度量指标</strong>，只有标签列表。</p><p>例如，基于 2 小时的样本数据，来预测主机可用磁盘空间的是否在 4 个小时候被占满，可以使用如下表达式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">predict_linear(node_filesystem_free&#123;job="node"&#125;[2h], 4 * 3600) <span class="tag">&lt; <span class="attr">0</span></span></span><br><span class="line"><span class="tag"><span class="attr">1.</span></span></span><br></pre></td></tr></table></figure><p>通过下面的例子来观察返回值：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">predict_linear(http_requests_total&#123;code="200",instance="120.77.65.193:9090",job="prometheus",method="get"&#125;[5m], 5)</span><br><span class="line">结果：</span><br><span class="line">&#123;code="200",handler="query_range",instance="120.77.65.193:9090",job="prometheus",method="get"&#125;  1</span><br><span class="line">&#123;code="200",handler="prometheus",instance="120.77.65.193:9090",job="prometheus",method="get"&#125;   4283.449995397104</span><br><span class="line">&#123;code="200",handler="static",instance="120.77.65.193:9090",job="prometheus",method="get"&#125;   22.99999999999999</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这个函数一般只用在 Gauge 类型的时间序列上。</p><h2 id="rate"><a href="#rate" class="headerlink" title="rate()"></a>rate()</h2><p><code>rate(v range-vector)</code> 函数可以直接计算区间向量 v 在时间窗口内平均增长速率，它会在单调性发生变化时(如由于采样目标重启引起的计数器复位)自动中断。该函数的返回结果<strong>不带有度量指标</strong>，只有标签列表。</p><p>例如，以下表达式返回区间向量中每个时间序列过去 5 分钟内 HTTP 请求数的每秒增长率：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rate(http_requests_total[5m])</span><br><span class="line">结果：</span><br><span class="line">&#123;code="200",handler="label_values",instance="120.77.65.193:9090",job="prometheus",method="get"&#125; 0</span><br><span class="line">&#123;code="200",handler="query_range",instance="120.77.65.193:9090",job="prometheus",method="get"&#125;  0</span><br><span class="line">&#123;code="200",handler="prometheus",instance="120.77.65.193:9090",job="prometheus",method="get"&#125;   0.2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>rate() 函数返回值类型只能用计数器，在长期趋势分析或者告警中推荐使用这个函数。</p><blockquote><p><strong>[info] 注意</strong></p><p>当将 <code>rate()</code> 函数与<a href="https://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators" target="_blank" rel="external">聚合运算符</a>（例如 <code>sum()</code>）或随时间聚合的函数（任何以 <code>_over_time</code> 结尾的函数）一起使用时，必须先执行 rate 函数，然后再进行聚合操作，否则当采样目标重新启动时 rate() 无法检测到计数器是否被重置。</p></blockquote><h2 id="resets"><a href="#resets" class="headerlink" title="resets()"></a>resets()</h2><p><code>resets(v range-vector)</code> 的参数是一个区间向量。对于每个时间序列，它都返回一个计数器重置的次数。两个连续样本之间的值的减少被认为是一次计数器重置。</p><p>这个函数一般只用在计数器类型的时间序列上。</p><h2 id="round"><a href="#round" class="headerlink" title="round()"></a>round()</h2><p><code>round(v instant-vector, to_nearest=1 scalar)</code> 函数与 <code>ceil</code> 和 <code>floor</code> 函数类似，返回向量中所有样本值的最接近的整数。<code>to_nearest</code> 参数是可选的,默认为 1,表示样本返回的是最接近 1 的整数倍的值。你也可以将该参数指定为任意值（也可以是小数），表示样本返回的是最接近它的整数倍的值。</p><h2 id="scalar"><a href="#scalar" class="headerlink" title="scalar()"></a>scalar()</h2><p><code>scalar(v instant-vector)</code> 函数的参数是一个单元素的瞬时向量,它返回其唯一的时间序列的值作为一个标量。如果度量指标的样本数量大于 1 或者等于 0, 则返回 <code>NaN</code>。</p><h2 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h2><p><code>sort(v instant-vector)</code> 函数对向量按元素的值进行升序排序，返回结果：key: value = 度量指标：样本值[升序排列]。</p><h2 id="sort-desc"><a href="#sort-desc" class="headerlink" title="sort_desc()"></a>sort_desc()</h2><p><code>sort(v instant-vector)</code> 函数对向量按元素的值进行降序排序，返回结果：key: value = 度量指标：样本值[降序排列]。</p><h2 id="sqrt"><a href="#sqrt" class="headerlink" title="sqrt()"></a>sqrt()</h2><p><code>sqrt(v instant-vector)</code> 函数计算向量 v 中所有元素的平方根。</p><h2 id="time"><a href="#time" class="headerlink" title="time()"></a>time()</h2><p><code>time()</code> 函数返回从 1970-01-01 到现在的秒数。注意：它不是直接返回当前时间，而是时间戳</p><h2 id="timestamp"><a href="#timestamp" class="headerlink" title="timestamp()"></a>timestamp()</h2><p><code>timestamp(v instant-vector)</code> 函数返回向量 v 中的每个样本的时间戳（从 1970-01-01 到现在的秒数）。</p><p>该函数从 Prometheus 2.0 版本开始引入。</p><h2 id="vector"><a href="#vector" class="headerlink" title="vector()"></a>vector()</h2><p><code>vector(s scalar)</code> 函数将标量 s 作为没有标签的向量返回，即返回结果为：key: value= {}, s。</p><h2 id="year"><a href="#year" class="headerlink" title="year()"></a>year()</h2><p><code>year(v=vector(time()) instant-vector)</code> 函数返回被给定 UTC 时间的当前年份。</p><h2 id="over-time"><a href="#over-time" class="headerlink" title="_over_time()"></a><code>_over_time()</code></h2><p>下面的函数列表允许传入一个区间向量，它们会聚合每个时间序列的范围，并返回一个瞬时向量：</p><ul><li><code>avg_over_time(range-vector)</code> : 区间向量内每个度量指标的平均值。</li><li><code>min_over_time(range-vector)</code> : 区间向量内每个度量指标的最小值。</li><li><code>max_over_time(range-vector)</code> : 区间向量内每个度量指标的最大值。</li><li><code>sum_over_time(range-vector)</code> : 区间向量内每个度量指标的求和。</li><li><code>count_over_time(range-vector)</code> : 区间向量内每个度量指标的样本数据个数。</li><li><code>quantile_over_time(scalar, range-vector)</code> : 区间向量内每个度量指标的样本数据值分位数，φ-quantile (0 ≤ φ ≤ 1)。</li><li><code>stddev_over_time(range-vector)</code> : 区间向量内每个度量指标的总体标准差。</li><li><code>stdvar_over_time(range-vector)</code> : 区间向量内每个度量指标的总体标准方差。</li></ul><blockquote><p><strong>[info] 注意</strong></p><p>即使区间向量内的值分布不均匀，它们在聚合时的权重也是相同的。</p></blockquote><p>原文： <a href="https://blog.51cto.com/wzlinux/2490670" target="_blank" rel="external">https://blog.51cto.com/wzlinux/2490670</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p id=&quot;div-border-top-green&quot;&gt;改变，永远不嫌晚。无论你是几岁，也无论你目前所处的境况有多糟，只要立定目标、一步一步往前走，人生随时都有翻盘的可能性。&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Prometheus 提供了其它大量的内置函数，可以对时序数据进行丰富的处理。某些函数有默认的参数，例如：&lt;code&gt;year(v=vector(time()) instant-vector)&lt;/code&gt;。其中参数 &lt;code&gt;v&lt;/code&gt; 是一个瞬时向量，如果不提供该参数，将使用默认值 &lt;code&gt;vector(time())&lt;/code&gt;。instant-vector 表示参数类型。&lt;/p&gt;
&lt;h2 id=&quot;abs&quot;&gt;&lt;a href=&quot;#abs&quot; class=&quot;headerlink&quot; title=&quot;abs()&quot;&gt;&lt;/a&gt;abs()&lt;/h2&gt;&lt;p&gt;&lt;code&gt;abs(v instant-vector)&lt;/code&gt; 返回输入向量的所有样本的绝对值。&lt;/p&gt;
&lt;h2 id=&quot;absent&quot;&gt;&lt;a href=&quot;#absent&quot; class=&quot;headerlink&quot; title=&quot;absent()&quot;&gt;&lt;/a&gt;absent()&lt;/h2&gt;&lt;p&gt;&lt;code&gt;absent(v instant-vector)&lt;/code&gt;，如果传递给它的向量参数具有样本数据，则返回空向量；如果传递的向量参数没有样本数据，则返回不带度量指标名称且带有标签的时间序列，且样本值为1。&lt;/p&gt;
&lt;p&gt;当监控度量指标时，如果获取到的样本数据是空的， 使用 absent 方法对告警是非常有用的。例如：&lt;/p&gt;
    
    </summary>
    
      <category term="Prometheus" scheme="https://magiceses.github.io/categories/Prometheus/"/>
    
    
      <category term="Prometheus" scheme="https://magiceses.github.io/tags/Prometheus/"/>
    
  </entry>
  
  <entry>
    <title>Prometheus 告警规则生成和发送分析</title>
    <link href="https://magiceses.github.io/2020/10/06/prometheus-prometheus-5-%E5%91%8A%E8%AD%A6%E8%A7%84%E5%88%99%E7%94%9F%E6%88%90%E5%92%8C%E5%8F%91%E9%80%81%E5%88%86%E6%9E%90/"/>
    <id>https://magiceses.github.io/2020/10/06/prometheus-prometheus-5-告警规则生成和发送分析/</id>
    <published>2020-10-06T03:54:55.000Z</published>
    <updated>2021-10-11T06:58:01.222Z</updated>
    
    <content type="html"><![CDATA[<p id="div-border-top-green">每个人真正强大起来都要度过一段没人帮忙，没人支持的日子。所有事情都是自己一个人撑，所有情绪都是只有自己知道。但只要咬牙撑过去，一切都不一样了。<br></p><h1 id="rules-配置和使用"><a href="#rules-配置和使用" class="headerlink" title="rules 配置和使用"></a>rules 配置和使用</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>prometheus不仅可以提供数据采集功能，而且还可以做告警服务，通过匹配的性能参数，发出告警；然后把产生的警报发给Alertmanager进行处理。</p><p>但是这需要在Prometheus使用的配置文件中添加关联Alertmanager的组件的对应配置信息</p><a id="more"></a><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">alerting:</span></span><br><span class="line"><span class="attr">  alert_relabel_configs:</span></span><br><span class="line">    <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;relabel_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"><span class="attr">  alertmanagers:</span></span><br><span class="line">    <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;alertmanager_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"><span class="comment"># alertmanagers 为 alertmanager_config 数组，</span></span><br></pre></td></tr></table></figure><p>配置范例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">alerting:</span></span><br><span class="line"><span class="attr">  alert_relabel_configs:</span> <span class="comment"># 动态修改 alert 属性的规则配置。</span></span><br><span class="line"><span class="attr">    - source_labels:</span> <span class="string">[dc]</span> </span><br><span class="line"><span class="attr">      regex:</span> <span class="string">(.+)\d+</span></span><br><span class="line"><span class="attr">      target_label:</span> <span class="string">dc1</span></span><br><span class="line"><span class="attr">  alertmanagers:</span></span><br><span class="line"><span class="attr">    - static_configs:</span></span><br><span class="line"><span class="attr">        - targets:</span> <span class="string">['127.0.0.1:9093']</span> <span class="comment"># 单实例配置</span></span><br><span class="line">        <span class="comment">#- targets: ['172.31.10.167:19093','172.31.10.167:29093','172.31.10.167:39093'] # 集群配置</span></span><br><span class="line"><span class="attr">  - job_name:</span> <span class="string">'Alertmanager'</span></span><br><span class="line">    <span class="comment"># metrics_path defaults to '/metrics'</span></span><br><span class="line">    <span class="comment"># scheme defaults to 'http'.</span></span><br><span class="line"><span class="attr">    static_configs:</span></span><br><span class="line"><span class="attr">    - targets:</span> <span class="string">['localhost:19093']</span></span><br></pre></td></tr></table></figure><p>上面的配置中的 <code>alert_relabel_configs</code>是指警报重新标记在发送到Alertmanager之前应用于警报。 它具有与目标重新标记相同的配置格式和操作，外部标签标记后应用警报重新标记，主要是针对集群配置。</p><p>这个设置的用途是确保具有不同外部label的HA对Prometheus服务端发送相同的警报信息。</p><p>Alertmanager 可以通过 <code>static_configs</code> 参数静态配置，也可以使用其中一种支持的服务发现机制动态发现，我们上面的配置是静态的单实例，针对集群HA配置，后面会讲。</p><p>此外，<code>relabel_configs</code> 允许从发现的实体中选择 Alertmanager，并对使用的API路径提供高级修改，该路径通过 <code>__alerts_path__</code> 标签公开。</p><p>完成以上配置后，重启Prometheus服务，用以加载生效，也可以使用前文说过的热加载功能，使其配置生效。然后通过浏览器，访问 <a href="https://links.jianshu.com/go?to=http%3A%2F%2F192.168.1.220%3A19090%2Falerts" target="_blank" rel="external">http://192.168.1.220:19090/alerts</a> 就可以看 <code>inactive</code> <code>pending</code> <code>firing</code> 三个状态，没有警报信息是因为我们还没有配置警报规则 <code>rules</code>。</p><h2 id="告警规则"><a href="#告警规则" class="headerlink" title="告警规则"></a>告警规则</h2><p>警报规则 <code>rules</code> 使用的是 yaml 格式进行定义，在Prometheus中通过我们前面讲过的 <code>PromQL</code> 配置实际警报触发条件，Prometheus 会根据设置的警告规则 <code>Ruels</code> 以及配置间隔时间进行周期性计算，当满足触发条件规则会发送警报通知。</p><p>警报规则加载的是在 <code>prometheus.yml</code> 文件中进行配置，默认的警报规则进行周期运行计算的时间是1分钟，可以使用 <code>global</code> 中的 <code>evaluation_interval</code> 来决定时间间隔。</p><p>样例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line"><span class="attr">    evaluation_interval:</span> <span class="number">15</span><span class="string">s</span></span><br></pre></td></tr></table></figure><p>警报规则可以指定多个文件，也可以自定到自定义的目录下面，为了管理更为便捷，方便阅读，可以把警报规则拆成多份，用以区分环境，系统，服务等，如：prod，test，dev 等等，并且支持以正则表达式定义。</p><p>样例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rule_files:</span></span><br><span class="line">    <span class="comment">#- "/data/prometheus/rules/*.yml" # 正则表达式，会加在此目录下所有警报规则配置文件</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"/data/prometheus/rules/ops.yml"</span> <span class="comment"># 仅加载ops.yml警报规则文件</span></span><br><span class="line">    <span class="comment">#- "/data/prometheus/rules/prod-*.yml" </span></span><br><span class="line">    <span class="comment">#- "/data/prometheus/rules/test-*.yml"</span></span><br><span class="line">    <span class="comment">#- "/data/prometheus/rules/dev-*.yml"</span></span><br></pre></td></tr></table></figure><p>现在开始讲警报规则 <code>Rules</code> 的定义，格式为YAML。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">groups:</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line"><span class="attr">  - alert:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line"><span class="attr">    expr:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line"><span class="attr">    for:</span>  <span class="string">[</span> <span class="string">&lt;duration&gt;</span> <span class="string">| default 0 ]</span></span><br><span class="line"><span class="string"></span><span class="attr">    labels:</span></span><br><span class="line">      <span class="string">[</span> <span class="string">&lt;lable_name&gt;:</span> <span class="string">&lt;label_value&gt;</span> <span class="string">]</span></span><br><span class="line"><span class="attr">    annotations:</span></span><br><span class="line">      <span class="string">[</span> <span class="string">&lt;lable_name&gt;:</span> <span class="string">&lt;tmpl_string&gt;</span> <span class="string">]</span></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>- name: &lt;string&gt;</code></td><td style="text-align:center">警报规则组的名称</td></tr><tr><td style="text-align:center"><code>- alert: &lt;string&gt;</code></td><td style="text-align:center">警报规则的名称</td></tr><tr><td style="text-align:center"><code>expr: &lt;string</code></td><td style="text-align:center">使用PromQL表达式完成的警报触发条件，用于计算是否有满足触发条件</td></tr><tr><td style="text-align:center"><code>&lt;lable_name&gt;: &lt;label_value&gt;</code></td><td style="text-align:center">自定义标签，允许自行定义标签附加在警报上，比如<code>high</code> <code>warning</code></td></tr><tr><td style="text-align:center"><code>annotations: &lt;lable_name&gt;: &lt;tmpl_string&gt;</code></td><td style="text-align:center">用来设置有关警报的一组描述信息，其中包括自定义的标签，以及expr计算后的值。</td></tr></tbody></table><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">groups:</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">operations</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line"><span class="attr">  - alert:</span> <span class="string">node-down</span></span><br><span class="line"><span class="attr">    expr:</span> <span class="string">up&#123;env="operations"&#125;</span> <span class="string">!=</span> <span class="number">1</span></span><br><span class="line"><span class="attr">    for:</span> <span class="number">5</span><span class="string">m</span></span><br><span class="line"><span class="attr">    labels:</span></span><br><span class="line"><span class="attr">      status:</span> <span class="string">High</span></span><br><span class="line"><span class="attr">      team:</span> <span class="string">operations</span></span><br><span class="line"><span class="attr">    annotations:</span></span><br><span class="line"><span class="attr">      description:</span> <span class="string">"Environment: <span class="template-variable">&#123;&#123; $labels.env &#125;&#125;</span> Instance: <span class="template-variable">&#123;&#123; $labels.instance &#125;&#125;</span> is Down ! ! !"</span></span><br><span class="line"><span class="attr">      value:</span> <span class="string">'<span class="template-variable">&#123;&#123; $value &#125;&#125;</span>'</span></span><br><span class="line"><span class="attr">      summary:</span>  <span class="string">"The host node was down 20 minutes ago"</span></span><br></pre></td></tr></table></figure><p>以上就是一个完整 <code>Rules</code> 的配置，如果Prometheus 在周期检测中使用PromQ以<code>env=operations</code>为维度查询，如果当前查询结果中具有标签<code>operations</code>，且返回值都不等于1的时候，发送警报。<br>对于写好的 <code>Rules</code> 可以是常用 <code>promtool</code> 来<code>check ruls.yml</code>的书写格式是否正确。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/bin/promtool check rules /data/prometheus/rules/ops.yml</span><br><span class="line">Checking /data/prometheus/rules/ops.yml</span><br><span class="line">  SUCCESS: 7 rules found</span><br></pre></td></tr></table></figure><p>对于修改好的rules文件，保存以后，经过检测没有问题，直接重新热加载 Prometheus就可以在页面看到了。对于触发警报规则，比较简单了，直接修改运算值或者去停掉 node-exporter 服务，便可在界面看到警报信息。一个警报在生命周期会有三种状态</p><table><thead><tr><th style="text-align:center">状态</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>Inactive</code></td><td style="text-align:center">正常状态，未激活警报</td></tr><tr><td style="text-align:center"><code>Pending</code></td><td style="text-align:center">已满足触发条件，但没有满足发送时间条件，此条件就是上面rules范例中的 <code>for 5m</code> 子句中定义的持续时间</td></tr><tr><td style="text-align:center"><code>Firing</code></td><td style="text-align:center">满足条件，且超过了 for 子句中的的指定持续时间5m</td></tr></tbody></table><p>带有for子句的警报触发以后首先会先转换成 <code>Pending</code> 状态，然后在转换为 <code>Firing</code> 状态。这里需要俩个周期才能触发警报条件，如果没有设置 <code>for</code> 子句，会直接 <code>Inactive</code> 状态转换成 <code>Firing状态</code>，然后触发警报，发送给 <code>Receiver</code> 设置的通知人。</p><p>在运行过程中，Prometheus会把Pending或Firing状态的每一个警报创建一个 <code>Alerts</code>指标名称，这个可以通过Rules来触发警报测试，直接在UI中Graph查看指标 <code>ALERTS</code>，格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALERTS&#123;alertname=&quot;alert name&quot;,alertstate=&quot;pending|firing&quot;,&lt;additional alert label&gt;&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/prometheus-prometheus-16.png" alt="img"></p><p>当警报处于激活状态 <code>Pending</code> 或者 <code>Firing</code>时候，如上图所示，样本值为1。其他状态为0。则不显示。上图已经触发警报，其警报已经被转发给Alertmanager组件，此时可以在浏览器上通过可以用过9093端口访问，查看警报状态。</p><p><img src="/images/prometheus-prometheus-17.png" alt="img"></p><p>现在我们来说一下整理下Prometheus从收集监控指标信息到触发警报的过程：</p><table><thead><tr><th style="text-align:center">状态</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>1.定义规则</code></td><td style="text-align:center">在Prometheus配置中，scrape_interval: 15s，默认是1分钟，这个定义是收集监控指标信息的采集周期，同时配置对应的警报规则，可以是全局，也可以单独为某一个metrics定义</td></tr><tr><td style="text-align:center"><code>2.周期计算</code></td><td style="text-align:center">对于表达式进行计算时，Prometheus中的配置中配置了 evaluation_interval: 15s，默认也是一分钟，为警报规则的计算周期，<code>evaluation_interval</code> 只是全局计算周期值。</td></tr><tr><td style="text-align:center"><code>3.1警报状态转换(pending)</code></td><td style="text-align:center">当首次触发警报规则条件成立，表达式为 <code>true</code>，并且没有满足警报规则中的for子句中的持续时间时，警报状态切换为 <code>Pending</code></td></tr><tr><td style="text-align:center"><code>3.2警报状态转换(firing)</code></td><td style="text-align:center">若下一个计算周期中，表达式仍为 <code>true</code>，并且满足警报规则中的for子句的持续时间时，警报状态转换为 <code>Firing</code>，即为 <code>active</code>，警报会被Prometheus推送到ALertmanager组件</td></tr><tr><td style="text-align:center"><code>3.3警报状态转换(period)</code></td><td style="text-align:center">如果在 <code>evaluation_interval</code> 的计算周期内，表达式还是为 <code>true</code>，同时满足 for子句的持续时间，持续转发到Alertmanager，这里只是转发状态到Alertmanager，并不是直接发送通知到指定通知源</td></tr><tr><td style="text-align:center"><code>3.4警报状态转换(resolve)</code></td><td style="text-align:center">只到某个周期，表达式 为 <code>false</code>，警报状态会变成 <code>inactive</code> ，并且会有一个 <code>resolve</code> 被发送到Alertmanager，用于说明警报故障依解决，发送resolve信息需要自己单独在Alertmanager中定义</td></tr></tbody></table><h2 id="Rules-类型"><a href="#Rules-类型" class="headerlink" title="Rules 类型"></a>Rules 类型</h2><p>Prometheus 支持两种类型的 <code>Rules</code> ，可以对其进行配置，然后定期进行运算：<code>recording rules</code> 记录规则 与 <code>alerting rules</code> 警报规则，规则文件的计算频率与警报规则计算频率一致，都是通过全局配置中的 <code>evaluation_interval</code> 定义。</p><h3 id="alerting-rules"><a href="#alerting-rules" class="headerlink" title="alerting rules"></a>alerting rules</h3><p>要在Prometheus中使用Rules规则，就必须创建一个包含必要规则语句的文件，并让Prometheus通过Prometheus配置中的rule_files字段加载该文件，前面我们已经讲过了。</p><p>其实语法都一样，除了 <code>recording rules</code> 中的收集的指标名称 <code>record: &lt;string&gt;</code> 字段配置方式略有不同，其他都是一样的。</p><p>样例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- alert:</span> <span class="string">ServiceDown</span></span><br><span class="line"><span class="attr">    expr:</span> <span class="string">avg_over_time(up[5m])</span> <span class="string">*</span> <span class="number">100</span> <span class="string">&lt;</span> <span class="number">50</span></span><br><span class="line"><span class="attr">    annotations:</span></span><br><span class="line"><span class="attr">      description:</span> <span class="string">The</span> <span class="string">service</span> <span class="string">&#123;&#123;</span> <span class="string">$labels.job</span> <span class="string">&#125;&#125;</span> <span class="string">instance</span> <span class="string">&#123;&#123;</span> <span class="string">$labels.instance</span> <span class="string">&#125;&#125;</span> <span class="string">is</span></span><br><span class="line">        <span class="string">not</span> <span class="string">responding</span> <span class="string">for</span> <span class="string">more</span> <span class="string">than</span> <span class="number">50</span><span class="string">%</span> <span class="string">of</span> <span class="string">the</span> <span class="string">time</span> <span class="string">for</span> <span class="number">5</span> <span class="string">minutes.</span></span><br><span class="line"><span class="attr">      summary:</span> <span class="string">The</span> <span class="string">service</span> <span class="string">&#123;&#123;</span> <span class="string">$labels.job</span> <span class="string">&#125;&#125;</span> <span class="string">is</span> <span class="string">not</span> <span class="string">responding</span></span><br><span class="line"><span class="attr">  - alert:</span> <span class="string">RedisDown</span></span><br><span class="line"><span class="attr">    expr:</span> <span class="string">avg_over_time(redis_up[5m])</span> <span class="string">*</span> <span class="number">100</span> <span class="string">&lt;</span> <span class="number">50</span></span><br><span class="line"><span class="attr">    annotations:</span></span><br><span class="line"><span class="attr">      description:</span> <span class="string">The</span> <span class="string">Redis</span> <span class="string">service</span> <span class="string">&#123;&#123;</span> <span class="string">$labels.job</span> <span class="string">&#125;&#125;</span> <span class="string">instance</span> <span class="string">&#123;&#123;</span> <span class="string">$labels.instance</span></span><br><span class="line">        <span class="string">&#125;&#125;</span> <span class="string">is</span> <span class="string">not</span> <span class="string">responding</span> <span class="string">for</span> <span class="string">more</span> <span class="string">than</span> <span class="number">50</span><span class="string">%</span> <span class="string">of</span> <span class="string">the</span> <span class="string">time</span> <span class="string">for</span> <span class="number">5</span> <span class="string">minutes.</span></span><br><span class="line"><span class="attr">      summary:</span> <span class="string">The</span> <span class="string">Redis</span> <span class="string">service</span> <span class="string">&#123;&#123;</span> <span class="string">$labels.job</span> <span class="string">&#125;&#125;</span> <span class="string">is</span> <span class="string">not</span> <span class="string">responding</span></span><br><span class="line"><span class="attr">  - alert:</span> <span class="string">PostgresDown</span></span><br><span class="line"><span class="attr">    expr:</span> <span class="string">avg_over_time(pg_up[5m])</span> <span class="string">*</span> <span class="number">100</span> <span class="string">&lt;</span> <span class="number">50</span></span><br><span class="line"><span class="attr">    annotations:</span></span><br><span class="line"><span class="attr">      description:</span> <span class="string">The</span> <span class="string">Postgres</span> <span class="string">service</span> <span class="string">&#123;&#123;</span> <span class="string">$labels.job</span> <span class="string">&#125;&#125;</span> <span class="string">instance</span> <span class="string">&#123;&#123;</span> <span class="string">$labels.instance</span></span><br><span class="line">        <span class="string">&#125;&#125;</span> <span class="string">is</span> <span class="string">not</span> <span class="string">responding</span> <span class="string">for</span> <span class="string">more</span> <span class="string">than</span> <span class="number">50</span><span class="string">%</span> <span class="string">of</span> <span class="string">the</span> <span class="string">time</span> <span class="string">for</span> <span class="number">5</span> <span class="string">minutes.</span></span><br><span class="line"><span class="attr">      summary:</span> <span class="string">The</span> <span class="string">Postgres</span> <span class="string">service</span> <span class="string">&#123;&#123;</span> <span class="string">$labels.job</span> <span class="string">&#125;&#125;</span> <span class="string">is</span> <span class="string">not</span> <span class="string">responding</span></span><br></pre></td></tr></table></figure><h3 id="recording-rules"><a href="#recording-rules" class="headerlink" title="recording rules"></a>recording rules</h3><p><code>recording rules</code> 是提前设置好一个比较花费大量时间运算或经常运算的表达式，其结果保存成一组新的时间序列数据。当需要查询的时候直接会返回已经计算好的结果，这样会比直接查询快，同时也减轻了PromQl的计算压力，同时对可视化查询的时候也很有用，可视化展示每次只需要刷新重复查询相同的表达式即可。</p><p>在配置的时候，除却 <code>record: &lt;string&gt;</code> 需要注意，其他的基本上是一样的，一个 <code>groups</code> 下可以包含多条规则 <code>rules</code> ，<code>Recording</code> 和 <code>Rules</code> 保存在 <code>group</code> 内，<code>Group</code> 中的规则以规则的配置时间间隔顺序运算，也就是全局中的 <code>evaluation_interval</code> 设置。</p><p>样例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">groups:</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">http_requests_total</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line"><span class="attr">  - record:</span> <span class="attr">job:http_requests_total:rate10m</span></span><br><span class="line"><span class="attr">    expr:</span> <span class="string">sum</span> <span class="string">by</span> <span class="string">(job)(rate(http_requests_total[10m]))</span></span><br><span class="line"><span class="attr">    lables:</span></span><br><span class="line"><span class="attr">      team:</span> <span class="string">operations</span></span><br><span class="line"><span class="attr">  - record:</span> <span class="attr">job:http_requests_total:rate30m</span></span><br><span class="line"><span class="attr">    expr:</span> <span class="string">sum</span> <span class="string">by</span> <span class="string">(job)(rate(http_requests_total[30m]))</span></span><br><span class="line"><span class="attr">    lables:</span></span><br><span class="line"><span class="attr">      team:</span> <span class="string">operations</span></span><br></pre></td></tr></table></figure><p>上面的规则其实就是根据 <code>record</code> 规则中的定义，Prometheus 会在后台完成 <code>expr</code> 中定义的 PromQL 表达式周期性运算，以 <code>job</code> 为维度使用 <code>sum</code> 聚合运算符 计算 函数<code>rate</code> 对<code>http_requests_total</code> 指标区间 <code>10m</code> 内的增长率，并且将计算结果保存到新的时间序列 <code>job:http_requests_total:rate10m</code> 中，</p><p>同时还可以通过 <code>labels</code> 为样本数据添加额外的自定义标签，但是要注意的是这个 <code>Lables</code> 一定存在当前表达式 <code>Metrics</code> 中。</p><h2 id="使用模板"><a href="#使用模板" class="headerlink" title="使用模板"></a>使用模板</h2><p>模板是在警报中使用时间序列标签和值展示的一种方法，可以用于警报规则中的注释（annotation）与标签（lable）。模板其实使用的go语言的标准模板语法，并公开一些包含时间序列标签和值的变量。这样查询的时候，更具有可读性，也可以执行其他PromQL查询来向警报添加额外内容，ALertmanager Web UI中会根据标签值显示器警报信息。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#123;&#123;</span> <span class="string">$lable.&lt;lablename&gt;&#125;&#125;</span> <span class="string">可以获取当前警报实例中的指定标签值</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#123;&#123;</span> <span class="string">$value</span> <span class="string">&#125;&#125;</span> <span class="string">变量可以获取当前PromQL表达式的计算样本值。</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">groups:</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">operations</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line"><span class="comment"># monitor node memory usage</span></span><br><span class="line"><span class="attr">  - alert:</span> <span class="string">node-memory-usage</span></span><br><span class="line"><span class="attr">    expr:</span> <span class="string">(1</span> <span class="bullet">-</span> <span class="string">(node_memory_MemAvailable_bytes&#123;env="operations",job!='atlassian'&#125;</span> <span class="string">/</span> <span class="string">(node_memory_MemTotal_bytes&#123;env="operations"&#125;)))*</span> <span class="number">100</span> <span class="string">&gt; 90</span></span><br><span class="line"><span class="string"></span><span class="attr">    for:</span> <span class="number">1</span><span class="string">m</span></span><br><span class="line"><span class="attr">    labels:</span></span><br><span class="line"><span class="attr">      status:</span> <span class="string">Warning</span></span><br><span class="line"><span class="attr">      team:</span> <span class="string">operations</span></span><br><span class="line"><span class="attr">    annotations:</span></span><br><span class="line"><span class="attr">      description:</span> <span class="string">"Environment: <span class="template-variable">&#123;&#123; $labels.env &#125;&#125;</span> Instance: <span class="template-variable">&#123;&#123; $labels.instance &#125;&#125;</span> memory usage above <span class="template-variable">&#123;&#123; $value &#125;&#125;</span> ! ! !"</span></span><br><span class="line"><span class="attr">      summary:</span>  <span class="string">"node os memory usage status"</span></span><br></pre></td></tr></table></figure><p>调整好rules以后，我们可以使用 <code>curl -XPOST http://localhost:9090/-/reload</code> 或者 对Prometheus服务重启，让警报规则生效。</p><p>这个时候，我们可以把阈值调整为 <code>50</code> 来进行故障模拟操作，这时在去访问UI的时候，当持续1分钟满足警报条件，实际警报状态已转换为 <code>Firing</code>，可以在 Annotations中看到模板信息 <code>summary</code> 与 <code>description</code> 已经成功显示。</p><p><img src="/images/prometheus-prometheus-18.png" alt="img"></p><p>需要注意的是，一个稳定健壮的Prometheus监控系统中，要尽量使用模板化，这样会降低性能开销（Debug调试信息等），同时也易于维护。</p><p><strong>下面网站收录了当前大部分的rules规则，大家可以对应自己的环境，配置相关服务的Rules。</strong></p><p>Prometheus警报规则收集(<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fawesome-prometheus-alerts.grep.to%2F" target="_blank" rel="external">https://awesome-prometheus-alerts.grep.to/</a>)</p><h1 id="rules-源码分析"><a href="#rules-源码分析" class="headerlink" title="rules 源码分析"></a>rules 源码分析</h1><p>入口还是在 prometheus 的 <code>main.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// notifier 是用于向 alertmanager 发送告警的</span></span><br><span class="line">notifierManager = notifier.NewManager(&amp;cfg.notifier, log.With(logger, <span class="string">"component"</span>, <span class="string">"notifier"</span>))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明 ruleManager</span></span><br><span class="line">ruleManager = rules.NewManager(&amp;rules.ManagerOptions&#123;</span><br><span class="line">Appendable:      fanoutStorage,</span><br><span class="line">Queryable:       localStorage,</span><br><span class="line">QueryFunc:       rules.EngineQueryFunc(queryEngine, fanoutStorage),</span><br><span class="line"><span class="comment">// 若触发告警规则,则通过sendAlerts发送告警信息</span></span><br><span class="line">NotifyFunc:      sendAlerts(notifierManager, cfg.web.ExternalURL.String()),</span><br><span class="line">Context:         ctxRule,</span><br><span class="line">ExternalURL:     cfg.web.ExternalURL,</span><br><span class="line">Registerer:      prometheus.DefaultRegisterer,</span><br><span class="line">Logger:          log.With(logger, <span class="string">"component"</span>, <span class="string">"rule manager"</span>),</span><br><span class="line">OutageTolerance: time.Duration(cfg.outageTolerance),</span><br><span class="line">ForGracePeriod:  time.Duration(cfg.forGracePeriod),</span><br><span class="line">ResendDelay:     time.Duration(cfg.resendDelay),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>主要看下这里两个 <code>manager</code> 的初始化，<code>ruleManager</code> 主要是根据定义的告警规则进行定时的计算，<code>notifierManager</code> 主要是在生成告警之后会告警的内容进行发送，与 <code>alertmanager</code> 进行交互，将告警信息交给 <code>alertmanager</code> 进行处理之后再根据配置的发送方式，将内容发送给 <code>receivers</code>。下面分别看下：</p><h2 id="ruleManager"><a href="#ruleManager" class="headerlink" title="ruleManager"></a>ruleManager</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">name: <span class="string">"rules"</span>,</span><br><span class="line">reloader: <span class="function"><span class="keyword">func</span><span class="params">(cfg *config.Config)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// Get all rule files matching the configuration paths.</span></span><br><span class="line"><span class="keyword">var</span> files []<span class="keyword">string</span></span><br><span class="line"><span class="comment">// 列出配置的所有rules文件,比如 /tmp/*.rules</span></span><br><span class="line"><span class="keyword">for</span> _, pat := <span class="keyword">range</span> cfg.RuleFiles &#123;</span><br><span class="line">fs, err := filepath.Glob(pat)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// The only error can be a bad pattern.</span></span><br><span class="line"><span class="keyword">return</span> errors.Wrapf(err, <span class="string">"error retrieving rule files for %s"</span>, pat)</span><br><span class="line">&#125;</span><br><span class="line">files = <span class="built_in">append</span>(files, fs...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// files["/tmp/kubelet.rules","nodes.rules"]</span></span><br><span class="line"><span class="keyword">return</span> ruleManager.Update(</span><br><span class="line">time.Duration(cfg.GlobalConfig.EvaluationInterval),</span><br><span class="line">files,</span><br><span class="line">cfg.GlobalConfig.ExternalLabels,</span><br><span class="line">)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>遍历配置的苏欧欧 <code>rules</code> 文件，进行解析，并将其加入 <code>files</code> 切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Update the rule manager's state as the config requires. If</span></span><br><span class="line"><span class="comment">// loading the new rules failed the old rule set is restored.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Manager)</span> <span class="title">Update</span><span class="params">(interval time.Duration, files []<span class="keyword">string</span>, externalLabels labels.Labels)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">m.mtx.Lock()</span><br><span class="line"><span class="keyword">defer</span> m.mtx.Unlock()</span><br><span class="line"></span><br><span class="line">groups, errs := m.LoadGroups(interval, externalLabels, files...)</span><br><span class="line"><span class="keyword">if</span> errs != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, e := <span class="keyword">range</span> errs &#123;</span><br><span class="line">level.Error(m.logger).Log(<span class="string">"msg"</span>, <span class="string">"loading groups failed"</span>, <span class="string">"err"</span>, e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">"error loading rules, previous rule set restored"</span>)</span><br><span class="line">&#125;</span><br><span class="line">m.restored = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> _, newg := <span class="keyword">range</span> groups &#123;</span><br><span class="line"><span class="comment">// If there is an old group with the same identifier,</span></span><br><span class="line"><span class="comment">// check if new group equals with the old group, if yes then skip it.</span></span><br><span class="line"><span class="comment">// If not equals, stop it and wait for it to finish the current iteration.</span></span><br><span class="line"><span class="comment">// Then copy it into the new group.</span></span><br><span class="line">gn := GroupKey(newg.file, newg.name)</span><br><span class="line">oldg, ok := m.groups[gn]</span><br><span class="line"><span class="built_in">delete</span>(m.groups, gn)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ok &amp;&amp; oldg.Equals(newg) &#123;</span><br><span class="line">groups[gn] = oldg</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 每一个 group 开一个协程去 run</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(newg *Group)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">oldg.stop()</span><br><span class="line">newg.CopyState(oldg)</span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line"><span class="comment">// Wait with starting evaluation until the rule manager</span></span><br><span class="line"><span class="comment">// is told to run. This is necessary to avoid running</span></span><br><span class="line"><span class="comment">// queries against a bootstrapping storage.</span></span><br><span class="line">&lt;-m.block</span><br><span class="line">newg.run(m.opts.Context)</span><br><span class="line">&#125;(newg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stop remaining old groups.</span></span><br><span class="line">wg.Add(<span class="built_in">len</span>(m.groups))</span><br><span class="line"><span class="keyword">for</span> n, oldg := <span class="keyword">range</span> m.groups &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">string</span>, g *Group)</span></span> &#123;</span><br><span class="line">g.markStale = <span class="literal">true</span></span><br><span class="line">g.stop()</span><br><span class="line"><span class="keyword">if</span> m := g.metrics; m != <span class="literal">nil</span> &#123;</span><br><span class="line">m.IterationsMissed.DeleteLabelValues(n)</span><br><span class="line">m.IterationsScheduled.DeleteLabelValues(n)</span><br><span class="line">m.EvalTotal.DeleteLabelValues(n)</span><br><span class="line">m.EvalFailures.DeleteLabelValues(n)</span><br><span class="line">m.GroupInterval.DeleteLabelValues(n)</span><br><span class="line">m.GroupLastEvalTime.DeleteLabelValues(n)</span><br><span class="line">m.GroupLastDuration.DeleteLabelValues(n)</span><br><span class="line">m.GroupRules.DeleteLabelValues(n)</span><br><span class="line">m.GroupSamples.DeleteLabelValues((n))</span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;(n, oldg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">m.groups = groups</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合上面的初始化看，到这里为止主要做了如下几件事情：</p><ol><li>列出配置的所有rules文件</li><li>解析rules文件</li><li>按groupName分组</li><li>group.Run()，此处会启动定时任务，按照配置的频率evaluation_interval执行告警或者汇总规则</li></ol><p>看下 <code>run</code> 方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">run</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(g.terminated)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait an initial amount to have consistently slotted intervals.</span></span><br><span class="line">evalTimestamp := g.EvalTimestamp(time.Now().UnixNano()).Add(g.interval)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(time.Until(evalTimestamp)):</span><br><span class="line"><span class="keyword">case</span> &lt;-g.done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx = promql.NewOriginContext(ctx, <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line"><span class="string">"ruleGroup"</span>: <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"file"</span>: g.File(),</span><br><span class="line"><span class="string">"name"</span>: g.Name(),</span><br><span class="line">&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">iter := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">g.metrics.IterationsScheduled.WithLabelValues(GroupKey(g.file, g.name)).Inc()</span><br><span class="line"></span><br><span class="line">start := time.Now()</span><br><span class="line"><span class="comment">// 将循环当前group的所有rule，并执行eval</span></span><br><span class="line">g.Eval(ctx, evalTimestamp)</span><br><span class="line">timeSinceStart := time.Since(start)</span><br><span class="line"></span><br><span class="line">g.metrics.IterationDuration.Observe(timeSinceStart.Seconds())</span><br><span class="line">g.setEvaluationTime(timeSinceStart)</span><br><span class="line">g.setLastEvaluation(start)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The assumption here is that since the ticker was started after having</span></span><br><span class="line"><span class="comment">// waited for `evalTimestamp` to pass, the ticks will trigger soon</span></span><br><span class="line"><span class="comment">// after each `evalTimestamp + N * g.interval` occurrence.</span></span><br><span class="line">tick := time.NewTicker(g.interval)</span><br><span class="line"><span class="keyword">defer</span> tick.Stop()</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !g.markStale &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(now time.Time)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, rule := <span class="keyword">range</span> g.seriesInPreviousEval &#123;</span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> rule &#123;</span><br><span class="line">g.staleSeries = <span class="built_in">append</span>(g.staleSeries, r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// That can be garbage collected at this point.</span></span><br><span class="line">g.seriesInPreviousEval = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// Wait for 2 intervals to give the opportunity to renamed rules</span></span><br><span class="line"><span class="comment">// to insert new series in the tsdb. At this point if there is a</span></span><br><span class="line"><span class="comment">// renamed rule, it should already be started.</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-g.managerDone:</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">2</span> * g.interval):</span><br><span class="line">g.cleanupStaleSeries(ctx, now)</span><br><span class="line">&#125;</span><br><span class="line">&#125;(time.Now())</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次运行iter，先进行一次rules判断</span></span><br><span class="line">iter()</span><br><span class="line"><span class="comment">// 如果我们需要恢复的话，我们等待另一个 Eval 完成。</span></span><br><span class="line"><span class="comment">// 原因是，在第一次评估期间（或之前），我们可能没有充足的数据，</span></span><br><span class="line"><span class="comment">// 并且记录规则没有更新某些警报可能依赖的最新值</span></span><br><span class="line"><span class="keyword">if</span> g.shouldRestore &#123;</span><br><span class="line"><span class="comment">// If we have to restore, we wait for another Eval to finish.</span></span><br><span class="line"><span class="comment">// The reason behind this is, during first eval (or before it)</span></span><br><span class="line"><span class="comment">// we might not have enough data scraped, and recording rules would not</span></span><br><span class="line"><span class="comment">// have updated the latest values, on which some alerts might depend.</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-g.done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;-tick.C:</span><br><span class="line">missed := (time.Since(evalTimestamp) / g.interval) - <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> missed &gt; <span class="number">0</span> &#123;</span><br><span class="line">g.metrics.IterationsMissed.WithLabelValues(GroupKey(g.file, g.name)).Add(<span class="keyword">float64</span>(missed))</span><br><span class="line">g.metrics.IterationsScheduled.WithLabelValues(GroupKey(g.file, g.name)).Add(<span class="keyword">float64</span>(missed))</span><br><span class="line">&#125;</span><br><span class="line">evalTimestamp = evalTimestamp.Add((missed + <span class="number">1</span>) * g.interval)</span><br><span class="line">iter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">g.RestoreForState(time.Now())</span><br><span class="line">g.shouldRestore = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-g.done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-g.done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;-tick.C:</span><br><span class="line"><span class="comment">// 之后按照 interval 周期循环rules判断是否发送告警</span></span><br><span class="line">missed := (time.Since(evalTimestamp) / g.interval) - <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> missed &gt; <span class="number">0</span> &#123;</span><br><span class="line">g.metrics.IterationsMissed.WithLabelValues(GroupKey(g.file, g.name)).Add(<span class="keyword">float64</span>(missed))</span><br><span class="line">g.metrics.IterationsScheduled.WithLabelValues(GroupKey(g.file, g.name)).Add(<span class="keyword">float64</span>(missed))</span><br><span class="line">&#125;</span><br><span class="line">evalTimestamp = evalTimestamp.Add((missed + <span class="number">1</span>) * g.interval)</span><br><span class="line">iter()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面主要就是根据rules的内容进行定时的计算，判断是否需要生成告警信息，然后将其交给 <code>notifierManager</code> 组件进行处理</p><p>通过<code>g.Eval()</code>，遍历rules去匹配</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Eval runs a single evaluation cycle in which all rules are evaluated sequentially.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">Eval</span><span class="params">(ctx context.Context, ts time.Time)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> samplesTotal <span class="keyword">float64</span></span><br><span class="line"><span class="comment">// 循环所有的rules</span></span><br><span class="line"><span class="keyword">for</span> i, rule := <span class="keyword">range</span> g.rules &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-g.done:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环所有的rules，将每个rule拿出来执行匿名函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>, rule Rule)</span></span> &#123;</span><br><span class="line">sp, ctx := opentracing.StartSpanFromContext(ctx, <span class="string">"rule"</span>)</span><br><span class="line">sp.SetTag(<span class="string">"name"</span>, rule.Name())</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(t time.Time)</span></span> &#123;</span><br><span class="line">sp.Finish()</span><br><span class="line"></span><br><span class="line">since := time.Since(t)</span><br><span class="line">g.metrics.EvalDuration.Observe(since.Seconds())</span><br><span class="line">rule.SetEvaluationDuration(since)</span><br><span class="line">rule.SetEvaluationTimestamp(t)</span><br><span class="line">&#125;(time.Now())</span><br><span class="line"></span><br><span class="line">g.metrics.EvalTotal.WithLabelValues(GroupKey(g.File(), g.Name())).Inc()</span><br><span class="line"></span><br><span class="line"><span class="comment">// AlertingRule.Eval()，通过Engine拉取数据，计算告警表达式，创建告警状态 pending or firing</span></span><br><span class="line">vector, err := rule.Eval(ctx, ts, g.opts.QueryFunc, g.opts.ExternalURL)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">rule.SetHealth(HealthBad)</span><br><span class="line">rule.SetLastError(err)</span><br><span class="line">g.metrics.EvalFailures.WithLabelValues(GroupKey(g.File(), g.Name())).Inc()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Canceled queries are intentional termination of queries. This normally</span></span><br><span class="line"><span class="comment">// happens on shutdown and thus we skip logging of any errors here.</span></span><br><span class="line"><span class="keyword">if</span> _, ok := err.(promql.ErrQueryCanceled); !ok &#123;</span><br><span class="line">level.Warn(g.logger).Log(<span class="string">"msg"</span>, <span class="string">"Evaluating rule failed"</span>, <span class="string">"rule"</span>, rule, <span class="string">"err"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">samplesTotal += <span class="keyword">float64</span>(<span class="built_in">len</span>(vector))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否需要发送告警给 alertmanager</span></span><br><span class="line"><span class="keyword">if</span> ar, ok := rule.(*AlertingRule); ok &#123;</span><br><span class="line">ar.sendAlerts(ctx, ts, g.opts.ResendDelay, g.interval, g.opts.NotifyFunc)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">numOutOfOrder = <span class="number">0</span></span><br><span class="line">numDuplicates = <span class="number">0</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">app := g.opts.Appendable.Appender(ctx)</span><br><span class="line">seriesReturned := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]labels.Labels, <span class="built_in">len</span>(g.seriesInPreviousEval[i]))</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := app.Commit(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">rule.SetHealth(HealthBad)</span><br><span class="line">rule.SetLastError(err)</span><br><span class="line">g.metrics.EvalFailures.WithLabelValues(GroupKey(g.File(), g.Name())).Inc()</span><br><span class="line"></span><br><span class="line">level.Warn(g.logger).Log(<span class="string">"msg"</span>, <span class="string">"Rule sample appending failed"</span>, <span class="string">"err"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">g.seriesInPreviousEval[i] = seriesReturned</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, s := <span class="keyword">range</span> vector &#123;</span><br><span class="line"><span class="keyword">if</span> _, err := app.Append(<span class="number">0</span>, s.Metric, s.T, s.V); err != <span class="literal">nil</span> &#123;</span><br><span class="line">rule.SetHealth(HealthBad)</span><br><span class="line">rule.SetLastError(err)</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> errors.Cause(err) &#123;</span><br><span class="line"><span class="keyword">case</span> storage.ErrOutOfOrderSample:</span><br><span class="line">numOutOfOrder++</span><br><span class="line">level.Debug(g.logger).Log(<span class="string">"msg"</span>, <span class="string">"Rule evaluation result discarded"</span>, <span class="string">"err"</span>, err, <span class="string">"sample"</span>, s)</span><br><span class="line"><span class="keyword">case</span> storage.ErrDuplicateSampleForTimestamp:</span><br><span class="line">numDuplicates++</span><br><span class="line">level.Debug(g.logger).Log(<span class="string">"msg"</span>, <span class="string">"Rule evaluation result discarded"</span>, <span class="string">"err"</span>, err, <span class="string">"sample"</span>, s)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">level.Warn(g.logger).Log(<span class="string">"msg"</span>, <span class="string">"Rule evaluation result discarded"</span>, <span class="string">"err"</span>, err, <span class="string">"sample"</span>, s)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">seriesReturned[s.Metric.String()] = s.Metric</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> numOutOfOrder &gt; <span class="number">0</span> &#123;</span><br><span class="line">level.Warn(g.logger).Log(<span class="string">"msg"</span>, <span class="string">"Error on ingesting out-of-order result from rule evaluation"</span>, <span class="string">"numDropped"</span>, numOutOfOrder)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> numDuplicates &gt; <span class="number">0</span> &#123;</span><br><span class="line">level.Warn(g.logger).Log(<span class="string">"msg"</span>, <span class="string">"Error on ingesting results from rule evaluation with different value but same timestamp"</span>, <span class="string">"numDropped"</span>, numDuplicates)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> metric, lset := <span class="keyword">range</span> g.seriesInPreviousEval[i] &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := seriesReturned[metric]; !ok &#123;</span><br><span class="line"><span class="comment">// Series no longer exposed, mark it stale.</span></span><br><span class="line">_, err = app.Append(<span class="number">0</span>, lset, timestamp.FromTime(ts), math.Float64frombits(value.StaleNaN))</span><br><span class="line"><span class="keyword">switch</span> errors.Cause(err) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="literal">nil</span>:</span><br><span class="line"><span class="keyword">case</span> storage.ErrOutOfOrderSample, storage.ErrDuplicateSampleForTimestamp:</span><br><span class="line"><span class="comment">// Do not count these in logging, as this is expected if series</span></span><br><span class="line"><span class="comment">// is exposed from a different rule.</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">level.Warn(g.logger).Log(<span class="string">"msg"</span>, <span class="string">"Adding stale sample failed"</span>, <span class="string">"sample"</span>, metric, <span class="string">"err"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;(i, rule)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> g.metrics != <span class="literal">nil</span> &#123;</span><br><span class="line">g.metrics.GroupSamples.WithLabelValues(GroupKey(g.File(), g.Name())).Set(samplesTotal)</span><br><span class="line">&#125;</span><br><span class="line">g.cleanupStaleSeries(ctx, ts)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>AlertingRule.Eval()</code>，通过<code>Engine</code>拉取数据，计算告警表达式，创建告警状态<code>pending or firing</code>，然后判断是否需要发送告警给 <code>alertmanager</code></p><p>如果需要发送的话，执行 <code>sendAlerts</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *AlertingRule)</span> <span class="title">sendAlerts</span><span class="params">(ctx context.Context, ts time.Time, resendDelay time.Duration, interval time.Duration, notifyFunc NotifyFunc)</span></span> &#123;</span><br><span class="line">alerts := []*Alert&#123;&#125;</span><br><span class="line">r.ForEachActiveAlert(<span class="function"><span class="keyword">func</span><span class="params">(alert *Alert)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> alert.needsSending(ts, resendDelay) &#123;</span><br><span class="line">alert.LastSentAt = ts</span><br><span class="line"><span class="comment">// Allow for two Eval or Alertmanager send failures.</span></span><br><span class="line">delta := resendDelay</span><br><span class="line"><span class="keyword">if</span> interval &gt; resendDelay &#123;</span><br><span class="line">delta = interval</span><br><span class="line">&#125;</span><br><span class="line">alert.ValidUntil = ts.Add(<span class="number">4</span> * delta)</span><br><span class="line">anew := *alert</span><br><span class="line">alerts = <span class="built_in">append</span>(alerts, &amp;anew)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">notifyFunc(ctx, r.vector.String(), alerts...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这边就是将 <code>alert</code> 整合一下，通过 <code>notifyFunc</code> 发送出去，那么这里的 notifyFunc 是什么呢？还记得我们初始化的时候定义的变量吗，回忆一下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ruleManager = rules.NewManager(&amp;rules.ManagerOptions&#123;</span><br><span class="line">Appendable:      fanoutStorage,</span><br><span class="line">Queryable:       localStorage,</span><br><span class="line">QueryFunc:       rules.EngineQueryFunc(queryEngine, fanoutStorage),</span><br><span class="line"><span class="comment">// 若触发告警规则,则通过sendAlerts发送告警信息</span></span><br><span class="line">NotifyFunc:      sendAlerts(notifierManager, cfg.web.ExternalURL.String()),</span><br><span class="line">Context:         ctxRule,</span><br><span class="line">ExternalURL:     cfg.web.ExternalURL,</span><br><span class="line">Registerer:      prometheus.DefaultRegisterer,</span><br><span class="line">Logger:          log.With(logger, <span class="string">"component"</span>, <span class="string">"rule manager"</span>),</span><br><span class="line">OutageTolerance: time.Duration(cfg.outageTolerance),</span><br><span class="line">ForGracePeriod:  time.Duration(cfg.forGracePeriod),</span><br><span class="line">ResendDelay:     time.Duration(cfg.resendDelay),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>没错就是 <code>sendAlerts(notifierManager, cfg.web.ExternalURL.String())</code> ，具体实现在</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sendAlerts implements the rules.NotifyFunc for a Notifier.</span></span><br><span class="line"><span class="comment">// sendAlerts方法主要作用是把规则管理(ruleManager)把告警信息转换成notifier.Alert类型</span></span><br><span class="line"><span class="comment">// 遍历告警信息,构造告警,告警信息长度大于0, 则发送告警</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendAlerts</span><span class="params">(s sender, externalURL <span class="keyword">string</span>)</span> <span class="title">rules</span>.<span class="title">NotifyFunc</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, expr <span class="keyword">string</span>, alerts ...*rules.Alert)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> res []*notifier.Alert</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历告警信息</span></span><br><span class="line"><span class="keyword">for</span> _, alert := <span class="keyword">range</span> alerts &#123;</span><br><span class="line">a := &amp;notifier.Alert&#123;</span><br><span class="line">StartsAt:     alert.FiredAt,</span><br><span class="line">Labels:       alert.Labels,</span><br><span class="line">Annotations:  alert.Annotations,</span><br><span class="line">GeneratorURL: externalURL + strutil.TableLinkForExpression(expr),</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 若告警结束,设置告警结束时间为ResolverdAt时间</span></span><br><span class="line"><span class="keyword">if</span> !alert.ResolvedAt.IsZero() &#123;</span><br><span class="line">a.EndsAt = alert.ResolvedAt</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 若告警还是active状态,设置告警结束时间为当前时间</span></span><br><span class="line">a.EndsAt = alert.ValidUntil</span><br><span class="line">&#125;</span><br><span class="line">res = <span class="built_in">append</span>(res, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若是有告警信息, 则发送告警</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(alerts) &gt; <span class="number">0</span> &#123;</span><br><span class="line">s.Send(res...)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里的 <code>sender</code> 就是 <code>norifierManager</code> ，规则管理(ruleManager)把告警信息转换成notifier.Alert类型，遍历告警信息，如果存在告警，则发送告警。</p><p><code>notifier.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Send queues the given notification requests for processing.</span></span><br><span class="line"><span class="comment">// Panics if called on a handler that is not running.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Manager)</span> <span class="title">Send</span><span class="params">(alerts ...*Alert)</span></span> &#123;</span><br><span class="line">n.mtx.Lock()</span><br><span class="line"><span class="keyword">defer</span> n.mtx.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Attach external labels before relabelling and sending.</span></span><br><span class="line"><span class="comment">// 根据配置文件prometheus.yml的alert_relabel_configs下的relabel_config对告警的label进行重置</span></span><br><span class="line"><span class="keyword">for</span> _, a := <span class="keyword">range</span> alerts &#123;</span><br><span class="line">lb := labels.NewBuilder(a.Labels)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, l := <span class="keyword">range</span> n.opts.ExternalLabels &#123;</span><br><span class="line"><span class="keyword">if</span> a.Labels.Get(l.Name) == <span class="string">""</span> &#123;</span><br><span class="line">lb.Set(l.Name, l.Value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.Labels = lb.Labels()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alerts = n.relabelAlerts(alerts)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(alerts) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Queue capacity should be significantly larger than a single alert</span></span><br><span class="line"><span class="comment">// batch could be.</span></span><br><span class="line"><span class="comment">// 若待告警信息的数量大于队列总容量,则移除待告警信息中最早的告警信息, 依据的规则是先进先移除</span></span><br><span class="line"><span class="keyword">if</span> d := <span class="built_in">len</span>(alerts) - n.opts.QueueCapacity; d &gt; <span class="number">0</span> &#123;</span><br><span class="line">alerts = alerts[d:]</span><br><span class="line"></span><br><span class="line">level.Warn(n.logger).Log(<span class="string">"msg"</span>, <span class="string">"Alert batch larger than queue capacity, dropping alerts"</span>, <span class="string">"num_dropped"</span>, d)</span><br><span class="line">n.metrics.dropped.Add(<span class="keyword">float64</span>(d))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If the queue is full, remove the oldest alerts in favor</span></span><br><span class="line"><span class="comment">// of newer ones.</span></span><br><span class="line"><span class="comment">// 若队列中已有的告警信息和待发送的告警信息大于队列的总容量,则从队列中移除最早的告警信息, 依据是先进先移除</span></span><br><span class="line"><span class="keyword">if</span> d := (<span class="built_in">len</span>(n.queue) + <span class="built_in">len</span>(alerts)) - n.opts.QueueCapacity; d &gt; <span class="number">0</span> &#123;</span><br><span class="line">n.queue = n.queue[d:]</span><br><span class="line"></span><br><span class="line">level.Warn(n.logger).Log(<span class="string">"msg"</span>, <span class="string">"Alert notification queue full, dropping alerts"</span>, <span class="string">"num_dropped"</span>, d)</span><br><span class="line">n.metrics.dropped.Add(<span class="keyword">float64</span>(d))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把待发送的告警信息加入队列</span></span><br><span class="line">n.queue = <span class="built_in">append</span>(n.queue, alerts...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Notify sending goroutine that there are alerts to be processed.</span></span><br><span class="line"><span class="comment">// 告知通知管理(notifierManager)有告警信息需要处理</span></span><br><span class="line"><span class="comment">// setMore方法相当于一个触发器，向管道n.more发送触发信息, 告知通知管理(notifierManager)有告警信息需要处理，</span></span><br><span class="line"><span class="comment">// 是连接规则管理(ruleManager)和通知管理(notifierManager)的桥梁</span></span><br><span class="line">n.setMore()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看下 <code>notifierManager</code> 的处理</p><h2 id="notifierManager"><a href="#notifierManager" class="headerlink" title="notifierManager"></a>notifierManager</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// notifier 是用于向 alertmanager 发送告警的</span></span><br><span class="line">notifierManager = notifier.NewManager(&amp;cfg.notifier, log.With(logger, <span class="string">"component"</span>, <span class="string">"notifier"</span>))</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">name:     <span class="string">"notify"</span>,</span><br><span class="line">reloader: notifierManager.ApplyConfig,</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ApplyConfig updates the status state as the new config requires.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Manager)</span> <span class="title">ApplyConfig</span><span class="params">(conf *config.Config)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">n.mtx.Lock()</span><br><span class="line"><span class="keyword">defer</span> n.mtx.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置文件prometheus.yml中global下的external_labels, 用于外部系统标签的，不是用于metrics数据</span></span><br><span class="line">n.opts.ExternalLabels = conf.GlobalConfig.ExternalLabels</span><br><span class="line"><span class="comment">// 配置文件prometheus.yml中alertingl下alert_relabel_configs, 动态修改 alert 属性的规则配置</span></span><br><span class="line">n.opts.RelabelConfigs = conf.AlertingConfig.AlertRelabelConfigs</span><br><span class="line"></span><br><span class="line">amSets := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*alertmanagerSet)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历告警相关的配置,即配置文件prometheus.yml的alerting</span></span><br><span class="line"><span class="keyword">for</span> k, cfg := <span class="keyword">range</span> conf.AlertingConfig.AlertmanagerConfigs.ToMap() &#123;</span><br><span class="line"><span class="comment">// 把alerting下每个配置项, 转换成结构实例:alertmanagerSet</span></span><br><span class="line">ams, err := newAlertmanagerSet(cfg, n.logger, n.metrics)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">amSets[k] = ams</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n.alertmanagers = amSets</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下正式启动的地方：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// When the notifier manager receives a new targets list</span></span><br><span class="line"><span class="comment">// it needs to read a valid config for each job.</span></span><br><span class="line"><span class="comment">// It depends on the config being in sync with the discovery manager</span></span><br><span class="line"><span class="comment">// so we wait until the config is fully loaded.</span></span><br><span class="line">&lt;-reloadReady.C</span><br><span class="line"></span><br><span class="line">notifierManager.Run(discoveryManagerNotify.SyncCh())</span><br><span class="line">level.Info(logger).Log(<span class="string">"msg"</span>, <span class="string">"Notifier manager stopped"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line">notifierManager.Stop()</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run dispatches notifications continuously.</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Run方法, 监听n.more管道. 若规则管理(ruleManager)向管道n.more发送信号,</span></span><br><span class="line"><span class="comment">告知通知管理(notifierManager)有告警信息需要发送，则触发接下来的告警信息处理</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Run方法和指标采集(scrapeManager)的Run方法共用服务发现 (serviceDiscover)的处理逻辑,</span></span><br><span class="line"><span class="comment">检测目标(targets)是否有变动, 不同的是通知管理(notifierManager)只监听告警服务的变动</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">指标采集(scrapeManager)的tset为map类型, key为job_name, value为targetgroup.Group．</span></span><br><span class="line"><span class="comment">而通知管理(notifierManager)的tset也为map类型，不同的是key为AlertmanagerConfig, value为targetgroup.Group</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Manager)</span> <span class="title">Run</span><span class="params">(tsets &lt;-<span class="keyword">chan</span> <span class="keyword">map</span>[<span class="keyword">string</span>][]*targetgroup.Group)</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-n.ctx.Done():</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="comment">// 发现告警服务有更新,重新加载配置. 参考服务发现(discoveryManager)</span></span><br><span class="line"><span class="keyword">case</span> ts := &lt;-tsets:</span><br><span class="line">n.reload(ts)</span><br><span class="line"><span class="comment">// 告警信号,这个channel在ruleManager服务在产生告警时，会发出信号</span></span><br><span class="line"><span class="keyword">case</span> &lt;-n.more:</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 利用告警队列, 获取告警信息</span></span><br><span class="line">alerts := n.nextBatch()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果全部am都没发送成功，就记录丢弃数量指标</span></span><br><span class="line"><span class="keyword">if</span> !n.sendAll(alerts...) &#123;</span><br><span class="line">n.metrics.dropped.Add(<span class="keyword">float64</span>(<span class="built_in">len</span>(alerts)))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// If the queue still has items left, kick off the next iteration.</span></span><br><span class="line"><span class="comment">// 若告警队列中还有告警信息,则再次想n.more传入信号,发送告警信息</span></span><br><span class="line"><span class="keyword">if</span> n.queueLen() &gt; <span class="number">0</span> &#123;</span><br><span class="line">n.setMore()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是通过 <code>n.more</code> channel与 ruleManager 做交互，当那边产生告警的时候，这边会接收到这个信号，进行处理，然后发送</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sendAll sends the alerts to all configured Alertmanagers concurrently.</span></span><br><span class="line"><span class="comment">// It returns true if the alerts could be sent successfully to at least one Alertmanager.</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将告警发送给全部当前配置的 Alertmanager。至少成功发送给一个 Alertmanager 就返回 true。</span></span><br><span class="line"><span class="comment">1. 如果 alerts 为空就返回 true</span></span><br><span class="line"><span class="comment">2. 记录函数执行开始时间</span></span><br><span class="line"><span class="comment">3. 声明 v1Payload, v2Payload 两个字节数组，他们是 alerts 序列化的结果，提前声明是作为缓存，避免在循环中反复声明降低性能</span></span><br><span class="line"><span class="comment">4. 加锁读取 Alertmanager 集合</span></span><br><span class="line"><span class="comment">5. 声明一个 WaitGroup 用于同步等待每个 am 都发送完毕后退出函数</span></span><br><span class="line"><span class="comment">6. 循环 amSets 中的每个 ams，amSet 是不同的服务发现方式配置的am集合，每个 amSet 里面可能有多个 am</span></span><br><span class="line"><span class="comment">7. 根据 ams 的 API 版本对 alerts 进行序列化成 payload</span></span><br><span class="line"><span class="comment">8. 循环 ams 中的每个 am，启一个 goroutine，调用 sendOne() 函数将 payload 发送过去，根据成功或者失败的结果记录观测指标</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Manager)</span> <span class="title">sendAll</span><span class="params">(alerts ...*Alert)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(alerts) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">begin := time.Now()</span><br><span class="line"></span><br><span class="line"><span class="comment">// v1Payload and v2Payload represent 'alerts' marshaled for Alertmanager API</span></span><br><span class="line"><span class="comment">// v1 or v2. Marshaling happens below. Reference here is for caching between</span></span><br><span class="line"><span class="comment">// for loop iterations.</span></span><br><span class="line"><span class="keyword">var</span> v1Payload, v2Payload []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line">n.mtx.RLock()</span><br><span class="line"><span class="comment">// 获取当前最新的告警服务列表</span></span><br><span class="line">amSets := n.alertmanagers</span><br><span class="line">n.mtx.RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">wg         sync.WaitGroup</span><br><span class="line">numSuccess atomic.Uint64</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 遍历告警服务列表</span></span><br><span class="line"><span class="keyword">for</span> _, ams := <span class="keyword">range</span> amSets &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">payload []<span class="keyword">byte</span></span><br><span class="line">err     error</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">ams.mtx.RLock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> ams.cfg.APIVersion &#123;</span><br><span class="line"><span class="keyword">case</span> config.AlertmanagerAPIVersionV1:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> v1Payload == <span class="literal">nil</span> &#123;</span><br><span class="line">v1Payload, err = json.Marshal(alerts)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">level.Error(n.logger).Log(<span class="string">"msg"</span>, <span class="string">"Encoding alerts for Alertmanager API v1 failed"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">ams.mtx.RUnlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">payload = v1Payload</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> config.AlertmanagerAPIVersionV2:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> v2Payload == <span class="literal">nil</span> &#123;</span><br><span class="line">openAPIAlerts := alertsToOpenAPIAlerts(alerts)</span><br><span class="line"></span><br><span class="line">v2Payload, err = json.Marshal(openAPIAlerts)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">level.Error(n.logger).Log(<span class="string">"msg"</span>, <span class="string">"Encoding alerts for Alertmanager API v2 failed"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">ams.mtx.RUnlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">payload = v2Payload</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#123;</span><br><span class="line">level.Error(n.logger).Log(</span><br><span class="line"><span class="string">"msg"</span>, fmt.Sprintf(<span class="string">"Invalid Alertmanager API version '%v', expected one of '%v'"</span>, ams.cfg.APIVersion, config.SupportedAlertmanagerAPIVersions),</span><br><span class="line"><span class="string">"err"</span>, err,</span><br><span class="line">)</span><br><span class="line">ams.mtx.RUnlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, am := <span class="keyword">range</span> ams.ams &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">ctx, cancel := context.WithTimeout(n.ctx, time.Duration(ams.cfg.Timeout))</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 起一个协程发送告警信息</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(client *http.Client, url <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := n.sendOne(ctx, client, url, payload); err != <span class="literal">nil</span> &#123;</span><br><span class="line">level.Error(n.logger).Log(<span class="string">"alertmanager"</span>, url, <span class="string">"count"</span>, <span class="built_in">len</span>(alerts), <span class="string">"msg"</span>, <span class="string">"Error sending alert"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">n.metrics.errors.WithLabelValues(url).Inc()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">numSuccess.Inc()</span><br><span class="line">&#125;</span><br><span class="line">n.metrics.latency.WithLabelValues(url).Observe(time.Since(begin).Seconds())</span><br><span class="line">n.metrics.sent.WithLabelValues(url).Add(<span class="keyword">float64</span>(<span class="built_in">len</span>(alerts)))</span><br><span class="line"></span><br><span class="line">wg.Done()</span><br><span class="line">&#125;(ams.client, am.url().String())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ams.mtx.RUnlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若至少成功发送给一个告警服务，则返回true</span></span><br><span class="line"><span class="keyword">return</span> numSuccess.Load() &gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里发送成功之后就到 <code>alertmanager</code> 服务了，如果发送失败了，就将这个指标丢弃了，若告警队列中还有告警信息，则再次想n.more传入信号，再次发送告警信息处理。</p><p>参考：</p><p><a href="https://blog.csdn.net/u010278923/article/details/70946469?locationNum=9&amp;fps=1" target="_blank" rel="external">Prometheus 实战于源码分析之alert</a></p><p><a href="https://www.jianshu.com/p/1697e09e99ac" target="_blank" rel="external">Prometheus监控神器-Rules篇</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p id=&quot;div-border-top-green&quot;&gt;每个人真正强大起来都要度过一段没人帮忙，没人支持的日子。所有事情都是自己一个人撑，所有情绪都是只有自己知道。但只要咬牙撑过去，一切都不一样了。&lt;br&gt;&lt;/p&gt;

&lt;h1 id=&quot;rules-配置和使用&quot;&gt;&lt;a href=&quot;#rules-配置和使用&quot; class=&quot;headerlink&quot; title=&quot;rules 配置和使用&quot;&gt;&lt;/a&gt;rules 配置和使用&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;prometheus不仅可以提供数据采集功能，而且还可以做告警服务，通过匹配的性能参数，发出告警；然后把产生的警报发给Alertmanager进行处理。&lt;/p&gt;
&lt;p&gt;但是这需要在Prometheus使用的配置文件中添加关联Alertmanager的组件的对应配置信息&lt;/p&gt;
    
    </summary>
    
      <category term="Prometheus" scheme="https://magiceses.github.io/categories/Prometheus/"/>
    
    
      <category term="Prometheus" scheme="https://magiceses.github.io/tags/Prometheus/"/>
    
  </entry>
  
  <entry>
    <title>Prometheus 指标抓取源码分析</title>
    <link href="https://magiceses.github.io/2020/10/05/prometheus-prometheus-4-%E6%8C%87%E6%A0%87%E6%8A%93%E5%8F%96%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://magiceses.github.io/2020/10/05/prometheus-prometheus-4-指标抓取源码分析/</id>
    <published>2020-10-04T23:25:24.000Z</published>
    <updated>2021-10-02T05:24:14.719Z</updated>
    
    <content type="html"><![CDATA[<p id="div-border-top-green">生活像一只蝴蝶，没有破茧的勇气，哪来飞舞的美丽。生活像一只蜜蜂，没有勤劳和努力，怎能尝到花粉的甜蜜，越努力越幸运！<br></p><p>scrape模块在prometheus中负责着采集具体指标，并记录到后端存储中的功能，可以说是prometheus最为核心的一个功能模块</p><p>篇幅较长，需要耐心</p><h2 id="指标采集简介"><a href="#指标采集简介" class="headerlink" title="指标采集简介"></a>指标采集简介</h2><p>为了从服务发现(serviceDiscover)实时获取监控服务(targets)，指标采集(scrapeManager)通过协程把管道(chan)获取来的服务(targets)存</p><p>进一个map类型：<code>map[string][]*targetgroup.Group</code>．其中，map的key是job_name，map的value是结构体targetgroup.Group，</p><p>该结构体包含该job_name对应的Targets，Labes和Source</p><a id="more"></a><p>指标采集(scrapeManager)获取服务(targets)的变动，可分为多种情况，以服务增加为例，若有新的job添加，指标采集(scrapeManager)</p><p>会进行重载，为新的job创建一个scrapePool，并为job中的每个target创建一个scrapeLoop．若job没有变动，只增加了job下对应的</p><p>targets，则只需创建新的targets对应的scrapeLoop</p><h2 id="指标采集流程"><a href="#指标采集流程" class="headerlink" title="指标采集流程"></a>指标采集流程</h2><p>总体流程</p><p><img src="/images/prometheus-prometheus-9.png" alt="在这里插入图片描述"></p><p>静态结构</p><p><img src="/images/prometheus-prometheus-10.jpeg" alt="img"></p><p>在一个管理面（scrapeManager）中，每次初始化（重载），会根据配置的份数创建出对应的采集缓冲池（scrapePool）；在缓冲池</p><p>中，每一个监控目标会对应创建一个采集循环（scrapeLoop）；采集循环可以认为是最小的一个工作单位，下图进一步解析采集循环的</p><p>静态结构</p><p><img src="/images/prometheus-prometheus-11.jpeg" alt="img"></p><p>采集的主要流程函数在scrape.go中的scrapeAndReport，采集接口（scraper）采集到数据后，会先调用append方法写到采集缓冲层</p><p>（scrapeCache）中，最后调用持久化的Commit方法写到后端存储</p><h2 id="指标采集配置"><a href="#指标采集配置" class="headerlink" title="指标采集配置"></a>指标采集配置</h2><p>指标采集(scrapeManager)调用scrapeManager.ApplyConfig方法，完成配置初始化及应用</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">prometheus/scrape/manager.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ApplyConfig resets the manager's target providers and job configurations as defined by the new cfg.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Manager)</span> <span class="title">ApplyConfig</span><span class="params">(cfg *config.Config)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">m.mtxScrape.Lock()</span><br><span class="line"><span class="keyword">defer</span> m.mtxScrape.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个map，key是job_name，value是结构体config.ScrapeConfig</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*config.ScrapeConfig)</span><br><span class="line"><span class="keyword">for</span> _, scfg := <span class="keyword">range</span> cfg.ScrapeConfigs &#123;</span><br><span class="line">c[scfg.JobName] = scfg</span><br><span class="line">&#125;</span><br><span class="line">m.scrapeConfigs = c</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := m.setJitterSeed(cfg.GlobalConfig.ExternalLabels); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 首次启动不执行</span></span><br><span class="line"><span class="comment">// Cleanup and reload pool if the configuration has changed.</span></span><br><span class="line"><span class="keyword">var</span> failed <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">for</span> name, sp := <span class="keyword">range</span> m.scrapePools &#123;</span><br><span class="line">    <span class="comment">// 若job_name在scrapePools中，不在scrapeConfigs中，则说明已经更新，停止该job_name对应的scrapePool</span></span><br><span class="line"><span class="keyword">if</span> cfg, ok := m.scrapeConfigs[name]; !ok &#123;</span><br><span class="line">sp.stop()</span><br><span class="line"><span class="built_in">delete</span>(m.scrapePools, name)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> !reflect.DeepEqual(sp.config, cfg) &#123;</span><br><span class="line">      <span class="comment">// 若job_name在scrapePools中，也在scrapeConfigs中，但配置有变化，比如target增加或减少，需要重新加</span></span><br><span class="line">err := sp.reload(cfg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">level.Error(m.logger).Log(<span class="string">"msg"</span>, <span class="string">"error reloading scrape pool"</span>, <span class="string">"err"</span>, err, <span class="string">"scrape_pool"</span>, name)</span><br><span class="line">failed = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> failed &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">"failed to apply the new configuration"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用reload方法重新加载配置文件</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">prometheus/scrape/scrape.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// reload the scrape pool with the given scrape configuration. The target state is preserved</span></span><br><span class="line"><span class="comment">// but all scrape loops are restarted with the new scrape configuration.</span></span><br><span class="line"><span class="comment">// This method returns after all scrape loops that were stopped have stopped scraping.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sp *scrapePool)</span> <span class="title">reload</span><span class="params">(cfg *config.ScrapeConfig)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">sp.mtx.Lock()</span><br><span class="line"><span class="keyword">defer</span> sp.mtx.Unlock()</span><br><span class="line">targetScrapePoolReloads.Inc()</span><br><span class="line">start := time.Now()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成client，用于获取指标(metircs)</span></span><br><span class="line">client, err := config_util.NewClientFromConfig(cfg.HTTPClientConfig, cfg.JobName, config_util.WithHTTP2Disabled())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">targetScrapePoolReloadsFailed.Inc()</span><br><span class="line"><span class="keyword">return</span> errors.Wrap(err, <span class="string">"error creating HTTP client"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reuseCache := reusableCache(sp.config, cfg)</span><br><span class="line">sp.config = cfg</span><br><span class="line">oldClient := sp.client</span><br><span class="line">sp.client = client</span><br><span class="line"></span><br><span class="line">targetScrapePoolTargetLimit.WithLabelValues(sp.config.JobName).Set(<span class="keyword">float64</span>(sp.config.TargetLimit))</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">wg          sync.WaitGroup</span><br><span class="line">interval    = time.Duration(sp.config.ScrapeInterval)</span><br><span class="line">timeout     = time.Duration(sp.config.ScrapeTimeout)</span><br><span class="line">sampleLimit = <span class="keyword">int</span>(sp.config.SampleLimit)</span><br><span class="line">labelLimits = &amp;labelLimits&#123;</span><br><span class="line">labelLimit:            <span class="keyword">int</span>(sp.config.LabelLimit),</span><br><span class="line">labelNameLengthLimit:  <span class="keyword">int</span>(sp.config.LabelNameLengthLimit),</span><br><span class="line">labelValueLengthLimit: <span class="keyword">int</span>(sp.config.LabelValueLengthLimit),</span><br><span class="line">&#125;</span><br><span class="line">honorLabels     = sp.config.HonorLabels</span><br><span class="line">honorTimestamps = sp.config.HonorTimestamps</span><br><span class="line">mrc             = sp.config.MetricRelabelConfigs</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">sp.targetMtx.Lock()</span><br><span class="line"></span><br><span class="line">forcedErr := sp.refreshTargetLimitErr()</span><br><span class="line">  <span class="comment">// 停止该scrapePool下对应的所有的oldLoop，更具配置创建所有的newLoop，并通过协程启动</span></span><br><span class="line"><span class="keyword">for</span> fp, oldLoop := <span class="keyword">range</span> sp.loops &#123;</span><br><span class="line"><span class="keyword">var</span> cache *scrapeCache</span><br><span class="line"><span class="keyword">if</span> oc := oldLoop.getCache(); reuseCache &amp;&amp; oc != <span class="literal">nil</span> &#123;</span><br><span class="line">oldLoop.disableEndOfRunStalenessMarkers()</span><br><span class="line">cache = oc</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cache = newScrapeCache()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">t       = sp.activeTargets[fp]</span><br><span class="line">s       = &amp;targetScraper&#123;Target: t, client: sp.client, timeout: timeout&#125;</span><br><span class="line">newLoop = sp.newLoop(scrapeLoopOptions&#123;</span><br><span class="line">target:          t,</span><br><span class="line">scraper:         s,</span><br><span class="line">sampleLimit:     sampleLimit,</span><br><span class="line">labelLimits:     labelLimits,</span><br><span class="line">honorLabels:     honorLabels,</span><br><span class="line">honorTimestamps: honorTimestamps,</span><br><span class="line">mrc:             mrc,</span><br><span class="line">cache:           cache,</span><br><span class="line">&#125;)</span><br><span class="line">)</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(oldLoop, newLoop loop)</span></span> &#123;</span><br><span class="line">oldLoop.stop()</span><br><span class="line">wg.Done()</span><br><span class="line"></span><br><span class="line">newLoop.setForcedError(forcedErr)</span><br><span class="line">newLoop.run(interval, timeout, <span class="literal">nil</span>)</span><br><span class="line">&#125;(oldLoop, newLoop)</span><br><span class="line"></span><br><span class="line">sp.loops[fp] = newLoop</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp.targetMtx.Unlock()</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">oldClient.CloseIdleConnections()</span><br><span class="line">targetReloadIntervalLength.WithLabelValues(interval.String()).Observe(</span><br><span class="line">time.Since(start).Seconds(),</span><br><span class="line">)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次 reload 配置文件的时候都会重新加载 scrape 的配置，config/config.go 中的 ScrapeConfig 结构体</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ScrapeConfig configures a scraping unit for Prometheus.</span></span><br><span class="line"><span class="keyword">type</span> ScrapeConfig <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// The job name to which the job label is set by default.</span></span><br><span class="line">JobName <span class="keyword">string</span> <span class="string">`yaml:"job_name"`</span></span><br><span class="line"><span class="comment">// Indicator whether the scraped metrics should remain unmodified.</span></span><br><span class="line">HonorLabels <span class="keyword">bool</span> <span class="string">`yaml:"honor_labels,omitempty"`</span></span><br><span class="line"><span class="comment">// Indicator whether the scraped timestamps should be respected.</span></span><br><span class="line">HonorTimestamps <span class="keyword">bool</span> <span class="string">`yaml:"honor_timestamps"`</span></span><br><span class="line"><span class="comment">// A set of query parameters with which the target is scraped.</span></span><br><span class="line">Params url.Values <span class="string">`yaml:"params,omitempty"`</span></span><br><span class="line"><span class="comment">// How frequently to scrape the targets of this scrape config.</span></span><br><span class="line">ScrapeInterval model.Duration <span class="string">`yaml:"scrape_interval,omitempty"`</span></span><br><span class="line"><span class="comment">// The timeout for scraping targets of this config.</span></span><br><span class="line">ScrapeTimeout model.Duration <span class="string">`yaml:"scrape_timeout,omitempty"`</span></span><br><span class="line"><span class="comment">// The HTTP resource path on which to fetch metrics from targets.</span></span><br><span class="line">MetricsPath <span class="keyword">string</span> <span class="string">`yaml:"metrics_path,omitempty"`</span></span><br><span class="line"><span class="comment">// The URL scheme with which to fetch metrics from targets.</span></span><br><span class="line">Scheme <span class="keyword">string</span> <span class="string">`yaml:"scheme,omitempty"`</span></span><br><span class="line"><span class="comment">// More than this many samples post metric-relabeling will cause the scrape to</span></span><br><span class="line"><span class="comment">// fail.</span></span><br><span class="line">SampleLimit <span class="keyword">uint</span> <span class="string">`yaml:"sample_limit,omitempty"`</span></span><br><span class="line"><span class="comment">// More than this many targets after the target relabeling will cause the</span></span><br><span class="line"><span class="comment">// scrapes to fail.</span></span><br><span class="line">TargetLimit <span class="keyword">uint</span> <span class="string">`yaml:"target_limit,omitempty"`</span></span><br><span class="line"><span class="comment">// More than this many labels post metric-relabeling will cause the scrape to</span></span><br><span class="line"><span class="comment">// fail.</span></span><br><span class="line">LabelLimit <span class="keyword">uint</span> <span class="string">`yaml:"label_limit,omitempty"`</span></span><br><span class="line"><span class="comment">// More than this label name length post metric-relabeling will cause the</span></span><br><span class="line"><span class="comment">// scrape to fail.</span></span><br><span class="line">LabelNameLengthLimit <span class="keyword">uint</span> <span class="string">`yaml:"label_name_length_limit,omitempty"`</span></span><br><span class="line"><span class="comment">// More than this label value length post metric-relabeling will cause the</span></span><br><span class="line"><span class="comment">// scrape to fail.</span></span><br><span class="line">LabelValueLengthLimit <span class="keyword">uint</span> <span class="string">`yaml:"label_value_length_limit,omitempty"`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// We cannot do proper Go type embedding below as the parser will then parse</span></span><br><span class="line"><span class="comment">// values arbitrarily into the overflow maps of further-down types.</span></span><br><span class="line"></span><br><span class="line">ServiceDiscoveryConfigs discovery.Configs       <span class="string">`yaml:"-"`</span></span><br><span class="line">HTTPClientConfig        config.HTTPClientConfig <span class="string">`yaml:",inline"`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// List of target relabel configurations.</span></span><br><span class="line">RelabelConfigs []*relabel.Config <span class="string">`yaml:"relabel_configs,omitempty"`</span></span><br><span class="line"><span class="comment">// List of metric relabel configurations.</span></span><br><span class="line">MetricRelabelConfigs []*relabel.Config <span class="string">`yaml:"metric_relabel_configs,omitempty"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指标采集启动"><a href="#指标采集启动" class="headerlink" title="指标采集启动"></a>指标采集启动</h2><ol><li>main 函数中初始化 scrapeManager 实例</li></ol><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">prometheus/cmd/prometheus/main.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 scrapeManager，fanout Storage 是一个读写多个底层存储的代理</span></span><br><span class="line">scrapeManager = scrape.NewManager(log.With(logger, <span class="string">"component"</span>, <span class="string">"scrape manager"</span>), fanoutStorage)</span><br></pre></td></tr></table></figure><p>fanoutStorage 是读写多个底层存储的代理，实现了 storage.Appendable 接口</p><p>NewManager方法了实例化结构体Manager</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">prometheus/scrape/manager.<span class="keyword">go</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// NewManager is the Manager constructor</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewManager</span><span class="params">(logger log.Logger, app Appendable)</span> *<span class="title">Manager</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> logger == <span class="literal">nil</span> &#123;</span><br><span class="line">logger = log.NewNopLogger()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;Manager&#123;</span><br><span class="line"><span class="built_in">append</span>:        app,</span><br><span class="line">logger:        logger,</span><br><span class="line">scrapeConfigs: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*config.ScrapeConfig),</span><br><span class="line">scrapePools:   <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*scrapePool),</span><br><span class="line">graceShut:     <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">triggerReload: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体Manager维护map类型的scrapePools和targetSets，两者key都是job_name，但scrapePools的value对应结构体scrapepool，而</p><p>targetSets的value对应的结构体是Group，分别给出了两者的示例输出</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">prometheus/scrape/manager.<span class="keyword">go</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Manager maintains a set of scrape pools and manages start/stop cycles</span></span><br><span class="line"><span class="comment">// when receiving new target groups form the discovery manager.</span></span><br><span class="line"><span class="keyword">type</span> Manager <span class="keyword">struct</span> &#123;</span><br><span class="line">logger    log.Logger  <span class="comment">//系统日志</span></span><br><span class="line"><span class="built_in">append</span>    Appendable  <span class="comment">//存储监控指标</span></span><br><span class="line">graceShut <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;  <span class="comment">//退出</span></span><br><span class="line"> </span><br><span class="line">mtxScrape     sync.Mutex <span class="comment">// Guards the fields below. 读写锁</span></span><br><span class="line">scrapeConfigs <span class="keyword">map</span>[<span class="keyword">string</span>]*config.ScrapeConfig  <span class="comment">//prometheus.yml的srape_config配置部分，key对应job_name，value对应job_name的配置参数</span></span><br><span class="line">scrapePools   <span class="keyword">map</span>[<span class="keyword">string</span>]*scrapePool  <span class="comment">//key对应job_name，value对应结构体scrapePool，包含该job_name下所有的targets</span></span><br><span class="line">targetSets    <span class="keyword">map</span>[<span class="keyword">string</span>][]*targetgroup.Group  <span class="comment">//key对应job_name，value对应结构体Group，包含job_name对应的Targets，Labels和Source</span></span><br><span class="line"> </span><br><span class="line">triggerReload <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">//若有新的服务(targets)通过服务发现(serviceDisvoer)传过来，会向该管道传值，触发加载配置文件操作，后面会讲到</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">基于job_name：node的targetSets的示例输出：</span><br><span class="line">(dlv) p m.targetSets[<span class="string">"node"</span>]</span><br><span class="line">[]*github.com/prometheus/prometheus/discovery/targetgroup.Group <span class="built_in">len</span>: <span class="number">1</span>, <span class="built_in">cap</span>: <span class="number">1</span>, [</span><br><span class="line">*&#123;</span><br><span class="line">Targets: []github.com/prometheus/common/model.LabelSet <span class="built_in">len</span>: <span class="number">1</span>, <span class="built_in">cap</span>: <span class="number">1</span>, [</span><br><span class="line">                 [</span><br><span class="line">                   <span class="string">"__address__"</span>: <span class="string">"localhost:9100"</span>, </span><br><span class="line">                 ],</span><br><span class="line">],</span><br><span class="line">Labels: github.com/prometheus/common/model.LabelSet <span class="literal">nil</span>,</span><br><span class="line">Source: <span class="string">"0"</span>,&#125;,</span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line">基于job_name：node的scrapePools示例输出：</span><br><span class="line">(dlv) p m.scrapePools</span><br><span class="line"><span class="keyword">map</span>[<span class="keyword">string</span>]*github.com/prometheus/prometheus/scrape.scrapePool [</span><br><span class="line"><span class="string">"node"</span>: *&#123;</span><br><span class="line">appendable: github.com/prometheus/prometheus/scrape.Appendable(*github.com/prometheus/prometheus/storage.fanout) ...,</span><br><span class="line">logger: github.com/<span class="keyword">go</span>-kit/kit/log.Logger(*github.com/<span class="keyword">go</span>-kit/kit/log.context) ...,</span><br><span class="line">mtx: (*sync.RWMutex)(<span class="number">0xc001be0020</span>),</span><br><span class="line">config: *(*<span class="string">"github.com/prometheus/prometheus/config.ScrapeConfig"</span>)(<span class="number">0xc00048ab40</span>),</span><br><span class="line">client: *(*<span class="string">"net/http.Client"</span>)(<span class="number">0xc000d</span>303c0),</span><br><span class="line">activeTargets: <span class="keyword">map</span>[<span class="keyword">uint64</span>]*github.com/prometheus/prometheus/scrape.Target [],</span><br><span class="line">droppedTargets: []*github.com/prometheus/prometheus/scrape.Target <span class="built_in">len</span>: <span class="number">0</span>, <span class="built_in">cap</span>: <span class="number">0</span>, <span class="literal">nil</span>,</span><br><span class="line">loops: <span class="keyword">map</span>[<span class="keyword">uint64</span>]github.com/prometheus/prometheus/scrape.loop [],</span><br><span class="line">cancel: context.WithCancel.func1,</span><br><span class="line">newLoop: github.com/prometheus/prometheus/scrape.newScrapePool.func2,&#125;, </span><br><span class="line">]</span><br></pre></td></tr></table></figure><ol><li>指标采集(scrapeManager)获取实时监控服务(targets)的入口函数</li></ol><p><code>scrapeManager.Run(discoveryManagerScrape.SyncCh())</code></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">prometheus/cmd/prometheus/main.<span class="keyword">go</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Scrape manager.</span></span><br><span class="line">g.Add(</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// When the scrape manager receives a new targets list</span></span><br><span class="line"><span class="comment">// it needs to read a valid config for each job.</span></span><br><span class="line"><span class="comment">// It depends on the config being in sync with the discovery manager so</span></span><br><span class="line"><span class="comment">// we wait until the config is fully loaded.</span></span><br><span class="line">&lt;-reloadReady.C</span><br><span class="line"> </span><br><span class="line">err := scrapeManager.Run(discoveryManagerScrape.SyncCh())</span><br><span class="line">level.Info(logger).Log(<span class="string">"msg"</span>, <span class="string">"Scrape manager stopped"</span>)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line"><span class="comment">// Scrape manager needs to be stopped before closing the local TSDB</span></span><br><span class="line"><span class="comment">// so that it doesn't try to write samples to a closed storage.</span></span><br><span class="line">level.Info(logger).Log(<span class="string">"msg"</span>, <span class="string">"Stopping scrape manager..."</span>)</span><br><span class="line">scrapeManager.Stop()</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// ts即map[string][]*targetgroup.Group</span></span><br><span class="line">(dlv) p ts[<span class="string">"prometheus"</span>]</span><br><span class="line">[]*github.com/prometheus/prometheus/discovery/targetgroup.Group <span class="built_in">len</span>: <span class="number">1</span>, <span class="built_in">cap</span>: <span class="number">1</span>, [</span><br><span class="line">*&#123;</span><br><span class="line">Targets: []github.com/prometheus/common/model.LabelSet <span class="built_in">len</span>: <span class="number">1</span>, <span class="built_in">cap</span>: <span class="number">1</span>, [</span><br><span class="line">[...],</span><br><span class="line">],</span><br><span class="line">Labels: github.com/prometheus/common/model.LabelSet <span class="literal">nil</span>,</span><br><span class="line">Source: <span class="string">"0"</span>,&#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如配置文件中 scrape_configs 段是这样做的</span></span><br><span class="line">scrape_configs:</span><br><span class="line">  # The job name is added as a label <span class="string">`job=&lt;job_name&gt;`</span> to any timeseries scraped from this config.</span><br><span class="line">  - job_name: <span class="string">'prometheus'</span></span><br><span class="line">    static_configs:</span><br><span class="line">    - targets: [<span class="string">'localhost:9090'</span>, <span class="string">'192.168.1.2:9091'</span>]</span><br><span class="line">      labels:</span><br><span class="line">        cluster: es</span><br><span class="line">        env: prod</span><br><span class="line"><span class="comment">// 那么其中的 static_configs 会解析为</span></span><br><span class="line">targetgroup.Group&#123;</span><br><span class="line">Targets: []model.LabelSet&#123;</span><br><span class="line">model.LabelSet&#123;<span class="string">"__address__"</span>: <span class="string">"localhost:9090"</span>&#125;, </span><br><span class="line">model.LabelSet&#123;<span class="string">"__address__"</span>: <span class="string">"192.168.1.2:9091"</span>&#125;</span><br><span class="line">&#125;, </span><br><span class="line">Labels: model.LabelSet&#123;</span><br><span class="line"><span class="string">"cluster"</span>: <span class="string">"es"</span>, </span><br><span class="line"><span class="string">"env"</span>: <span class="string">"prod"</span></span><br><span class="line">&#125;, </span><br><span class="line">Source: <span class="string">""</span></span><br></pre></td></tr></table></figure><p>这里会起一个协程运行Run方法，从服务发现(serviceDiscover)实时获取被监控服务(targets)</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">prometheus/scrape/manager.<span class="keyword">go</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Run receives and saves target set updates and triggers the scraping loops reloading.</span></span><br><span class="line"><span class="comment">// Reloading happens in the background so that it doesn't block receiving targets updates.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Manager)</span> <span class="title">Run</span><span class="params">(tsets &lt;-<span class="keyword">chan</span> <span class="keyword">map</span>[<span class="keyword">string</span>][]*targetgroup.Group)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="comment">//定时(5s)更新服务(targets)，结合triggerReload一起使用，即每5s判断一次triggerReload是否更新．</span></span><br><span class="line"><span class="keyword">go</span> m.reloader() </span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="comment">//通过管道获取被监控的服务(targets)</span></span><br><span class="line"><span class="keyword">case</span> ts := &lt;-tsets:  </span><br><span class="line">m.updateTsets(ts)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">　　　 <span class="comment">//若从服务发现 (serviceDiscover)有服务(targets)变动，则给管道triggerReload传值，并触发reloader()方法更新服务．</span></span><br><span class="line"><span class="keyword">case</span> m.triggerReload &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;: </span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">case</span> &lt;-m.graceShut:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上流程还是比较清晰，若服务发现(serviceDiscovery)有服务(target)变动，Run方法就会向管道triggerReload注入值：</p><p>m.triggerReload &lt;- struct{}{}中，并起了一个协程，运行reloader方法．用于定时更新服务(targets)．启动这个协程应该是为了防止阻塞</p><p>从服务发现(serviceDiscover)获取变动的服务(targets)</p><p>reloader方法启动了一个定时器，在无限循环中每5s判断一下管道triggerReload，若有值，则执行reload方法</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">prometheus/scrape/manager.<span class="keyword">go</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Manager)</span> <span class="title">reloader</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//定时器5s</span></span><br><span class="line">ticker := time.NewTicker(<span class="number">5</span> * time.Second)</span><br><span class="line"><span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-m.graceShut:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">　      <span class="comment">// 若服务发现(serviceDiscovery)有服务(targets)变动，就会向管道triggerReload写入值，定时器每5s判断一次triggerReload管道是否有值，若有值，则触发reload方法</span></span><br><span class="line"><span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-m.triggerReload:</span><br><span class="line">m.reload()</span><br><span class="line"><span class="keyword">case</span> &lt;-m.graceShut:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reload方法会根据job_name比较targetSets，scrapePools和scrapeConfigs的一致性，并把每个job_name下的类型为</p><p>[]*targetgroup.Group的groups通过协程传给sp.Sync方法，增加并发</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line">prometheus/scrape/manager.<span class="keyword">go</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Manager)</span> <span class="title">reload</span><span class="params">()</span></span> &#123;</span><br><span class="line">m.mtxScrape.Lock()</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">  <span class="comment">//setName对应job_name，</span></span><br><span class="line">　<span class="comment">//group的结构体包含job_name对应的Targets，Labels和source</span></span><br><span class="line">  <span class="comment">// 遍历最新的抓取目标配置中的每个job 的 targetGroup</span></span><br><span class="line"><span class="keyword">for</span> setName, groups := <span class="keyword">range</span> m.targetSets &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//若该job_name不在scrapePools中，分为两种情况处理</span></span><br><span class="line">    <span class="comment">//(1)job_name不在scrapeConfigs中，则跳过</span></span><br><span class="line">    <span class="comment">//(2)job_name在scrapeConfigs中，则需要创建这个 job 的scrapePool，并把该job_name加到scrapePools中</span></span><br><span class="line"><span class="keyword">if</span> _, ok := m.scrapePools[setName]; !ok &#123;</span><br><span class="line">scrapeConfig, ok := m.scrapeConfigs[setName]</span><br><span class="line">      <span class="comment">// 抓取配置 m.scrapeConfigs 有没有这个 job 的配置，</span></span><br><span class="line"><span class="comment">// 解析配置的时候有可能出错，就会跳过出错的 job，这里再检查一下</span></span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">level.Error(m.logger).Log(<span class="string">"msg"</span>, <span class="string">"error reloading target set"</span>, <span class="string">"err"</span>, <span class="string">"invalid config id:"</span>+setName)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">// 创建这个 job 的scrapePool</span></span><br><span class="line">sp, err := newScrapePool(scrapeConfig, m.<span class="built_in">append</span>, m.jitterSeed, log.With(m.logger, <span class="string">"scrape_pool"</span>, setName))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">level.Error(m.logger).Log(<span class="string">"msg"</span>, <span class="string">"error creating new scrape pool"</span>, <span class="string">"err"</span>, err, <span class="string">"scrape_pool"</span>, setName)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">m.scrapePools[setName] = sp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// Run the sync in parallel as these take a while and at high load can't catch up.</span></span><br><span class="line">    <span class="comment">// 并发执行 scrapePool.Sync() 方法并等待全部执行完毕。</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(sp *scrapePool, groups []*targetgroup.Group)</span></span> &#123;</span><br><span class="line">      <span class="comment">//把groups转换为targets类型</span></span><br><span class="line">sp.Sync(groups)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;(m.scrapePools[setName], groups) <span class="comment">// 如果已经有这个 job 就启动，所以此处不用 sp 而用m.scrapePools[setName]</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">m.mtxScrape.Unlock()</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建这个 job 的scrapePool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newScrapePool</span><span class="params">(cfg *config.ScrapeConfig, app storage.Appendable, jitterSeed <span class="keyword">uint64</span>, logger log.Logger)</span> <span class="params">(*scrapePool, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// target_scrape_pools 数量统计，每个 job 一个池</span></span><br><span class="line">targetScrapePools.Inc()</span><br><span class="line"><span class="keyword">if</span> logger == <span class="literal">nil</span> &#123;</span><br><span class="line">logger = log.NewNopLogger()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据配置创建 http client</span></span><br><span class="line">client, err := config_util.NewClientFromConfig(cfg.HTTPClientConfig, cfg.JobName, config_util.WithHTTP2Disabled())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">targetScrapePoolsFailed.Inc()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">"error creating HTTP client"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// pool.New 返回一个分桶的 sync.Pool</span></span><br><span class="line">buffers := pool.New(<span class="number">1e3</span>, <span class="number">100e6</span>, <span class="number">3</span>, <span class="function"><span class="keyword">func</span><span class="params">(sz <span class="keyword">int</span>)</span> <span class="title">interface</span></span>&#123;&#125; &#123; <span class="keyword">return</span> <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>, sz) &#125;)</span><br><span class="line"></span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">  </span><br><span class="line">sp := &amp;scrapePool&#123;</span><br><span class="line">cancel:        cancel,</span><br><span class="line">appendable:    app,</span><br><span class="line">config:        cfg,</span><br><span class="line">client:        client,</span><br><span class="line">activeTargets: <span class="keyword">map</span>[<span class="keyword">uint64</span>]*Target&#123;&#125;,</span><br><span class="line">loops:         <span class="keyword">map</span>[<span class="keyword">uint64</span>]loop&#123;&#125;,</span><br><span class="line">logger:        logger,</span><br><span class="line">&#125;</span><br><span class="line">sp.newLoop = <span class="function"><span class="keyword">func</span><span class="params">(opts scrapeLoopOptions)</span> <span class="title">loop</span></span> &#123;</span><br><span class="line"><span class="comment">// Update the targets retrieval function for metadata to a new scrape cache.</span></span><br><span class="line">cache := opts.cache</span><br><span class="line"><span class="keyword">if</span> cache == <span class="literal">nil</span> &#123;</span><br><span class="line">cache = newScrapeCache()</span><br><span class="line">&#125;</span><br><span class="line">opts.target.SetMetadataStore(cache)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newScrapeLoop(</span><br><span class="line">ctx,</span><br><span class="line">opts.scraper,</span><br><span class="line">log.With(logger, <span class="string">"target"</span>, opts.target),</span><br><span class="line">buffers,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(l labels.Labels)</span> <span class="title">labels</span>.<span class="title">Labels</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> mutateSampleLabels(l, opts.target, opts.honorLabels, opts.mrc)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(l labels.Labels)</span> <span class="title">labels</span>.<span class="title">Labels</span></span> &#123; <span class="keyword">return</span> mutateReportSampleLabels(l, opts.target) &#125;,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span> <span class="title">storage</span>.<span class="title">Appender</span></span> &#123; <span class="keyword">return</span> appender(app.Appender(ctx), opts.sampleLimit) &#125;,</span><br><span class="line">cache,</span><br><span class="line">jitterSeed,</span><br><span class="line">opts.honorTimestamps,</span><br><span class="line">opts.labelLimits,</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sp, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// scrapePool manages scrapes for sets of targets.</span></span><br><span class="line"><span class="keyword">type</span> scrapePool <span class="keyword">struct</span> &#123;</span><br><span class="line">appendable Appendable</span><br><span class="line">logger     log.Logger</span><br><span class="line"></span><br><span class="line">mtx    sync.RWMutex</span><br><span class="line">config *config.ScrapeConfig</span><br><span class="line">client *http.Client</span><br><span class="line"><span class="comment">// Targets and loops must always be synchronized to have the same</span></span><br><span class="line"><span class="comment">// set of hashes.</span></span><br><span class="line">targets        <span class="keyword">map</span>[<span class="keyword">uint64</span>]*Target</span><br><span class="line">droppedTargets []*Target</span><br><span class="line">loops          <span class="keyword">map</span>[<span class="keyword">uint64</span>]loop</span><br><span class="line">cancel         context.CancelFunc</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constructor for new scrape loops. This is settable for testing convenience.</span></span><br><span class="line">newLoop <span class="function"><span class="keyword">func</span><span class="params">(*Target, scraper, <span class="keyword">int</span>, <span class="keyword">bool</span>, []*config.RelabelConfig)</span> </span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function">//<span class="title">scrapePool</span>管理一组对象的数据采集，其中的<span class="title">targets</span>和<span class="title">loops</span>都是<span class="title">map</span>，<span class="title">key</span>是一种<span class="title">hash</span>，<span class="title">value</span>分别是<span class="title">Target</span>和<span class="title">loop</span>，<span class="title">Target</span>和<span class="title">loop</span>存在一一对应的关系，<span class="title">Target</span>表示数据采集的对象，而<span class="title">loop</span>是个接口</span></span><br><span class="line"><span class="function">// <span class="title">A</span> <span class="title">loop</span> <span class="title">can</span> <span class="title">run</span> <span class="title">and</span> <span class="title">be</span> <span class="title">stopped</span> <span class="title">again</span>. <span class="title">It</span> <span class="title">must</span> <span class="title">not</span> <span class="title">be</span> <span class="title">reused</span> <span class="title">after</span> <span class="title">it</span> <span class="title">was</span> <span class="title">stopped</span>.</span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">loop</span> <span class="title">interface</span></span> &#123;</span><br><span class="line">run(interval, timeout time.Duration, errc <span class="keyword">chan</span>&lt;- error)</span><br><span class="line">stop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中 scrapeCache 是跟踪暴露的指标字符串到标签集和存储直接按的映射的， 此外它还跟踪相邻两次抓取之间的腐化情况</span></span><br><span class="line"><span class="comment">// scrapeCache tracks mappings of exposed metric strings to label sets and</span></span><br><span class="line"><span class="comment">// storage references. Additionally, it tracks staleness of series between</span></span><br><span class="line"><span class="comment">// scrapes.</span></span><br><span class="line"><span class="keyword">type</span> scrapeCache <span class="keyword">struct</span> &#123;</span><br><span class="line">iter <span class="keyword">uint64</span> <span class="comment">// Current scrape iteration. 当前抓取的迭代序号。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// How many series and metadata entries there were at the last success.</span></span><br><span class="line"><span class="comment">// 最后一次成功抓取的时序和元数据项</span></span><br><span class="line">successfulCount <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Parsed string to an entry with information about the actual label set</span></span><br><span class="line"><span class="comment">// and its storage reference.</span></span><br><span class="line"><span class="comment">// 将字符串解析为标签信息,key是metric,value是cacheEntry结构体</span></span><br><span class="line">series <span class="keyword">map</span>[<span class="keyword">string</span>]*cacheEntry</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cache of dropped metric strings and their iteration. The iteration must</span></span><br><span class="line"><span class="comment">// be a pointer so we can update it without setting a new entry with an unsafe</span></span><br><span class="line"><span class="comment">// string in addDropped().</span></span><br><span class="line"><span class="comment">// 丢弃的指标字符串和他们的迭代序号,缓存不合法指标(metrics)</span></span><br><span class="line">droppedSeries <span class="keyword">map</span>[<span class="keyword">string</span>]*<span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// seriesCur and seriesPrev store the labels of series that were seen</span></span><br><span class="line"><span class="comment">// in the current and previous scrape.</span></span><br><span class="line"><span class="comment">// We hold two maps and swap them out to save allocations.</span></span><br><span class="line"><span class="comment">// 当前抓取和上次抓取中见到的标签集，两个映射轮换可以节省分配。</span></span><br><span class="line">seriesCur  <span class="keyword">map</span>[<span class="keyword">uint64</span>]labels.Labels <span class="comment">//缓存本次scrape的指标(metrics)</span></span><br><span class="line">seriesPrev <span class="keyword">map</span>[<span class="keyword">uint64</span>]labels.Labels <span class="comment">//缓存上次scrape的指标(metrics)</span></span><br><span class="line"></span><br><span class="line">metaMtx  sync.Mutex <span class="comment">//同步锁</span></span><br><span class="line">metadata <span class="keyword">map</span>[<span class="keyword">string</span>]*metaEntry <span class="comment">//元数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sp.Sync方法引入了Target结构体，把[]*targetgroup.Group类型的groups转换为targets类型，其中每个groups对应一个job_name下多</p><p>个targets．随后，调用sp.sync方法，同步scrape服务</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sync converts target groups into actual scrape targets and synchronizes</span></span><br><span class="line"><span class="comment">// the currently running scraper with the resulting set and returns all scraped and dropped targets.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sp *scrapePool)</span> <span class="title">Sync</span><span class="params">(tgs []*targetgroup.Group)</span></span> &#123;</span><br><span class="line">sp.mtx.Lock()</span><br><span class="line"><span class="keyword">defer</span> sp.mtx.Unlock()</span><br><span class="line">start := time.Now()</span><br><span class="line"></span><br><span class="line">sp.targetMtx.Lock()</span><br><span class="line"><span class="keyword">var</span> all []*Target</span><br><span class="line">sp.droppedTargets = []*Target&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, tg := <span class="keyword">range</span> tgs &#123;</span><br><span class="line">    <span class="comment">// 转换targetgroup.Group类型为Target</span></span><br><span class="line">targets, err := targetsFromGroup(tg, sp.config)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">level.Error(sp.logger).Log(<span class="string">"msg"</span>, <span class="string">"creating targets failed"</span>, <span class="string">"err"</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, t := <span class="keyword">range</span> targets &#123;</span><br><span class="line">      <span class="comment">// 判断Target的有效label是否大于0</span></span><br><span class="line"><span class="keyword">if</span> t.Labels().Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">all = <span class="built_in">append</span>(all, t)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> t.DiscoveredLabels().Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 若为无效Target，则加入scrapeLoop的droppedTargets中</span></span><br><span class="line">sp.droppedTargets = <span class="built_in">append</span>(sp.droppedTargets, t)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sp.targetMtx.Unlock()</span><br><span class="line">sp.sync(all)</span><br><span class="line"></span><br><span class="line">targetSyncIntervalLength.WithLabelValues(sp.config.JobName).Observe(</span><br><span class="line">time.Since(start).Seconds(),</span><br><span class="line">)</span><br><span class="line">targetScrapePoolSyncsCounter.WithLabelValues(sp.config.JobName).Inc()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scrape.Target 是一次抓取的具体对象，包含了抓取和抓取后存储所需要的全部信息。从 targetGroup.Group 到 scrape.Target 的转换过程如下：</p><ol><li><p>targetsFromGroup函数遍历每个targetGroup.Group中的Target，合并targetGroup.Group的公共标签集（记为A）和这个Target本身的标签集（记为B）为标签集C。</p></li><li><p>populateLabels函数从C和*config.ScrapeConfig中创建Target。</p></li></ol><p>Target结构体以及方法定义</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TargetHealth describes the health state of a target.</span></span><br><span class="line"><span class="keyword">type</span> TargetHealth <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The possible health states of a target based on the last performed scrape.</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">HealthUnknown TargetHealth = <span class="string">"unknown"</span></span><br><span class="line">HealthGood    TargetHealth = <span class="string">"up"</span></span><br><span class="line">HealthBad     TargetHealth = <span class="string">"down"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Target refers to a singular HTTP or HTTPS endpoint.</span></span><br><span class="line"><span class="keyword">type</span> Target <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Labels before any processing.</span></span><br><span class="line"><span class="comment">// 未经处理的抓取到的原始标签集</span></span><br><span class="line">discoveredLabels labels.Labels</span><br><span class="line"><span class="comment">// Any labels that are added to this target and its metrics.</span></span><br><span class="line"><span class="comment">// 经过 relabel 处理后的标签集，会记录进 TSDB</span></span><br><span class="line">labels labels.Labels</span><br><span class="line"><span class="comment">// Additional URL parameters that are part of the target URL.</span></span><br><span class="line"><span class="comment">// 目标 URL 的额外参数</span></span><br><span class="line">params url.Values</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读写锁保护下面的变量</span></span><br><span class="line">mtx                sync.RWMutex</span><br><span class="line"><span class="comment">// 最后一次抓取的错误值</span></span><br><span class="line">lastError          error</span><br><span class="line"><span class="comment">// 最后一次抓取的时间</span></span><br><span class="line">lastScrape         time.Time</span><br><span class="line"><span class="comment">// 最后一次抓取的耗时</span></span><br><span class="line">lastScrapeDuration time.Duration</span><br><span class="line"><span class="comment">// 目标的健康状态</span></span><br><span class="line">health             TargetHealth</span><br><span class="line"><span class="comment">// 标签的元数据</span></span><br><span class="line">metadata           MetricMetadataStore</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewTarget creates a reasonably configured target for querying.</span></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTarget</span><span class="params">(labels, discoveredLabels labels.Labels, params url.Values)</span> *<span class="title">Target</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Target&#123;</span><br><span class="line">labels:           labels,</span><br><span class="line">discoveredLabels: discoveredLabels,</span><br><span class="line">params:           params,</span><br><span class="line">health:           HealthUnknown,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Target)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> t.URL().String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MetricMetadataStore represents a storage for metadata.</span></span><br><span class="line"><span class="comment">// MetricMetadataStore 接口代表元数据的存储</span></span><br><span class="line"><span class="keyword">type</span> MetricMetadataStore <span class="keyword">interface</span> &#123;</span><br><span class="line">ListMetadata() []MetricMetadata</span><br><span class="line">GetMetadata(metric <span class="keyword">string</span>) (MetricMetadata, <span class="keyword">bool</span>)</span><br><span class="line">SizeMetadata() <span class="keyword">int</span></span><br><span class="line">LengthMetadata() <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MetricMetadata is a piece of metadata for a metric.</span></span><br><span class="line"><span class="comment">// MetricMetadata 是一个指标的元数据。</span></span><br><span class="line"><span class="comment">// 包括指标名、指标类型、帮助信息（这三项在用客户端写观测指标时都要写）</span></span><br><span class="line"><span class="comment">// 和指标单位。</span></span><br><span class="line"><span class="keyword">type</span> MetricMetadata <span class="keyword">struct</span> &#123;</span><br><span class="line">Metric <span class="keyword">string</span></span><br><span class="line">Type   textparse.MetricType</span><br><span class="line">Help   <span class="keyword">string</span></span><br><span class="line">Unit   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// target 有 MetadataList()、MetadataSize()、MetadataLength() 和 Metadata() 方法，</span></span><br><span class="line"><span class="comment">// 获取元数据的一些信息，这些方法内部就是加读锁调用 metadata 字段的相对应的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Target)</span> <span class="title">MetadataList</span><span class="params">()</span> []<span class="title">MetricMetadata</span></span> &#123;</span><br><span class="line">t.mtx.RLock()</span><br><span class="line"><span class="keyword">defer</span> t.mtx.RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> t.metadata == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t.metadata.ListMetadata()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Target)</span> <span class="title">MetadataSize</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">t.mtx.RLock()</span><br><span class="line"><span class="keyword">defer</span> t.mtx.RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> t.metadata == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> t.metadata.SizeMetadata()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Target)</span> <span class="title">MetadataLength</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">t.mtx.RLock()</span><br><span class="line"><span class="keyword">defer</span> t.mtx.RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> t.metadata == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> t.metadata.LengthMetadata()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Metadata returns type and help metadata for the given metric.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Target)</span> <span class="title">Metadata</span><span class="params">(metric <span class="keyword">string</span>)</span> <span class="params">(MetricMetadata, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">t.mtx.RLock()</span><br><span class="line"><span class="keyword">defer</span> t.mtx.RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> t.metadata == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> MetricMetadata&#123;&#125;, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t.metadata.GetMetadata(metric)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置元数据，参数是个接口类型，也就是实现了接口方法的结构体</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Target)</span> <span class="title">SetMetadataStore</span><span class="params">(s MetricMetadataStore)</span></span> &#123;</span><br><span class="line">t.mtx.Lock()</span><br><span class="line"><span class="keyword">defer</span> t.mtx.Unlock()</span><br><span class="line">t.metadata = s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hash returns an identifying hash for the target.</span></span><br><span class="line"><span class="comment">// 用于得到一个目标的唯一标识。FVN-1a 是一个简单的非加密哈希算法，性能较高，碰撞率较低。</span></span><br><span class="line"><span class="comment">// 该方法用目标的标签集的哈希值和目标的端点 URL 作为参数计算哈希值，其中标签集的哈希值使用 xxHash 算法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Target)</span> <span class="title">hash</span><span class="params">()</span> <span class="title">uint64</span></span> &#123;</span><br><span class="line">h := fnv.New64a()</span><br><span class="line"><span class="comment">//nolint: errcheck</span></span><br><span class="line">h.Write([]<span class="keyword">byte</span>(fmt.Sprintf(<span class="string">"%016d"</span>, t.labels.Hash())))</span><br><span class="line"><span class="comment">//nolint: errcheck</span></span><br><span class="line">h.Write([]<span class="keyword">byte</span>(t.URL().String()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> h.Sum64()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// offset returns the time until the next scrape cycle for the target.</span></span><br><span class="line"><span class="comment">// It includes the global server jitterSeed for scrapes from multiple Prometheus to try to be at different times.</span></span><br><span class="line"><span class="comment">// 得到距离目标开始下一次抓取循环的时间。参数中包含一个随机数，用于打散抓取开始时间，均匀化 Prometheus 的负载</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Target)</span> <span class="title">offset</span><span class="params">(interval time.Duration, jitterSeed <span class="keyword">uint64</span>)</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123;</span><br><span class="line">now := time.Now().UnixNano()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Base is a pinned to absolute time, no matter how often offset is called.</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">base   = <span class="keyword">int64</span>(interval) - now%<span class="keyword">int64</span>(interval)</span><br><span class="line">offset = (t.hash() ^ jitterSeed) % <span class="keyword">uint64</span>(interval)</span><br><span class="line">next   = base + <span class="keyword">int64</span>(offset)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> next &gt; <span class="keyword">int64</span>(interval) &#123;</span><br><span class="line">next -= <span class="keyword">int64</span>(interval)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> time.Duration(next)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Labels returns a copy of the set of all public labels of the target.</span></span><br><span class="line"><span class="comment">// Labels()、DiscoveredLabels()、SetDiscoveredLabels(l labels.Labels) 分别用于获取目标的非元信息</span></span><br><span class="line"><span class="comment">// （不以“————”开头）标签集、relabel 前的原始标签集和设置 relabel 前的原始标签集。需要注意的是 Labels() 方法没有加锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Target)</span> <span class="title">Labels</span><span class="params">()</span> <span class="title">labels</span>.<span class="title">Labels</span></span> &#123;</span><br><span class="line">lset := <span class="built_in">make</span>(labels.Labels, <span class="number">0</span>, <span class="built_in">len</span>(t.labels))</span><br><span class="line"><span class="keyword">for</span> _, l := <span class="keyword">range</span> t.labels &#123;</span><br><span class="line"><span class="keyword">if</span> !strings.HasPrefix(l.Name, model.ReservedLabelPrefix) &#123;</span><br><span class="line">lset = <span class="built_in">append</span>(lset, l)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> lset</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DiscoveredLabels returns a copy of the target's labels before any processing.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Target)</span> <span class="title">DiscoveredLabels</span><span class="params">()</span> <span class="title">labels</span>.<span class="title">Labels</span></span> &#123;</span><br><span class="line">t.mtx.Lock()</span><br><span class="line"><span class="keyword">defer</span> t.mtx.Unlock()</span><br><span class="line">lset := <span class="built_in">make</span>(labels.Labels, <span class="built_in">len</span>(t.discoveredLabels))</span><br><span class="line"><span class="built_in">copy</span>(lset, t.discoveredLabels)</span><br><span class="line"><span class="keyword">return</span> lset</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetDiscoveredLabels sets new DiscoveredLabels</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Target)</span> <span class="title">SetDiscoveredLabels</span><span class="params">(l labels.Labels)</span></span> &#123;</span><br><span class="line">t.mtx.Lock()</span><br><span class="line"><span class="keyword">defer</span> t.mtx.Unlock()</span><br><span class="line">t.discoveredLabels = l</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// URL returns a copy of the target's URL.</span></span><br><span class="line"><span class="comment">// URL() 方法组装 net/url.URL</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Target)</span> <span class="title">URL</span><span class="params">()</span> *<span class="title">url</span>.<span class="title">URL</span></span> &#123;</span><br><span class="line">params := url.Values&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> t.params &#123;</span><br><span class="line">params[k] = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(v))</span><br><span class="line"><span class="built_in">copy</span>(params[k], v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 url 参数相关的标签添加到参数中</span></span><br><span class="line"><span class="keyword">for</span> _, l := <span class="keyword">range</span> t.labels &#123;</span><br><span class="line"><span class="keyword">if</span> !strings.HasPrefix(l.Name, model.ParamLabelPrefix) &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">ks := l.Name[<span class="built_in">len</span>(model.ParamLabelPrefix):]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(params[ks]) &gt; <span class="number">0</span> &#123;</span><br><span class="line">params[ks][<span class="number">0</span>] = l.Value</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">params[ks] = []<span class="keyword">string</span>&#123;l.Value&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;url.URL&#123;</span><br><span class="line">Scheme:   t.labels.Get(model.SchemeLabel),</span><br><span class="line">Host:     t.labels.Get(model.AddressLabel),</span><br><span class="line">Path:     t.labels.Get(model.MetricsPathLabel),</span><br><span class="line">RawQuery: params.Encode(),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Report sets target data about the last scrape.</span></span><br><span class="line"><span class="comment">// Report() 设置最后一次抓取的结构体字段值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Target)</span> <span class="title">Report</span><span class="params">(start time.Time, dur time.Duration, err error)</span></span> &#123;</span><br><span class="line">t.mtx.Lock()</span><br><span class="line"><span class="keyword">defer</span> t.mtx.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">t.health = HealthGood</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">t.health = HealthBad</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t.lastError = err</span><br><span class="line">t.lastScrape = start</span><br><span class="line">t.lastScrapeDuration = dur</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LastError returns the error encountered during the last scrape.</span></span><br><span class="line"><span class="comment">// LastError()、LastScrape()、LastScrapeDuration()、Health()</span></span><br><span class="line"><span class="comment">// 方法加读锁获取结构体最后一次抓取的错误、最后一次抓取的时间、最后一次抓取的耗时和最后一次抓取目标的状态字段</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Target)</span> <span class="title">LastError</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">t.mtx.RLock()</span><br><span class="line"><span class="keyword">defer</span> t.mtx.RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> t.lastError</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LastScrape returns the time of the last scrape.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Target)</span> <span class="title">LastScrape</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Time</span></span> &#123;</span><br><span class="line">t.mtx.RLock()</span><br><span class="line"><span class="keyword">defer</span> t.mtx.RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> t.lastScrape</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LastScrapeDuration returns how long the last scrape of the target took.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Target)</span> <span class="title">LastScrapeDuration</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123;</span><br><span class="line">t.mtx.RLock()</span><br><span class="line"><span class="keyword">defer</span> t.mtx.RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> t.lastScrapeDuration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Health returns the last known health state of the target.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Target)</span> <span class="title">Health</span><span class="params">()</span> <span class="title">TargetHealth</span></span> &#123;</span><br><span class="line">t.mtx.RLock()</span><br><span class="line"><span class="keyword">defer</span> t.mtx.RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> t.health</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Targets is a sortable list of targets.</span></span><br><span class="line"><span class="comment">// 是一个实现了 sort 接口的 Target 指针切片，排序依据是 URL 字符串</span></span><br><span class="line"><span class="keyword">type</span> Targets []*Target</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts Targets)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(ts) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts Targets)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> ts[i].URL().String() &lt; ts[j].URL().String() &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ts Targets)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; ts[i], ts[j] = ts[j], ts[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> errSampleLimit = errors.New(<span class="string">"sample limit exceeded"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// limitAppender limits the number of total appended samples in a batch.</span></span><br><span class="line"><span class="comment">// limitAppender 结构体限制一次批量追加的样本数</span></span><br><span class="line"><span class="keyword">type</span> limitAppender <span class="keyword">struct</span> &#123;</span><br><span class="line">storage.Appender</span><br><span class="line"></span><br><span class="line">limit <span class="keyword">int</span></span><br><span class="line">i     <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(app *limitAppender)</span> <span class="title">Append</span><span class="params">(ref <span class="keyword">uint64</span>, lset labels.Labels, t <span class="keyword">int64</span>, v <span class="keyword">float64</span>)</span> <span class="params">(<span class="keyword">uint64</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> !value.IsStaleNaN(v) &#123;</span><br><span class="line">app.i++</span><br><span class="line"><span class="keyword">if</span> app.i &gt; app.limit &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, errSampleLimit</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ref, err := app.Appender.Append(ref, lset, t, v)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ref, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// timeLimitAppender 结构体是限制插入时间的，如果要追加的样本时间戳超过限制就返回错误</span></span><br><span class="line"><span class="keyword">type</span> timeLimitAppender <span class="keyword">struct</span> &#123;</span><br><span class="line">storage.Appender</span><br><span class="line"></span><br><span class="line">maxTime <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(app *timeLimitAppender)</span> <span class="title">Append</span><span class="params">(ref <span class="keyword">uint64</span>, lset labels.Labels, t <span class="keyword">int64</span>, v <span class="keyword">float64</span>)</span> <span class="params">(<span class="keyword">uint64</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> t &gt; app.maxTime &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, storage.ErrOutOfBounds</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ref, err := app.Appender.Append(ref, lset, t, v)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ref, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// populateLabels builds a label set from the given label set and scrape configuration.</span></span><br><span class="line"><span class="comment">// It returns a label set before relabeling was applied as the second return value.</span></span><br><span class="line"><span class="comment">// Returns the original discovered label set found before relabelling was applied if the target is dropped during relabeling.</span></span><br><span class="line"><span class="comment">// populateLabels 函数从给定的标签集和抓取配置中构造一个标签集。返回的第二个值是 relabel 之前的标签集。</span></span><br><span class="line"><span class="comment">// 如果目标在 rebalel 期间被丢弃，就返回 relabel 之前的原始标签集</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">populateLabels</span><span class="params">(lset labels.Labels, cfg *config.ScrapeConfig)</span> <span class="params">(res, orig labels.Labels, err error)</span></span> &#123;</span><br><span class="line"><span class="comment">// Copy labels into the labelset for the target if they are not set already.</span></span><br><span class="line">scrapeLabels := []labels.Label&#123;</span><br><span class="line">&#123;Name: model.JobLabel, Value: cfg.JobName&#125;,</span><br><span class="line">&#123;Name: model.MetricsPathLabel, Value: cfg.MetricsPath&#125;,</span><br><span class="line">&#123;Name: model.SchemeLabel, Value: cfg.Scheme&#125;,</span><br><span class="line">&#125;</span><br><span class="line">lb := labels.NewBuilder(lset)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果参数标签集 lset 中不含有 job、metricPath 和 scheme 标签就把它们添加进去</span></span><br><span class="line"><span class="keyword">for</span> _, l := <span class="keyword">range</span> scrapeLabels &#123;</span><br><span class="line"><span class="keyword">if</span> lv := lset.Get(l.Name); lv == <span class="string">""</span> &#123;</span><br><span class="line">lb.Set(l.Name, l.Value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Encode scrape query parameters as labels.</span></span><br><span class="line"><span class="comment">// 添加 url 参数标签</span></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> cfg.Params &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(v) &gt; <span class="number">0</span> &#123;</span><br><span class="line">lb.Set(model.ParamLabelPrefix+k, v[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// relabel 之前的标签集</span></span><br><span class="line">preRelabelLabels := lb.Labels()</span><br><span class="line"><span class="comment">// 应用 relabel</span></span><br><span class="line">lset = relabel.Process(preRelabelLabels, cfg.RelabelConfigs...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if the target was dropped.</span></span><br><span class="line"><span class="comment">// 如果 relabel 把这个标签集丢弃了就返回 relabel 之前的标签集</span></span><br><span class="line"><span class="keyword">if</span> lset == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, preRelabelLabels, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果 relabel 后 __address__ 标签没有了就返回错误</span></span><br><span class="line"><span class="keyword">if</span> v := lset.Get(model.AddressLabel); v == <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, errors.New(<span class="string">"no address"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lb = labels.NewBuilder(lset)</span><br><span class="line"></span><br><span class="line"><span class="comment">// addPort checks whether we should add a default port to the address.</span></span><br><span class="line"><span class="comment">// If the address is not valid, we don't append a port either.</span></span><br><span class="line"><span class="comment">// addPort 检查是否需要为地址添加默认端口。如果地址不合法，也不添加端口</span></span><br><span class="line">addPort := <span class="function"><span class="keyword">func</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">// If we can split, a port exists and we don't have to add one.</span></span><br><span class="line"><span class="comment">// 有端口就不用添加了</span></span><br><span class="line"><span class="keyword">if</span> _, _, err := net.SplitHostPort(s); err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// If adding a port makes it valid, the previous error</span></span><br><span class="line"><span class="comment">// was not due to an invalid address and we can append a port.</span></span><br><span class="line"><span class="comment">// 如果添加以后不合法就可以添加</span></span><br><span class="line">_, _, err := net.SplitHostPort(s + <span class="string">":1234"</span>)</span><br><span class="line"><span class="keyword">return</span> err == <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">addr := lset.Get(model.AddressLabel)</span><br><span class="line"><span class="comment">// If it's an address with no trailing port, infer it based on the used scheme.</span></span><br><span class="line"><span class="comment">// __address__ 标签如果没有端口就根据 http 或 https 推断一个默认值</span></span><br><span class="line"><span class="keyword">if</span> addPort(addr) &#123;</span><br><span class="line"><span class="comment">// Addresses reaching this point are already wrapped in [] if necessary.</span></span><br><span class="line"><span class="keyword">switch</span> lset.Get(model.SchemeLabel) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"http"</span>, <span class="string">""</span>:</span><br><span class="line">addr = addr + <span class="string">":80"</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"https"</span>:</span><br><span class="line">addr = addr + <span class="string">":443"</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, errors.Errorf(<span class="string">"invalid scheme: %q"</span>, cfg.Scheme)</span><br><span class="line">&#125;</span><br><span class="line">lb.Set(model.AddressLabel, addr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查地址标签的值是否是合法地址</span></span><br><span class="line"><span class="keyword">if</span> err := config.CheckTargetAddress(model.LabelValue(addr)); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Meta labels are deleted after relabelling. Other internal labels propagate to</span></span><br><span class="line"><span class="comment">// the target which decides whether they will be part of their label set.</span></span><br><span class="line"><span class="comment">// relabel 以后删除 __meta_ 开头的标签。其他的内部标签保留</span></span><br><span class="line"><span class="keyword">for</span> _, l := <span class="keyword">range</span> lset &#123;</span><br><span class="line"><span class="keyword">if</span> strings.HasPrefix(l.Name, model.MetaLabelPrefix) &#123;</span><br><span class="line">lb.Del(l.Name)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Default the instance label to the target address.</span></span><br><span class="line"><span class="comment">// instance 标签为空就设置为地址</span></span><br><span class="line"><span class="keyword">if</span> v := lset.Get(model.InstanceLabel); v == <span class="string">""</span> &#123;</span><br><span class="line">lb.Set(model.InstanceLabel, addr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终标签集</span></span><br><span class="line">res = lb.Labels()</span><br><span class="line"><span class="comment">// 最后检查一遍，标签值必须都是合法的 UTF8 字符</span></span><br><span class="line"><span class="keyword">for</span> _, l := <span class="keyword">range</span> res &#123;</span><br><span class="line"><span class="comment">// Check label values are valid, drop the target if not.</span></span><br><span class="line"><span class="keyword">if</span> !model.LabelValue(l.Value).IsValid() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, errors.Errorf(<span class="string">"invalid label value for %q: %q"</span>, l.Name, l.Value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res, preRelabelLabels, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// targetsFromGroup builds targets based on the given TargetGroup and config.</span></span><br><span class="line"><span class="comment">// targetGroup.Group 在 prometheus/discovery/targetgroup/targetgroup.go 中，</span></span><br><span class="line"><span class="comment">// Target 在 prometheus/scrape/target.go 中。这是从服务发现到抓取目标的转换</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">targetsFromGroup</span><span class="params">(tg *targetgroup.Group, cfg *config.ScrapeConfig)</span> <span class="params">([]*Target, error)</span></span> &#123;</span><br><span class="line">targets := <span class="built_in">make</span>([]*Target, <span class="number">0</span>, <span class="built_in">len</span>(tg.Targets))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, tlset := <span class="keyword">range</span> tg.Targets &#123;</span><br><span class="line"><span class="comment">// tlset 是这个目标独有的标签，tg.Labels 是这个 group 公共的标签</span></span><br><span class="line">lbls := <span class="built_in">make</span>([]labels.Label, <span class="number">0</span>, <span class="built_in">len</span>(tlset)+<span class="built_in">len</span>(tg.Labels))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ln, lv := <span class="keyword">range</span> tlset &#123;</span><br><span class="line">lbls = <span class="built_in">append</span>(lbls, labels.Label&#123;Name: <span class="keyword">string</span>(ln), Value: <span class="keyword">string</span>(lv)&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> ln, lv := <span class="keyword">range</span> tg.Labels &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := tlset[ln]; !ok &#123;</span><br><span class="line">lbls = <span class="built_in">append</span>(lbls, labels.Label&#123;Name: <span class="keyword">string</span>(ln), Value: <span class="keyword">string</span>(lv)&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lset := labels.New(lbls...)</span><br><span class="line"></span><br><span class="line">lbls, origLabels, err := populateLabels(lset, cfg)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrapf(err, <span class="string">"instance %d in group %s"</span>, i, tg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> lbls != <span class="literal">nil</span> || origLabels != <span class="literal">nil</span> &#123;</span><br><span class="line">targets = <span class="built_in">append</span>(targets, NewTarget(lbls, origLabels, cfg.Params))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> targets, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sp.sync方法对比新的Target列表和原来的Target列表，若发现不在原来的Target列表中，则新建该targets的scrapeLoop，通过协程启动</p><p>scrapeLoop的run方法，并发采集存储指标．然后判断原来的Target列表是否存在失效的Target，若存在，则移除</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sync takes a list of potentially duplicated targets, deduplicates them, starts</span></span><br><span class="line"><span class="comment">// scrape loops for new targets, and stops scrape loops for disappeared targets.</span></span><br><span class="line"><span class="comment">// It returns after all stopped scrape loops terminated.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sp *scrapePool)</span> <span class="title">sync</span><span class="params">(targets []*Target)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">uniqueLoops = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">uint64</span>]loop)</span><br><span class="line">interval    = time.Duration(sp.config.ScrapeInterval) <span class="comment">// 指标采集周期</span></span><br><span class="line">timeout     = time.Duration(sp.config.ScrapeTimeout) <span class="comment">// 指标采集超时时间</span></span><br><span class="line">sampleLimit = <span class="keyword">int</span>(sp.config.SampleLimit)</span><br><span class="line">labelLimits = &amp;labelLimits&#123;</span><br><span class="line">labelLimit:            <span class="keyword">int</span>(sp.config.LabelLimit),</span><br><span class="line">labelNameLengthLimit:  <span class="keyword">int</span>(sp.config.LabelNameLengthLimit),</span><br><span class="line">labelValueLengthLimit: <span class="keyword">int</span>(sp.config.LabelValueLengthLimit),</span><br><span class="line">&#125;</span><br><span class="line">honorLabels     = sp.config.HonorLabels</span><br><span class="line">honorTimestamps = sp.config.HonorTimestamps</span><br><span class="line">mrc             = sp.config.MetricRelabelConfigs</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">sp.targetMtx.Lock()</span><br><span class="line"><span class="keyword">for</span> _, t := <span class="keyword">range</span> targets &#123;</span><br><span class="line">hash := t.hash()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若发现不在原来的Target列表中，则新建该target的scrapeLoop</span></span><br><span class="line"><span class="keyword">if</span> _, ok := sp.activeTargets[hash]; !ok &#123;</span><br><span class="line">s := &amp;targetScraper&#123;Target: t, client: sp.client, timeout: timeout&#125;</span><br><span class="line">l := sp.newLoop(scrapeLoopOptions&#123;</span><br><span class="line">target:          t,</span><br><span class="line">scraper:         s,</span><br><span class="line">sampleLimit:     sampleLimit,</span><br><span class="line">labelLimits:     labelLimits,</span><br><span class="line">honorLabels:     honorLabels,</span><br><span class="line">honorTimestamps: honorTimestamps,</span><br><span class="line">mrc:             mrc,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">sp.activeTargets[hash] = t</span><br><span class="line">sp.loops[hash] = l</span><br><span class="line"></span><br><span class="line">uniqueLoops[hash] = l</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// This might be a duplicated target.</span></span><br><span class="line"><span class="keyword">if</span> _, ok := uniqueLoops[hash]; !ok &#123;</span><br><span class="line">uniqueLoops[hash] = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Need to keep the most updated labels information</span></span><br><span class="line"><span class="comment">// for displaying it in the Service Discovery web page.</span></span><br><span class="line">sp.activeTargets[hash].SetDiscoveredLabels(t.DiscoveredLabels())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stop and remove old targets and scraper loops.</span></span><br><span class="line">  <span class="comment">// 判断原来的Target列表是否存在失效的Target，若存在则移除</span></span><br><span class="line"><span class="keyword">for</span> hash := <span class="keyword">range</span> sp.activeTargets &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := uniqueLoops[hash]; !ok &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(l loop)</span></span> &#123;</span><br><span class="line">l.stop()</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;(sp.loops[hash])</span><br><span class="line"></span><br><span class="line"><span class="built_in">delete</span>(sp.loops, hash)</span><br><span class="line"><span class="built_in">delete</span>(sp.activeTargets, hash)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp.targetMtx.Unlock()</span><br><span class="line"></span><br><span class="line">targetScrapePoolTargetsAdded.WithLabelValues(sp.config.JobName).Set(<span class="keyword">float64</span>(<span class="built_in">len</span>(uniqueLoops)))</span><br><span class="line">forcedErr := sp.refreshTargetLimitErr()</span><br><span class="line"><span class="keyword">for</span> _, l := <span class="keyword">range</span> sp.loops &#123;</span><br><span class="line">l.setForcedError(forcedErr)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 通过协程启动scrapeLoop的run方法，采集存储指标</span></span><br><span class="line"><span class="keyword">for</span> _, l := <span class="keyword">range</span> uniqueLoops &#123;</span><br><span class="line"><span class="keyword">if</span> l != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">go</span> l.run(interval, timeout, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Wait for all potentially stopped scrapers to terminate.</span></span><br><span class="line"><span class="comment">// This covers the case of flapping targets. If the server is under high load, a new scraper</span></span><br><span class="line"><span class="comment">// may be active and tries to insert. The old scraper that didn't terminate yet could still</span></span><br><span class="line"><span class="comment">// be inserting a previous sample set.</span></span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sp.sync方法起了一个协程运行scrapePool的run方法去采集并存储监控指标(metrics)</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sl *scrapeLoop)</span> <span class="title">run</span><span class="params">(interval, timeout time.Duration, errc <span class="keyword">chan</span>&lt;- error)</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="comment">// 检测超时</span></span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(sl.scraper.offset(interval, sl.jitterSeed)):</span><br><span class="line"><span class="comment">// Continue after a scraping offset.</span></span><br><span class="line">    <span class="comment">// 停止， 退出</span></span><br><span class="line"><span class="keyword">case</span> &lt;-sl.ctx.Done():</span><br><span class="line"><span class="built_in">close</span>(sl.stopped)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> last time.Time</span><br><span class="line"></span><br><span class="line">alignedScrapeTime := time.Now().Round(<span class="number">0</span>)</span><br><span class="line">ticker := time.NewTicker(interval)</span><br><span class="line"><span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"></span><br><span class="line">mainLoop:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-sl.parentCtx.Done():</span><br><span class="line"><span class="built_in">close</span>(sl.stopped)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;-sl.ctx.Done():</span><br><span class="line"><span class="keyword">break</span> mainLoop</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Temporary workaround for a jitter in go timers that causes disk space</span></span><br><span class="line"><span class="comment">// increase in TSDB.</span></span><br><span class="line"><span class="comment">// See https://github.com/prometheus/prometheus/issues/7846</span></span><br><span class="line"><span class="comment">// Calling Round ensures the time used is the wall clock, as otherwise .Sub</span></span><br><span class="line"><span class="comment">// and .Add on time.Time behave differently (see time package docs).</span></span><br><span class="line">scrapeTime := time.Now().Round(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> AlignScrapeTimestamps &amp;&amp; interval &gt; <span class="number">100</span>*scrapeTimestampTolerance &#123;</span><br><span class="line"><span class="comment">// For some reason, a tick might have been skipped, in which case we</span></span><br><span class="line"><span class="comment">// would call alignedScrapeTime.Add(interval) multiple times.</span></span><br><span class="line"><span class="keyword">for</span> scrapeTime.Sub(alignedScrapeTime) &gt;= interval &#123;</span><br><span class="line">alignedScrapeTime = alignedScrapeTime.Add(interval)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Align the scrape time if we are in the tolerance boundaries.</span></span><br><span class="line"><span class="keyword">if</span> scrapeTime.Sub(alignedScrapeTime) &lt;= scrapeTimestampTolerance &#123;</span><br><span class="line">scrapeTime = alignedScrapeTime</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">last = sl.scrapeAndReport(interval, timeout, last, scrapeTime, errc)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-sl.parentCtx.Done():</span><br><span class="line"><span class="built_in">close</span>(sl.stopped)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;-sl.ctx.Done():</span><br><span class="line"><span class="keyword">break</span> mainLoop</span><br><span class="line"><span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">close</span>(sl.stopped)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !sl.disabledEndOfRunStalenessMarkers &#123;</span><br><span class="line">sl.endOfRunStaleness(last, ticker, interval)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// scrapeAndReport performs a scrape and then appends the result to the storage</span></span><br><span class="line"><span class="comment">// together with reporting metrics, by using as few appenders as possible.</span></span><br><span class="line"><span class="comment">// In the happy scenario, a single appender is used.</span></span><br><span class="line"><span class="comment">// This function uses sl.parentCtx instead of sl.ctx on purpose. A scrape should</span></span><br><span class="line"><span class="comment">// only be cancelled on shutdown, not on reloads.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sl *scrapeLoop)</span> <span class="title">scrapeAndReport</span><span class="params">(interval, timeout time.Duration, last, appendTime time.Time, errc <span class="keyword">chan</span>&lt;- error)</span> <span class="title">time</span>.<span class="title">Time</span></span> &#123;</span><br><span class="line">start := time.Now()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Only record after the first scrape.</span></span><br><span class="line"><span class="keyword">if</span> !last.IsZero() &#123;</span><br><span class="line">targetIntervalLength.WithLabelValues(interval.String()).Observe(</span><br><span class="line">time.Since(last).Seconds(),</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取上次scrape(拉取)指标(metric)占用空间</span></span><br><span class="line">b := sl.buffers.Get(sl.lastScrapeSize).([]<span class="keyword">byte</span>)</span><br><span class="line"><span class="keyword">defer</span> sl.buffers.Put(b)</span><br><span class="line">  <span class="comment">//根据上次的占用的空间申请存储空间</span></span><br><span class="line">buf := bytes.NewBuffer(b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> total, added, seriesAdded <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> err, appErr, scrapeErr error</span><br><span class="line"></span><br><span class="line">app := sl.appender(sl.parentCtx)</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> forcedErr := sl.getForcedError(); forcedErr != <span class="literal">nil</span> &#123;</span><br><span class="line">scrapeErr = forcedErr</span><br><span class="line"><span class="comment">// Add stale markers.</span></span><br><span class="line"><span class="keyword">if</span> _, _, _, err := sl.<span class="built_in">append</span>(app, []<span class="keyword">byte</span>&#123;&#125;, <span class="string">""</span>, appendTime); err != <span class="literal">nil</span> &#123;</span><br><span class="line">app.Rollback()</span><br><span class="line">app = sl.appender(sl.parentCtx)</span><br><span class="line">level.Warn(sl.l).Log(<span class="string">"msg"</span>, <span class="string">"Append failed"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> errc != <span class="literal">nil</span> &#123;</span><br><span class="line">errc &lt;- forcedErr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> start</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> contentType <span class="keyword">string</span></span><br><span class="line">scrapeCtx, cancel := context.WithTimeout(sl.parentCtx, timeout)</span><br><span class="line">  <span class="comment">//开始scrape(拉取)指标</span></span><br><span class="line">contentType, scrapeErr = sl.scraper.scrape(scrapeCtx, buf)</span><br><span class="line">cancel()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> scrapeErr == <span class="literal">nil</span> &#123;</span><br><span class="line">b = buf.Bytes()</span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> There were issues with misbehaving clients in the past</span></span><br><span class="line"><span class="comment">// that occasionally returned empty results. We don't want those</span></span><br><span class="line"><span class="comment">// to falsely reset our buffer size.</span></span><br><span class="line">    <span class="comment">// 存储本次scrape拉取磁盘占用的空间，留待下次scrape(拉取)使用</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(b) &gt; <span class="number">0</span> &#123;</span><br><span class="line">sl.lastScrapeSize = <span class="built_in">len</span>(b)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">level.Debug(sl.l).Log(<span class="string">"msg"</span>, <span class="string">"Scrape failed"</span>, <span class="string">"err"</span>, scrapeErr)</span><br><span class="line"><span class="keyword">if</span> errc != <span class="literal">nil</span> &#123;</span><br><span class="line">errc &lt;- scrapeErr</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A failed scrape is the same as an empty scrape,</span></span><br><span class="line"><span class="comment">// we still call sl.append to trigger stale markers.</span></span><br><span class="line">  <span class="comment">// 存储指标</span></span><br><span class="line">total, added, seriesAdded, appErr = sl.<span class="built_in">append</span>(app, b, contentType, appendTime)</span><br><span class="line"><span class="keyword">if</span> appErr != <span class="literal">nil</span> &#123;</span><br><span class="line">app.Rollback()</span><br><span class="line">app = sl.appender(sl.parentCtx)</span><br><span class="line">level.Debug(sl.l).Log(<span class="string">"msg"</span>, <span class="string">"Append failed"</span>, <span class="string">"err"</span>, appErr)</span><br><span class="line"><span class="comment">// The append failed, probably due to a parse error or sample limit.</span></span><br><span class="line"><span class="comment">// Call sl.append again with an empty scrape to trigger stale markers.</span></span><br><span class="line"><span class="keyword">if</span> _, _, _, err := sl.<span class="built_in">append</span>(app, []<span class="keyword">byte</span>&#123;&#125;, <span class="string">""</span>, appendTime); err != <span class="literal">nil</span> &#123;</span><br><span class="line">app.Rollback()</span><br><span class="line">app = sl.appender(sl.parentCtx)</span><br><span class="line">level.Warn(sl.l).Log(<span class="string">"msg"</span>, <span class="string">"Append failed"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> scrapeErr == <span class="literal">nil</span> &#123;</span><br><span class="line">scrapeErr = appErr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> start</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>run方法主要实现两个功能：指标采集(scrape)和指标存储．此外，为了实现对象的复用，在采集(scrape)过程中，使用了sync.Pool机制</p><p>提高性能，即每次采集(scrape)完成后，都会申请和本次采集(scrape)指标存储空间一样的大小的bytes，加入到buffer中，以备下次指标</p><p>采集(scrape)直接使用</p><p>最后看一下<code>scrape</code>函数的代码，这个函数其实就是发送http get请求，并把响应结果写入到<code>io.Writer</code>中</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *targetScraper)</span> <span class="title">scrape</span><span class="params">(ctx context.Context, w io.Writer)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> s.req == <span class="literal">nil</span> &#123;</span><br><span class="line">req, err := http.NewRequest(<span class="string">"GET"</span>, s.URL().String(), <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">&#125;</span><br><span class="line">req.Header.Add(<span class="string">"Accept"</span>, acceptHeader)</span><br><span class="line">req.Header.Add(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip"</span>)</span><br><span class="line">req.Header.Set(<span class="string">"User-Agent"</span>, userAgentHeader)</span><br><span class="line">req.Header.Set(<span class="string">"X-Prometheus-Scrape-Timeout-Seconds"</span>, fmt.Sprintf(<span class="string">"%f"</span>, s.timeout.Seconds()))</span><br><span class="line"></span><br><span class="line">s.req = req</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resp, err := s.client.Do(s.req.WithContext(ctx))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">io.Copy(ioutil.Discard, resp.Body)</span><br><span class="line">resp.Body.Close()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> resp.StatusCode != http.StatusOK &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, errors.Errorf(<span class="string">"server returned HTTP status %s"</span>, resp.Status)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> resp.Header.Get(<span class="string">"Content-Encoding"</span>) != <span class="string">"gzip"</span> &#123;</span><br><span class="line">_, err = io.Copy(w, resp.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resp.Header.Get(<span class="string">"Content-Type"</span>), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s.gzipr == <span class="literal">nil</span> &#123;</span><br><span class="line">s.buf = bufio.NewReader(resp.Body)</span><br><span class="line">s.gzipr, err = gzip.NewReader(s.buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">s.buf.Reset(resp.Body)</span><br><span class="line"><span class="keyword">if</span> err = s.gzipr.Reset(s.buf); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_, err = io.Copy(w, s.gzipr)</span><br><span class="line">s.gzipr.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resp.Header.Get(<span class="string">"Content-Type"</span>), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此就完成了指标采集</p><p>参考：</p><p><a href="https://blog.csdn.net/dengxiafubi/article/details/102996336?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162311811516780265424839%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=162311811516780265424839&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-2-102996336.pc_v2_rank_blog_default&amp;utm_term=Prometheus%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97&amp;spm=1018.2226.3001.4450" target="_blank" rel="external">https://blog.csdn.net/dengxiafubi/article/details/102996336?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162311811516780265424839%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=162311811516780265424839&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-2-102996336.pc_v2_rank_blog_default&amp;utm_term=Prometheus%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97&amp;spm=1018.2226.3001.4450</a></p><p><a href="https://blog.csdn.net/qq_35753140/article/details/117148565?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162304613116780269873364%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=162304613116780269873364&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-3-117148565.pc_v2_rank_blog_default&amp;utm_term=Prometheus%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0&amp;spm=1018.2226.3001.4450" target="_blank" rel="external">https://blog.csdn.net/qq_35753140/article/details/117148565?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162304613116780269873364%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=162304613116780269873364&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-3-117148565.pc_v2_rank_blog_default&amp;utm_term=Prometheus%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0&amp;spm=1018.2226.3001.4450</a></p><p><a href="https://blog.csdn.net/qq_35753140/article/details/117201128?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162304613116780269873364%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=162304613116780269873364&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-6-117201128.pc_v2_rank_blog_default&amp;utm_term=Prometheus%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0&amp;spm=1018.2226.3001.4450" target="_blank" rel="external">https://blog.csdn.net/qq_35753140/article/details/117201128?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162304613116780269873364%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=162304613116780269873364&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-6-117201128.pc_v2_rank_blog_default&amp;utm_term=Prometheus%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0&amp;spm=1018.2226.3001.4450</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p id=&quot;div-border-top-green&quot;&gt;生活像一只蝴蝶，没有破茧的勇气，哪来飞舞的美丽。生活像一只蜜蜂，没有勤劳和努力，怎能尝到花粉的甜蜜，越努力越幸运！&lt;br&gt;&lt;/p&gt;

&lt;p&gt;scrape模块在prometheus中负责着采集具体指标，并记录到后端存储中的功能，可以说是prometheus最为核心的一个功能模块&lt;/p&gt;
&lt;p&gt;篇幅较长，需要耐心&lt;/p&gt;
&lt;h2 id=&quot;指标采集简介&quot;&gt;&lt;a href=&quot;#指标采集简介&quot; class=&quot;headerlink&quot; title=&quot;指标采集简介&quot;&gt;&lt;/a&gt;指标采集简介&lt;/h2&gt;&lt;p&gt;为了从服务发现(serviceDiscover)实时获取监控服务(targets)，指标采集(scrapeManager)通过协程把管道(chan)获取来的服务(targets)存&lt;/p&gt;
&lt;p&gt;进一个map类型：&lt;code&gt;map[string][]*targetgroup.Group&lt;/code&gt;．其中，map的key是job_name，map的value是结构体targetgroup.Group，&lt;/p&gt;
&lt;p&gt;该结构体包含该job_name对应的Targets，Labes和Source&lt;/p&gt;
    
    </summary>
    
      <category term="Prometheus" scheme="https://magiceses.github.io/categories/Prometheus/"/>
    
    
      <category term="Prometheus" scheme="https://magiceses.github.io/tags/Prometheus/"/>
    
  </entry>
  
  <entry>
    <title>Prometheus 服务发现源码分析</title>
    <link href="https://magiceses.github.io/2020/10/04/prometheus-prometheus-3-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://magiceses.github.io/2020/10/04/prometheus-prometheus-3-服务发现源码分析/</id>
    <published>2020-10-04T03:25:24.000Z</published>
    <updated>2021-10-02T07:49:30.954Z</updated>
    
    <content type="html"><![CDATA[<p id="div-border-top-green">我不知道萧红可有类似的体验，是否担心华美的袍上爬满虱子，也许她知道，但她不在乎，她更想要取暖，即使将虱子一道披挂上身。她像忍耐虱子一样，忍耐着世界的冷眼，还装成一派天真模样，仿佛因不谙世事而无从察觉，就可以不受伤害。<br></p><h2 id="服务发现简介"><a href="#服务发现简介" class="headerlink" title="服务发现简介"></a>服务发现简介</h2><p>云原生、容器场景下按需的资源使用方式对于监控系统而言就意味着没有了一个固定的监控目标，所有的监控对象(基础设施、应用、服</p><p>务)都在动态的变化，这对基于Push模式传统监控软件带来挑战。</p><a id="more"></a><p>对于Prometheus这一类基于Pull模式的监控系统，显然也无法继续使用的static_configs的方式静态的定义监控目标。而对于</p><p>Prometheus而言其解决方案就是引入一个中间的代理人（服务注册中心），这个代理人掌握着当前所有监控目标的访问信息，</p><p>Prometheus只需要向这个代理人询问有哪些监控目标控即可， 这种模式被称为服务发现。</p><p>通过服务发现的方式，管理员可以在不重启Prometheus服务的情况下动态的发现需要监控的Target实例信息。</p><p>Prometheus 每个被控目标暴露一个 endpoint 供 server 抓取，要获知这些 endpoint 有多种方式，最简单的是在配置文件里静态配置，</p><p>还有基于 k8s、consul、dns 等多种方式，基于文件的服务发现是比较灵活普遍的一种方式。</p><p>Prometheus采用pull方式拉取监控数据，需要实时感知被监控服务(Target)的变化．服务发现(serviceDiscover)支持多种服务发现系统，</p><p>这些系统可以动态感知被监控的服务(Target)的变化，把变化的被监控服务(Target)转换为targetgroup.Group的结构，通过管道up发送个</p><p>服务发现(serviceDiscover)．以版本 v2.27为例，目前服务发现(serviceDiscover)支持的服务发现系统类型如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package install has the side-effect of registering all builtin</span></span><br><span class="line"><span class="comment">// service discovery config types.</span></span><br><span class="line"><span class="keyword">package</span> install</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">_ <span class="string">"github.com/prometheus/prometheus/discovery/aws"</span>          <span class="comment">// register aws</span></span><br><span class="line">_ <span class="string">"github.com/prometheus/prometheus/discovery/azure"</span>        <span class="comment">// register azure</span></span><br><span class="line">_ <span class="string">"github.com/prometheus/prometheus/discovery/consul"</span>       <span class="comment">// register consul</span></span><br><span class="line">_ <span class="string">"github.com/prometheus/prometheus/discovery/digitalocean"</span> <span class="comment">// register digitalocean</span></span><br><span class="line">_ <span class="string">"github.com/prometheus/prometheus/discovery/dns"</span>          <span class="comment">// register dns</span></span><br><span class="line">_ <span class="string">"github.com/prometheus/prometheus/discovery/eureka"</span>       <span class="comment">// register eureka</span></span><br><span class="line">_ <span class="string">"github.com/prometheus/prometheus/discovery/file"</span>         <span class="comment">// register file</span></span><br><span class="line">_ <span class="string">"github.com/prometheus/prometheus/discovery/gce"</span>          <span class="comment">// register gce</span></span><br><span class="line">_ <span class="string">"github.com/prometheus/prometheus/discovery/hetzner"</span>      <span class="comment">// register hetzner</span></span><br><span class="line">_ <span class="string">"github.com/prometheus/prometheus/discovery/kubernetes"</span>   <span class="comment">// register kubernetes</span></span><br><span class="line">_ <span class="string">"github.com/prometheus/prometheus/discovery/marathon"</span>     <span class="comment">// register marathon</span></span><br><span class="line">_ <span class="string">"github.com/prometheus/prometheus/discovery/moby"</span>         <span class="comment">// register moby</span></span><br><span class="line">_ <span class="string">"github.com/prometheus/prometheus/discovery/openstack"</span>    <span class="comment">// register openstack</span></span><br><span class="line">_ <span class="string">"github.com/prometheus/prometheus/discovery/scaleway"</span>     <span class="comment">// register scaleway</span></span><br><span class="line">_ <span class="string">"github.com/prometheus/prometheus/discovery/triton"</span>       <span class="comment">// register triton</span></span><br><span class="line">_ <span class="string">"github.com/prometheus/prometheus/discovery/zookeeper"</span>    <span class="comment">// register zookeeper</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="服务发现接口"><a href="#服务发现接口" class="headerlink" title="服务发现接口"></a>服务发现接口</h2><p>服务发现(serviceDiscover)为了实现对以上服务发现系统的统一管理，提供了一个Discoverer接口，由各个服务发现系统来实现，然后把</p><p>上线的服务(Target)通过up管道发送给服务发现(serviceDiscover)</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">prometheus/discovery/manager.<span class="keyword">go</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> Discoverer <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Run hands a channel to the discovery provider (Consul, DNS etc) through which it can send</span></span><br><span class="line"><span class="comment">// updated target groups.</span></span><br><span class="line"><span class="comment">// Must returns if the context gets canceled. It should not close the update</span></span><br><span class="line"><span class="comment">// channel on returning.</span></span><br><span class="line">Run(ctx context.Context, up <span class="keyword">chan</span>&lt;- []*targetgroup.Group)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">prometheus/discovery/targetgroup/targetgroup.<span class="keyword">go</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Group is a set of targets with a common label set(production , test, staging etc.).</span></span><br><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Targets is a list of targets identified by a label set. Each target is</span></span><br><span class="line"><span class="comment">// uniquely identifiable in the group by its address label.</span></span><br><span class="line">Targets []model.LabelSet <span class="comment">//服务(Target)主要标签，比如ip + port，示例："__address__": "localhost:9100"</span></span><br><span class="line"><span class="comment">// Labels is a set of labels that is common across all targets in the group.</span></span><br><span class="line">Labels model.LabelSet　<span class="comment">//服务(Target)其他标签，可以为空：</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Source is an identifier that describes a group of targets.</span></span><br><span class="line">Source <span class="keyword">string</span> <span class="comment">//全局唯一个ID，示例：Source: "0"</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Group的一个示例：</span><br><span class="line">(dlv) p tg</span><br><span class="line">*github.com/prometheus/prometheus/discovery/targetgroup.Group &#123;</span><br><span class="line">Targets: []github.com/prometheus/common/model.LabelSet <span class="built_in">len</span>: <span class="number">1</span>, <span class="built_in">cap</span>: <span class="number">1</span>, [</span><br><span class="line">　　　　　　　[</span><br><span class="line">　　　　　　　<span class="string">"__address__"</span>: <span class="string">"localhost:9100"</span>, </span><br><span class="line">　　　　　　　],</span><br><span class="line">　　　　　　　　]</span><br><span class="line">],</span><br><span class="line">Labels: github.com/prometheus/common/model.LabelSet <span class="literal">nil</span>,</span><br><span class="line">Source: <span class="string">"0"</span>,&#125;</span><br></pre></td></tr></table></figure><p>除了静态服务发现系统(StaticConfigs)在prometheus/discovery/manager.go中实现了以上接口，其他动态服务发现系统，在</p><p>prometheus/discovery/下都在有各自的目录下实现。</p><h2 id="服务发现配置"><a href="#服务发现配置" class="headerlink" title="服务发现配置"></a>服务发现配置</h2><p>示例配置文件：prometheus.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># my global config</span></span><br><span class="line"><span class="attr">global:</span></span><br><span class="line"><span class="attr">  scrape_interval:</span>     <span class="number">15</span><span class="string">s</span> <span class="comment"># Set the scrape interval to every 15 seconds. Default is every 1 minute.</span></span><br><span class="line"><span class="attr">  evaluation_interval:</span> <span class="number">15</span><span class="string">s</span> <span class="comment"># Evaluate rules every 15 seconds. The default is every 1 minute.</span></span><br><span class="line">  <span class="comment"># scrape_timeout is set to the global default (10s).</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Alertmanager configuration</span></span><br><span class="line"><span class="attr">alerting:</span></span><br><span class="line"><span class="attr">  alertmanagers:</span></span><br><span class="line"><span class="attr">  - static_configs:</span></span><br><span class="line"><span class="attr">    - targets:</span></span><br><span class="line"><span class="attr">       - alertmanager:</span><span class="number">9093</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Load rules once and periodically evaluate them according to the global 'evaluation_interval'.</span></span><br><span class="line"><span class="attr">rule_files:</span></span><br><span class="line">  <span class="comment"># - "first_rules.yml"</span></span><br><span class="line">  <span class="comment"># - "second_rules.yml"</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># A scrape configuration containing exactly one endpoint to scrape:</span></span><br><span class="line"><span class="comment"># Here it's Prometheus itself.</span></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="comment"># The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.</span></span><br><span class="line"><span class="attr">  - job_name:</span> <span class="string">'prometheus'</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># metrics_path defaults to '/metrics'</span></span><br><span class="line">    <span class="comment"># scheme defaults to 'http'.</span></span><br><span class="line"><span class="attr">    scrape_interval:</span> <span class="number">5</span><span class="string">s</span></span><br><span class="line"><span class="attr">    static_configs:</span></span><br><span class="line"><span class="attr">    - targets:</span> <span class="string">['localhost:9090']</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">  - job_name:</span> <span class="string">'node'</span></span><br><span class="line"><span class="attr">    scrape_interval:</span> <span class="number">10</span><span class="string">s</span></span><br><span class="line"><span class="attr">    static_configs:</span></span><br><span class="line"><span class="attr">      - targets:</span> <span class="string">['localhost:9100']</span></span><br></pre></td></tr></table></figure><ol><li><p>配置文件初始化</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">prometheus/cmd/prometheus/main.<span class="keyword">go</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//discovery.Name("scrape")用于区分notify</span></span><br><span class="line">discoveryManagerScrape  = discovery.NewManager(ctxScrape, log.With(logger, <span class="string">"component"</span>, <span class="string">"discovery manager scrape"</span>), discovery.Name(<span class="string">"scrape"</span>))</span><br></pre></td></tr></table></figure></li><li><p>调用NewManager方法，实例化Manager结构体</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">prometheus/discovery/manager.<span class="keyword">go</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// NewManager is the Discovery Manager constructor.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewManager</span><span class="params">(ctx context.Context, logger log.Logger, options ...<span class="keyword">func</span>(*Manager)</span>) *<span class="title">Manager</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> logger == <span class="literal">nil</span> &#123;</span><br><span class="line">logger = log.NewNopLogger()</span><br><span class="line">&#125;</span><br><span class="line">mgr := &amp;Manager&#123;</span><br><span class="line">logger:         logger,</span><br><span class="line">syncCh:         <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">map</span>[<span class="keyword">string</span>][]*targetgroup.Group),</span><br><span class="line">targets:        <span class="built_in">make</span>(<span class="keyword">map</span>[poolKey]<span class="keyword">map</span>[<span class="keyword">string</span>]*targetgroup.Group),</span><br><span class="line">discoverCancel: []context.CancelFunc&#123;&#125;,</span><br><span class="line">ctx:            ctx,</span><br><span class="line">updatert:       <span class="number">5</span> * time.Second,</span><br><span class="line">triggerSend:    <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, option := <span class="keyword">range</span> options &#123;</span><br><span class="line">option(mgr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mgr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体Manager定义如下</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">prometheus/discovery/manager.<span class="keyword">go</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Manager maintains a set of discovery providers and sends each update to a map channel.</span></span><br><span class="line"><span class="comment">// Targets are grouped by the target set name.</span></span><br><span class="line"><span class="keyword">type</span> Manager <span class="keyword">struct</span> &#123;</span><br><span class="line">logger         log.Logger <span class="comment">//日志</span></span><br><span class="line">name           <span class="keyword">string</span>　　　<span class="comment">// 用于区分srape和notify，因为他们用的同一个discovery/manager.go</span></span><br><span class="line">mtx            sync.RWMutex <span class="comment">//同步读写锁</span></span><br><span class="line">ctx            context.Context <span class="comment">//协同控制，比如系统退出</span></span><br><span class="line">discoverCancel []context.CancelFunc <span class="comment">// 处理服务下线</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Some Discoverers(eg. k8s) send only the updates for a given target group</span></span><br><span class="line"><span class="comment">// so we use map[tg.Source]*targetgroup.Group to know which group to update.</span></span><br><span class="line">targets <span class="keyword">map</span>[poolKey]<span class="keyword">map</span>[<span class="keyword">string</span>]*targetgroup.Group <span class="comment">//发现的服务(Targets)</span></span><br><span class="line"><span class="comment">// providers keeps track of SD providers.</span></span><br><span class="line">providers []*provider <span class="comment">// providers的类型可分为kubernetes，DNS等</span></span><br><span class="line"><span class="comment">// The sync channel sends the updates as a map where the key is the job value from the scrape config.</span></span><br><span class="line"><span class="comment">// key 是 prometheus 配置文件的 job_name，value 是其对应的 targetgroup</span></span><br><span class="line">  <span class="comment">// 把发现的服务Targets)通过管道形式通知给scrapeManager</span></span><br><span class="line">  syncCh <span class="keyword">chan</span> <span class="keyword">map</span>[<span class="keyword">string</span>][]*targetgroup.Group </span><br><span class="line"> </span><br><span class="line"><span class="comment">// How long to wait before sending updates to the channel. The variable</span></span><br><span class="line"><span class="comment">// should only be modified in unit tests.</span></span><br><span class="line">updatert time.Duration</span><br><span class="line"> </span><br><span class="line"><span class="comment">// The triggerSend channel signals to the manager that new updates have been received from providers.</span></span><br><span class="line"><span class="comment">// 这是一个用于通知 manager 有 provider 进行了更新的 channel</span></span><br><span class="line">  triggerSend <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较重要的成员是 targets，它保存了全量的 target，poolKey 是一个结构体，由 job_name 和 provider_name 组成</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">prometheus/discovery/manager.<span class="keyword">go</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// poolKey定义了每个发现的服务的来源</span></span><br><span class="line"><span class="keyword">type</span> poolKey <span class="keyword">struct</span> &#123;</span><br><span class="line">setName  <span class="keyword">string</span> <span class="comment">//对应系统名/索引值，比如：string/0(静态服务发现)，DNS/1(动态服务发现)</span></span><br><span class="line">provider <span class="keyword">string</span> <span class="comment">//对应job_name</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 m.registerProviders 可以看到 setName 就是 “file”/“dns”/“consul”…,provider 是 provider 对象的 name 字段，是 “file”/“dns”/</p><p>“consul”… 后面跟上这个 m.provider 有多少个发现文件，比如 file_SD_discovrer 配置了3个yml文件，poolKey 的 provider 字段就</p><p>是 “file/3”</p></li><li><p>通过匿名函数加载prometheus.yml的scrape_configs下对应配置</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">prometheus/cmd/prometheus/main.<span class="keyword">go</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(cfg *config.Config)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]sd_config.ServiceDiscoveryConfig)</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> cfg.ScrapeConfigs &#123;</span><br><span class="line">        c[v.JobName] = v.ServiceDiscoveryConfig</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> discoveryManagerScrape.ApplyConfig(c)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>以示例配置文件prometheus.yml为例，包含两个jobs，job_name分别是prometheus和node，每个job可以包含多个targets．以job_name：node为例，匿名函数变量v输出如下:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">(dlv) p v</span><br><span class="line">*github.com/prometheus/prometheus/config.ScrapeConfig &#123;</span><br><span class="line">JobName: <span class="string">"node"</span>,</span><br><span class="line">HonorLabels: <span class="literal">false</span>,</span><br><span class="line">Params: net/url.Values <span class="literal">nil</span>,</span><br><span class="line">ScrapeInterval: <span class="number">10000000000</span>,</span><br><span class="line">ScrapeTimeout: <span class="number">10000000000</span>,</span><br><span class="line">MetricsPath: <span class="string">"/metrics"</span>,</span><br><span class="line">Scheme: <span class="string">"http"</span>,</span><br><span class="line">SampleLimit: <span class="number">0</span>,</span><br><span class="line">ServiceDiscoveryConfig: github.com/prometheus/prometheus/discovery/config.ServiceDiscoveryConfig &#123;</span><br><span class="line">StaticConfigs: []*github.com/prometheus/prometheus/discovery/targetgroup.Group <span class="built_in">len</span>: <span class="number">1</span>, <span class="built_in">cap</span>: <span class="number">1</span>, [</span><br><span class="line">*(*<span class="string">"github.com/prometheus/prometheus/discovery/targetgroup.Group"</span>)(<span class="number">0xc0018a27b0</span>),</span><br><span class="line">],</span><br><span class="line">DNSSDConfigs: []*github.com/prometheus/prometheus/discovery/dns.SDConfig <span class="built_in">len</span>: <span class="number">0</span>, <span class="built_in">cap</span>: <span class="number">0</span>, <span class="literal">nil</span>,</span><br><span class="line">FileSDConfigs: []*github.com/prometheus/prometheus/discovery/file.SDConfig <span class="built_in">len</span>: <span class="number">0</span>, <span class="built_in">cap</span>: <span class="number">0</span>, <span class="literal">nil</span>,</span><br><span class="line">        ．．．．．．</span><br><span class="line">        ．．．．．．</span><br><span class="line">        ．．．．．．</span><br><span class="line">AzureSDConfigs: []*github.com/prometheus/prometheus/discovery/azure.SDConfig <span class="built_in">len</span>: <span class="number">0</span>, <span class="built_in">cap</span>: <span class="number">0</span>, <span class="literal">nil</span>,</span><br><span class="line">TritonSDConfigs: []*github.com/prometheus/prometheus/discovery/triton.SDConfig <span class="built_in">len</span>: <span class="number">0</span>, <span class="built_in">cap</span>: <span class="number">0</span>, <span class="literal">nil</span>,&#125;,</span><br><span class="line">HTTPClientConfig: github.com/prometheus/common/config.HTTPClientConfig &#123;</span><br><span class="line">BasicAuth: *github.com/prometheus/common/config.BasicAuth <span class="literal">nil</span>,</span><br><span class="line">BearerToken: <span class="string">""</span>,</span><br><span class="line">BearerTokenFile: <span class="string">""</span>,</span><br><span class="line">ProxyURL: (*<span class="string">"github.com/prometheus/common/config.URL"</span>)(<span class="number">0xc000458cf</span>8),</span><br><span class="line">TLSConfig: (*<span class="string">"github.com/prometheus/common/config.TLSConfig"</span>)(<span class="number">0xc000458d</span>00),&#125;,</span><br><span class="line">RelabelConfigs: []*github.com/prometheus/prometheus/pkg/relabel.Config <span class="built_in">len</span>: <span class="number">0</span>, <span class="built_in">cap</span>: <span class="number">0</span>, <span class="literal">nil</span>,</span><br><span class="line">MetricRelabelConfigs: []*github.com/prometheus/prometheus/pkg/relabel.Config <span class="built_in">len</span>: <span class="number">0</span>, <span class="built_in">cap</span>: <span class="number">0</span>, <span class="literal">nil</span>,&#125;</span><br></pre></td></tr></table></figure><p>由以上结果可知，job_name：node对应静态服务发现系统(StaticConfigs)．其实，在配置文件prometheus.yml中的两个job_names</p><p>都对应静态服务发现系统(StaticConfigs)</p></li><li><p>ApplyConfig方法实现逻辑比较清晰：先实现每个job的Discoverer接口，然后启动该job对应的服务发现系统</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">prometheus/discovery/manager.<span class="keyword">go</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// ApplyConfig removes all running discovery providers and starts new ones using the provided config.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Manager)</span> <span class="title">ApplyConfig</span><span class="params">(cfg <span class="keyword">map</span>[<span class="keyword">string</span>]sd_config.ServiceDiscoveryConfig)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">m.mtx.Lock()</span><br><span class="line"><span class="keyword">defer</span> m.mtx.Unlock()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> pk := <span class="keyword">range</span> m.targets &#123;</span><br><span class="line"><span class="keyword">if</span> _, ok := cfg[pk.setName]; !ok &#123;</span><br><span class="line">discoveredTargets.DeleteLabelValues(m.name, pk.setName)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 先把所有的Discoverer取消掉，这样做比较简单，毕竟配置文件修改频率非常低，没大毛病</span></span><br><span class="line">  <span class="comment">// 实现方式就是我们上面提到的Manager.discoverCancel这个取消函数的数组，遍历调用就是了</span></span><br><span class="line">m.cancelDiscoverers()</span><br><span class="line">  <span class="comment">// name对应job_name，scfg是给出该job_name对应的服务发现系统类型，每个job_name下可以包含多种服务发现系统类型，但用的比较少</span></span><br><span class="line"><span class="keyword">for</span> name, scfg := <span class="keyword">range</span> cfg &#123;</span><br><span class="line">m.registerProviders(scfg, name)</span><br><span class="line">discoveredTargets.WithLabelValues(m.name, name).Set(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, prov := <span class="keyword">range</span> m.providers &#123;</span><br><span class="line">　　　　<span class="comment">//启动每个job下对应的服务发现系统</span></span><br><span class="line">m.startProvider(m.ctx, prov)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ApplyConfig方法主要通过调用方法：registerProviders()和startProvider()实现以上功能</p><ul><li><p>registerProviders方法先判断每个job_name下包含所有的服务发现系统类型，接着由其对应的服务发现系统实现Discoverer接口，并构建provider和TargetGroups</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// registerProviders returns a number of failed SD config.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Manager)</span> <span class="title">registerProviders</span><span class="params">(cfgs Configs, setName <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        failed <span class="keyword">int</span></span><br><span class="line">        added  <span class="keyword">bool</span></span><br><span class="line">    )</span><br><span class="line">    add := <span class="function"><span class="keyword">func</span><span class="params">(cfg Config)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, p := <span class="keyword">range</span> m.providers &#123;</span><br><span class="line">            <span class="keyword">if</span> reflect.DeepEqual(cfg, p.config) &#123;</span><br><span class="line">                p.subs = <span class="built_in">append</span>(p.subs, setName)</span><br><span class="line">                added = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        typ := cfg.Name()</span><br><span class="line">        d, err := cfg.NewDiscoverer(DiscovererOptions&#123;</span><br><span class="line">            Logger: log.With(m.logger, <span class="string">"discovery"</span>, typ),</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            level.Error(m.logger).Log(<span class="string">"msg"</span>, <span class="string">"Cannot create service discovery"</span>, <span class="string">"err"</span>, err, <span class="string">"type"</span>, typ)</span><br><span class="line">            failed++</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        m.providers = <span class="built_in">append</span>(m.providers, &amp;provider&#123;</span><br><span class="line">            name:   fmt.Sprintf(<span class="string">"%s/%d"</span>, typ, <span class="built_in">len</span>(m.providers)),</span><br><span class="line">            d:      d,</span><br><span class="line">            config: cfg,</span><br><span class="line">            subs:   []<span class="keyword">string</span>&#123;setName&#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">        added = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, cfg := <span class="keyword">range</span> cfgs &#123;</span><br><span class="line">        add(cfg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !added &#123;</span><br><span class="line">        <span class="comment">// Add an empty target group to force the refresh of the corresponding</span></span><br><span class="line">        <span class="comment">// scrape pool and to notify the receiver that this target set has no</span></span><br><span class="line">        <span class="comment">// current targets.</span></span><br><span class="line">        <span class="comment">// It can happen because the combined set of SD configurations is empty</span></span><br><span class="line">        <span class="comment">// or because we fail to instantiate all the SD configurations.</span></span><br><span class="line">        add(StaticConfig&#123;&#123;&#125;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> failed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StaticConfigs对应TargetGroups， 以job_name：node为例，TargetGroups对应输出如下:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(dlv) p setName</span><br><span class="line"><span class="string">"node"</span></span><br><span class="line">(dlv) p StaticConfigs</span><br><span class="line">[]*github.com/prometheus/prometheus/discovery/targetgroup.Group <span class="built_in">len</span>: <span class="number">1</span>, <span class="built_in">cap</span>: <span class="number">1</span>, [</span><br><span class="line">    *&#123;</span><br><span class="line">        Targets: []github.com/prometheus/common/model.LabelSet <span class="built_in">len</span>: <span class="number">1</span>, <span class="built_in">cap</span>: <span class="number">1</span>, [</span><br><span class="line">    　　　　　　　　　　[</span><br><span class="line">        　　　　　　　　　　<span class="string">"__address__"</span>: <span class="string">"localhost:9100"</span>, </span><br><span class="line">    　　　　　　　　　　],</span><br><span class="line">        ],</span><br><span class="line">        Labels: github.com/prometheus/common/model.LabelSet <span class="literal">nil</span>,</span><br><span class="line">        Source: <span class="string">"0"</span>,&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>每个job_name对应一个TargetGroups，而每个TargetGroups可以包含多个provider，每个provider包含实现对应的Discoverer接口和job_name等．所以，对应关系：job_name －&gt; TargetGroups －&gt; 多个targets －&gt; 多个provider －&gt; 多个Discover．部分示例如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(dlv) p m.providers</span><br><span class="line">[]*github.com/prometheus/prometheus/discovery.provider <span class="built_in">len</span>: <span class="number">2</span>, <span class="built_in">cap</span>: <span class="number">2</span>, [</span><br><span class="line">    *&#123;</span><br><span class="line">        name: <span class="string">"string/0"</span>,</span><br><span class="line">        d: github.com/prometheus/prometheus/discovery.Discoverer(*github.com/prometheus/prometheus/discovery.StaticProvider) ...,</span><br><span class="line">        subs: []<span class="keyword">string</span> <span class="built_in">len</span>: <span class="number">1</span>, <span class="built_in">cap</span>: <span class="number">1</span>, [</span><br><span class="line">            <span class="string">"prometheus"</span>,</span><br><span class="line">        ],</span><br><span class="line">        config: <span class="keyword">interface</span> &#123;&#125;(<span class="keyword">string</span>) *(*<span class="keyword">interface</span> &#123;&#125;)(<span class="number">0xc000536268</span>),&#125;,</span><br><span class="line">    *&#123;</span><br><span class="line">        name: <span class="string">"string/1"</span>,</span><br><span class="line">        d: github.com/prometheus/prometheus/discovery.Discoverer(*github.com/prometheus/prometheus/discovery.StaticProvider) ...,</span><br><span class="line">        subs: []<span class="keyword">string</span> <span class="built_in">len</span>: <span class="number">1</span>, <span class="built_in">cap</span>: <span class="number">1</span>, [<span class="string">"node"</span>],</span><br><span class="line">        config: <span class="keyword">interface</span> &#123;&#125;(<span class="keyword">string</span>) *(*<span class="keyword">interface</span> &#123;&#125;)(<span class="number">0xc000518b78</span>),&#125;,</span><br><span class="line">]</span><br><span class="line">(dlv) p m.providers[<span class="number">0</span>].d</span><br><span class="line">github.com/prometheus/prometheus/discovery.Discoverer(*github.com/prometheus/prometheus/discovery.StaticProvider) *&#123;</span><br><span class="line">    TargetGroups: []*github.com/prometheus/prometheus/discovery/targetgroup.Group <span class="built_in">len</span>: <span class="number">1</span>, <span class="built_in">cap</span>: <span class="number">1</span>, [</span><br><span class="line">        *(*<span class="string">"github.com/prometheus/prometheus/discovery/targetgroup.Group"</span>)(<span class="number">0xc000ce09f</span>0),</span><br><span class="line">    ],&#125;</span><br></pre></td></tr></table></figure></li><li><p>startProvider方法逐一启动job_name对应的所有服务发现系统</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">prometheus/discovery/manager.<span class="keyword">go</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Manager)</span> <span class="title">startProvider</span><span class="params">(ctx context.Context, p *provider)</span></span> &#123;</span><br><span class="line">    level.Debug(m.logger).Log(<span class="string">"msg"</span>, <span class="string">"Starting provider"</span>, <span class="string">"provider"</span>, p.name, <span class="string">"subs"</span>, fmt.Sprintf(<span class="string">"%v"</span>, p.subs))</span><br><span class="line">    ctx, cancel := context.WithCancel(ctx)</span><br><span class="line">    updates := <span class="built_in">make</span>(<span class="keyword">chan</span> []*targetgroup.Group)</span><br><span class="line"> </span><br><span class="line">    m.discoverCancel = <span class="built_in">append</span>(m.discoverCancel, cancel)</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 第一个协程启动具体的发现的服务，作为[]*targetgroup.Group的生产者</span></span><br><span class="line">    <span class="keyword">go</span> p.d.Run(ctx, updates)</span><br><span class="line">  <span class="comment">// 第二个协程是[]*targetgroup.Group的消费者</span></span><br><span class="line">    <span class="keyword">go</span> m.updater(ctx, p, updates)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 备注：Run方法调用位置是实现Discoverer的服务发现系统中．若是静态服务发现，Run方法在prometheus/discovery/manager.go中实现，若是动态服务发现系统，则在对应系统的目录下实现．</span></span><br></pre></td></tr></table></figure><p>Run方法从结构体StaticProvider中取值，传递给[]*targetgroup.Group，作为服务发现的生产者</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">prometheus/discovery/discovery.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Discoverer <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Run hands a channel to the discovery provider (Consul, DNS, etc.) through which</span></span><br><span class="line">    <span class="comment">// it can send updated target groups. It must return when the context is canceled.</span></span><br><span class="line">    <span class="comment">// It should not close the update channel on returning.</span></span><br><span class="line">    Run(ctx context.Context, up <span class="keyword">chan</span>&lt;- []*targetgroup.Group)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">prometheus/discovery/manager.<span class="keyword">go</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// StaticProvider holds a list of target groups that never change.</span></span><br><span class="line"><span class="keyword">type</span> StaticProvider <span class="keyword">struct</span> &#123;</span><br><span class="line">    TargetGroups []*targetgroup.Group</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Run implements the Worker interface.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sd *StaticProvider)</span> <span class="title">Run</span><span class="params">(ctx context.Context, ch <span class="keyword">chan</span>&lt;- []*targetgroup.Group)</span></span> &#123;</span><br><span class="line">    <span class="comment">// We still have to consider that the consumer exits right away in which case</span></span><br><span class="line">    <span class="comment">// the context will be canceled.</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> ch &lt;- sd.TargetGroups:</span><br><span class="line">    <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>updater方法从[]*targetgroup.Group获取TargetGroups，并把它发传给结构体Manager中对应的Targets，Manager中对应的Targets是map类型</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">prometheus/discovery/manager.<span class="keyword">go</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Manager)</span> <span class="title">updater</span><span class="params">(ctx context.Context, p *provider, updates <span class="keyword">chan</span> []*targetgroup.Group)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">//退出</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> tgs, ok := &lt;-updates: <span class="comment">// 从[]*targetgroup.Group取TargetGroups</span></span><br><span class="line">            receivedUpdates.WithLabelValues(m.name).Inc()</span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                level.Debug(m.logger).Log(<span class="string">"msg"</span>, <span class="string">"discoverer channel closed"</span>, <span class="string">"provider"</span>, p.name)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// subs对应job_names，p.name对应系统名/索引值，比如：string/0</span></span><br><span class="line">            <span class="keyword">for</span> _, s := <span class="keyword">range</span> p.subs &#123;</span><br><span class="line">                m.updateGroup(poolKey&#123;setName: s, provider: p.name&#125;, tgs)</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> m.triggerSend &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新结构体Manager对应的targets，key是结构体poolKey，value是传递过来的TargetGroups，其中包含targets</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">prometheus/discovery/manager.<span class="keyword">go</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Manager)</span> <span class="title">updateGroup</span><span class="params">(poolKey poolKey, tgs []*targetgroup.Group)</span></span> &#123;</span><br><span class="line">    m.mtx.Lock()</span><br><span class="line">    <span class="keyword">defer</span> m.mtx.Unlock()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> _, tg := <span class="keyword">range</span> tgs &#123;</span><br><span class="line">        <span class="keyword">if</span> tg != <span class="literal">nil</span> &#123; <span class="comment">// Some Discoverers send nil target group so need to check for it to avoid panics.</span></span><br><span class="line">            <span class="keyword">if</span> _, ok := m.targets[poolKey]; !ok &#123;</span><br><span class="line">                m.targets[poolKey] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*targetgroup.Group)</span><br><span class="line">            &#125;</span><br><span class="line">            m.targets[poolKey][tg.Source] = tg <span class="comment">//一个tg对应一个job，在map类型targets中，结构体poolkey和tg.Source可以确定一个tg，即job</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="服务发现启动"><a href="#服务发现启动" class="headerlink" title="服务发现启动"></a>服务发现启动</h2><p>在main.go方法中启一个协程，运行Run()方法</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">prometheus/cmd/prometheus/main.<span class="keyword">go</span></span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Scrape discovery manager.</span></span><br><span class="line">    g.Add(</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">            err := discoveryManagerScrape.Run()</span><br><span class="line">            level.Info(logger).Log(<span class="string">"msg"</span>, <span class="string">"Scrape discovery manager stopped"</span>)</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line">            level.Info(logger).Log(<span class="string">"msg"</span>, <span class="string">"Stopping scrape discovery manager..."</span>)</span><br><span class="line">            cancelScrape()</span><br><span class="line">        &#125;,</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run starts the background processing</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Manager)</span> <span class="title">Run</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> m.sender()</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> m.ctx.Done() &#123;</span><br><span class="line">m.cancelDiscoverers()</span><br><span class="line"><span class="keyword">return</span> m.ctx.Err()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Run方法再起一个协程，运行sender()方法，sender方法的主要功能是处理结构体Manager中map类型的targets，然后传给结构</p><p>体Manager中的map类型<code>syncCh：syncCh chan map[string][]*targetgroup.Group</code></p><p>sender 通过一个计时器达到限制更新速率的目的，因为有些 discoverer 可能会过于频繁的更新 target。每次 Run() 都会根据 context 执</p><p>行取消发现的操作。周期计时器用法值得学，注意创建以后要延迟关闭。</p><p>每5秒检查一次 m.triggerSend 中有没有更新的信号，如果有更新的信号，就组装 <code>map[string][]*targetgroup.Group</code> 发送到</p><p>m.SyncCh 中，由于 m.SyncCh 是无缓冲通道，如果没能接收的话，就等到下次检查到更新信号再重试发送，这里的嵌套 select case 非</p><p>常值得学习</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Manager)</span> <span class="title">sender</span><span class="params">()</span></span> &#123;</span><br><span class="line">ticker := time.NewTicker(m.updatert)</span><br><span class="line"><span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-m.ctx.Done():</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> &lt;-ticker.C: <span class="comment">// Some discoverers send updates too often so we throttle these with the ticker.</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-m.triggerSend:</span><br><span class="line">sentUpdates.WithLabelValues(m.name).Inc()</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">　　　　　<span class="comment">//方法allGroups负责类型转换，并传给syncCh</span></span><br><span class="line"><span class="keyword">case</span> m.syncCh &lt;- m.allGroups(): </span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">delayedUpdates.WithLabelValues(m.name).Inc()</span><br><span class="line">level.Debug(m.logger).Log(<span class="string">"msg"</span>, <span class="string">"discovery receiver's channel was full so will retry the next cycle"</span>)</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> m.triggerSend &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>负责转换的allGroups()方法，<code>m.allGroups</code> 方法读取自身的 <code>targets</code> 成员变量中的值组装成 map 返回给调用者，用于向自身的 <code>syncCh</code> 发送这个 map，最终通知给 scraper；</p><p>当 SD 发现删除了某个 target group 时会发送一个空的 target group，此处对这个动作的意义做了说明，空的 target group 会通知</p><p>scraper 停止再抓取这些 target</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Manager)</span> <span class="title">allGroups</span><span class="params">()</span> <span class="title">map</span>[<span class="title">string</span>][]*<span class="title">targetgroup</span>.<span class="title">Group</span></span> &#123;</span><br><span class="line">m.mtx.Lock()</span><br><span class="line"><span class="keyword">defer</span> m.mtx.Unlock()</span><br><span class="line"> </span><br><span class="line">tSets := <span class="keyword">map</span>[<span class="keyword">string</span>][]*targetgroup.Group&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> pkey, tsets := <span class="keyword">range</span> m.targets &#123;</span><br><span class="line"><span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> _, tg := <span class="keyword">range</span> tsets &#123;</span><br><span class="line"><span class="comment">// Even if the target group 'tg' is empty we still need to send it to the 'Scrape manager'</span></span><br><span class="line"><span class="comment">// to signal that it needs to stop all scrape loops for this target set.</span></span><br><span class="line">tSets[pkey.setName] = <span class="built_in">append</span>(tSets[pkey.setName], tg)</span><br><span class="line">n += <span class="built_in">len</span>(tg.Targets)</span><br><span class="line">&#125;</span><br><span class="line">discoveredTargets.WithLabelValues(m.name, pkey.setName).Set(<span class="keyword">float64</span>(n))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tSets</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务发现和指标采集通信"><a href="#服务发现和指标采集通信" class="headerlink" title="服务发现和指标采集通信"></a>服务发现和指标采集通信</h2><p>服务发现 (serviceDiscover)和指标采集 (scrapeManager)通信，负责指标采集的服务监听的正是结构体Manager中的syncCh，由此实现了两个服务的通信</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">prometheus/cmd/prometheus/main.<span class="keyword">go</span></span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Scrape manager.</span></span><br><span class="line">g.Add(</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// When the scrape manager receives a new targets list</span></span><br><span class="line"><span class="comment">// it needs to read a valid config for each job.</span></span><br><span class="line"><span class="comment">// It depends on the config being in sync with the discovery manager so</span></span><br><span class="line"><span class="comment">// we wait until the config is fully loaded.</span></span><br><span class="line">&lt;-reloadReady.C</span><br><span class="line"> </span><br><span class="line">err := scrapeManager.Run(discoveryManagerScrape.SyncCh())</span><br><span class="line">level.Info(logger).Log(<span class="string">"msg"</span>, <span class="string">"Scrape manager stopped"</span>)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line"><span class="comment">// Scrape manager needs to be stopped before closing the local TSDB</span></span><br><span class="line"><span class="comment">// so that it doesn't try to write samples to a closed storage.</span></span><br><span class="line">level.Info(logger).Log(<span class="string">"msg"</span>, <span class="string">"Stopping scrape manager..."</span>)</span><br><span class="line">scrapeManager.Stop()</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">prometheus/discovery/manager.<span class="keyword">go</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// SyncCh returns a read only channel used by all the clients to receive target updates.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Manager)</span> <span class="title">SyncCh</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">map</span>[<span class="title">string</span>][]*<span class="title">targetgroup</span>.<span class="title">Group</span></span> &#123;</span><br><span class="line">    <span class="comment">//结构体Manager中的syncCh</span></span><br><span class="line"><span class="keyword">return</span> m.syncCh</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此，服务发现的主要功能就梳理出来了</p><p><img src="/images/prometheus-prometheus-8.png" alt="在这里插入图片描述"></p><ol><li><p>主程序调用 NewManager() Manager 实例</p></li><li><p>主程序调用 m.ApplyConfig() 根据配置文件配置并启动 Manager 实例，Manager 实例包括一组 Provider，其持有具体的 Discoverer，Discoverer 在运行时定期刷新target group，通过 channel 发送给 Manager 将其保存在 m.targets 中，并向 m.triggerSend channel 发送通知信号</p></li><li><p>m.Run() 按照 m.updatert 设定的时间间隔检查有没有更新的信号，有的话就把自己的 targets 字段中的 targets 发送给自身的 m.syncCh channel</p></li><li><p>主程序调用 m.SyncCh() 方法获取 channel 并从中取得 target</p></li></ol><p>参考：</p><p><a href="https://blog.csdn.net/dengxiafubi/article/details/102741656?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162311811516780265424839%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=162311811516780265424839&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-5-102741656.pc_v2_rank_blog_default&amp;utm_term=Prometheus%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97&amp;spm=1018.2226.3001.4450" target="_blank" rel="external">https://blog.csdn.net/dengxiafubi/article/details/102741656?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162311811516780265424839%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=162311811516780265424839&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-5-102741656.pc_v2_rank_blog_default&amp;utm_term=Prometheus%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97&amp;spm=1018.2226.3001.4450</a></p><p><a href="https://blog.csdn.net/qq_35753140/article/details/112999768?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162304613116780269873364%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=162304613116780269873364&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-4-112999768.pc_v2_rank_blog_default&amp;utm_term=Prometheus%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0&amp;spm=1018.2226.3001.4450" target="_blank" rel="external">https://blog.csdn.net/qq_35753140/article/details/112999768?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162304613116780269873364%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=162304613116780269873364&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-4-112999768.pc_v2_rank_blog_default&amp;utm_term=Prometheus%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0&amp;spm=1018.2226.3001.4450</a></p><p><a href="https://blog.csdn.net/weixin_42663840/article/details/81450705?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-13.baidujs&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-13.baidujs" target="_blank" rel="external">https://blog.csdn.net/weixin_42663840/article/details/81450705?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-13.baidujs&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-13.baidujs</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p id=&quot;div-border-top-green&quot;&gt;我不知道萧红可有类似的体验，是否担心华美的袍上爬满虱子，也许她知道，但她不在乎，她更想要取暖，即使将虱子一道披挂上身。她像忍耐虱子一样，忍耐着世界的冷眼，还装成一派天真模样，仿佛因不谙世事而无从察觉，就可以不受伤害。&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&quot;服务发现简介&quot;&gt;&lt;a href=&quot;#服务发现简介&quot; class=&quot;headerlink&quot; title=&quot;服务发现简介&quot;&gt;&lt;/a&gt;服务发现简介&lt;/h2&gt;&lt;p&gt;云原生、容器场景下按需的资源使用方式对于监控系统而言就意味着没有了一个固定的监控目标，所有的监控对象(基础设施、应用、服&lt;/p&gt;
&lt;p&gt;务)都在动态的变化，这对基于Push模式传统监控软件带来挑战。&lt;/p&gt;
    
    </summary>
    
      <category term="Prometheus" scheme="https://magiceses.github.io/categories/Prometheus/"/>
    
    
      <category term="Prometheus" scheme="https://magiceses.github.io/tags/Prometheus/"/>
    
  </entry>
  
  <entry>
    <title>Prometheus 源码分析-总览</title>
    <link href="https://magiceses.github.io/2020/10/03/prometheus-prometheus-2-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%80%BB%E8%A7%88/"/>
    <id>https://magiceses.github.io/2020/10/03/prometheus-prometheus-2-源码分析总览/</id>
    <published>2020-10-03T02:49:15.000Z</published>
    <updated>2021-10-02T04:54:59.216Z</updated>
    
    <content type="html"><![CDATA[<p id="div-border-top-green">人的一生更是如此不要去看低每一个人，更不要以自己现有的权利去欺压别人。现在混得好不代表以后就混的好，时刻提醒自己你今天奋斗了吗？<br></p><p>以下包括链接中的分析皆是平时网上学习以及自己用到的一些知识，简单做个总结，基于版本2.27</p><h2 id="架构总览"><a href="#架构总览" class="headerlink" title="架构总览"></a>架构总览</h2><p><img src="/images/prometheus-prometheus-6.png" alt="image"></p><a id="more"></a><p>Prometheus server 的核心功能模块是 HTTP server、TSDB 、服务发现和指标抓取</p><p>Prometheus 整个工作流程大概是这样的：</p><ul><li>通过 Service discovery 知道要抓取什么指标</li><li>抓取指标数据存入 TSDB</li><li>客户通过 HTTP server 使用 PromQL 查询结果</li></ul><h2 id="主要工作流程（main-go）"><a href="#主要工作流程（main-go）" class="headerlink" title="主要工作流程（main.go）"></a>主要工作流程（main.go）</h2><ol><li>设置命令行参数及其默认值和描述信息</li><li>解析启动命令的命令行参数为 cfg 实例</li><li>校验配置文件（–config.file 设置），默认是 prometheus.yml</li><li>打印 “Starting Prometheus” 和主机系统信息日志</li><li>初始化子任务对象</li><li>并发启动各个子任务</li></ol><h2 id="服务启动流程"><a href="#服务启动流程" class="headerlink" title="服务启动流程"></a>服务启动流程</h2><ol><li>接收 kill/web 终止信号，退出程序</li><li>启动 Scrape Discovery manager</li><li>启动 Notify Discovery manager</li><li>启动 Scrape manager</li><li>启动 Reload handler</li><li>初始加载配置</li><li>启动 Rule manager</li><li>初始化 TSDB</li><li>启动 Web server</li><li>启动 Notifier</li></ol><h2 id="服务预启动分析"><a href="#服务预启动分析" class="headerlink" title="服务预启动分析"></a>服务预启动分析</h2><ol><li><p>Storage组件初始化</p><p>Prometheus的Storage组件是时序数据库，包含两个：localStorage和remoteStorage．localStorage当前版本指TSDB，用于对metrics的本地存储存储，remoteStorage用于metrics的远程存储，其中fanoutStorage作为localStorage和remoteStorage的读写代理服务器．初始化流程如下</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prometheus/cmd/prometheus/main.<span class="keyword">go</span></span><br><span class="line"> </span><br><span class="line">localStorage  = &amp;tsdb.ReadyStorage&#123;&#125; <span class="comment">//本地存储</span></span><br><span class="line">remoteStorage = remote.NewStorage(log.With(logger, <span class="string">"component"</span>, <span class="string">"remote"</span>), <span class="comment">//远端存储 localStorage.StartTime, time.Duration(cfg.RemoteFlushDeadline))</span></span><br><span class="line">fanoutStorage = storage.NewFanout(logger, localStorage, remoteStorage) <span class="comment">//读写代理服务器</span></span><br></pre></td></tr></table></figure></li><li><p>notifier 组件初始化</p><p>notifier组件用于发送告警信息给AlertManager，通过方法notifier.NewManager完成初始化</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prometheus/cmd/prometheus/main.<span class="keyword">go</span></span><br><span class="line"> </span><br><span class="line">notifierManager = notifier.NewManager(&amp;cfg.notifier, log.With(logger, <span class="string">"component"</span>, <span class="string">"notifier"</span>))</span><br></pre></td></tr></table></figure></li><li><p>discoveryManagerScrape组件初始化</p><p>discoveryManagerScrape组件用于服务发现，当前版本支持多种服务发现系统，比如kuberneters等，通过方法discovery.NewManager完成初始化</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prometheus/cmd/prometheus/main.<span class="keyword">go</span></span><br><span class="line"> </span><br><span class="line">discoveryManagerScrape  = discovery.NewManager(ctxScrape, log.With(logger, <span class="string">"component"</span>, <span class="string">"discovery manager scrape"</span>), discovery.Name(<span class="string">"scrape"</span>))</span><br></pre></td></tr></table></figure></li><li><p>discoveryManagerNotify组件初始化</p><p>discoveryManagerNotify组件用于告警通知服务发现，比如AlertManager服务．也是通过方法discovery.NewManager完成初始化，不同的是，discoveryManagerNotify服务于notify，而discoveryManagerScrape服务与scrape</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prometheus/cmd/prometheus/main.<span class="keyword">go</span></span><br><span class="line"> </span><br><span class="line">discoveryManagerNotify  = discovery.NewManager(ctxNotify, log.With(logger, <span class="string">"component"</span>, <span class="string">"discovery manager notify"</span>), discovery.Name(<span class="string">"notify"</span>)</span><br></pre></td></tr></table></figure></li><li><p>scrapeManager组件初始化</p><p>scrapeManager组件利用discoveryManagerScrape组件发现的targets，抓取对应targets的所有metrics，并将抓取的metrics存储到fanoutStorage中，通过方法scrape.NewManager完成初始化</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prometheus/cmd/prometheus/main.<span class="keyword">go</span></span><br><span class="line"> </span><br><span class="line">scrapeManager = scrape.NewManager(log.With(logger, <span class="string">"component"</span>, <span class="string">"scrape manager"</span>), fanoutStorage)</span><br></pre></td></tr></table></figure></li><li><p>queryEngine组件</p><p>queryEngine组件用于rules查询和计算，通过方法promql.NewEngine完成初始化</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">prometheus/cmd/prometheus/main.<span class="keyword">go</span></span><br><span class="line"> </span><br><span class="line">opts = promql.EngineOpts&#123;</span><br><span class="line">    Logger:        log.With(logger, <span class="string">"component"</span>, <span class="string">"query engine"</span>),</span><br><span class="line">    Reg:           prometheus.DefaultRegisterer,</span><br><span class="line">    MaxConcurrent: cfg.queryConcurrency,　　　　　　　<span class="comment">//最大并发查询个数</span></span><br><span class="line">    MaxSamples:    cfg.queryMaxSamples,</span><br><span class="line">    Timeout:       time.Duration(cfg.queryTimeout),　<span class="comment">//查询超时时间</span></span><br><span class="line">&#125;</span><br><span class="line">queryEngine = promql.NewEngine(opts)</span><br></pre></td></tr></table></figure></li><li><p>ruleManager组件初始化</p><p>ruleManager组件通过方法rules.NewManager完成初始化．其中rules.NewManager的参数涉及多个组件：存储，queryEngine和notifier，整个流程包含rule计算和发送告警</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">prometheus/cmd/prometheus/main.<span class="keyword">go</span></span><br><span class="line"> </span><br><span class="line">ruleManager = rules.NewManager(&amp;rules.ManagerOptions&#123;</span><br><span class="line">    Appendable:      fanoutStorage,                        <span class="comment">//存储器</span></span><br><span class="line">    TSDB:            localStorage,　　　　　　　　　　　　　　<span class="comment">//本地时序数据库TSDB</span></span><br><span class="line">    QueryFunc:       rules.EngineQueryFunc(queryEngine, fanoutStorage), <span class="comment">//rules计算</span></span><br><span class="line">    NotifyFunc:      sendAlerts(notifierManager, cfg.web.ExternalURL.String()),　<span class="comment">//告警通知</span></span><br><span class="line">    Context:         ctxRule,　<span class="comment">//用于控制ruleManager组件的协程</span></span><br><span class="line">    ExternalURL:     cfg.web.ExternalURL,　<span class="comment">//通过Web对外开放的URL</span></span><br><span class="line">    Registerer:      prometheus.DefaultRegisterer, </span><br><span class="line">    Logger:          log.With(logger, <span class="string">"component"</span>, <span class="string">"rule manager"</span>),</span><br><span class="line">    OutageTolerance: time.Duration(cfg.outageTolerance), <span class="comment">//当prometheus重启时，保持alert状态（https://ganeshvernekar.com/gsoc-2018/persist-for-state/）</span></span><br><span class="line">    ForGracePeriod:  time.Duration(cfg.forGracePeriod),</span><br><span class="line">    ResendDelay:     time.Duration(cfg.resendDelay),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Web组件初始化</p><p>Web组件用于为Storage组件，queryEngine组件，scrapeManager组件， ruleManager组件和notifier 组件提供外部HTTP访问方式，初始化代码如下</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">prometheus/cmd/prometheus/main.<span class="keyword">go</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">cfg.web.Context = ctxWeb</span><br><span class="line">cfg.web.TSDB = localStorage.Get</span><br><span class="line">cfg.web.Storage = fanoutStorage</span><br><span class="line">cfg.web.QueryEngine = queryEngine</span><br><span class="line">cfg.web.ScrapeManager = scrapeManager</span><br><span class="line">cfg.web.RuleManager = ruleManager</span><br><span class="line">cfg.web.Notifier = notifierManager</span><br><span class="line"> </span><br><span class="line">cfg.web.Version = &amp;web.PrometheusVersion&#123;</span><br><span class="line">    Version:   version.Version,</span><br><span class="line">    Revision:  version.Revision,</span><br><span class="line">    Branch:    version.Branch,</span><br><span class="line">    BuildUser: version.BuildUser,</span><br><span class="line">    BuildDate: version.BuildDate,</span><br><span class="line">    GoVersion: version.GoVersion,</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">cfg.web.Flags = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Depends on cfg.web.ScrapeManager so needs to be after cfg.web.ScrapeManager = scrapeManager</span></span><br><span class="line">webHandler := web.New(log.With(logger, <span class="string">"component"</span>, <span class="string">"web"</span>), &amp;cfg.web)</span><br></pre></td></tr></table></figure></li></ol><p>以上几个服务组件在Web页面对外的访问如图所示</p><p><img src="/images/prometheus-prometheus-7.png" alt="img"></p><h2 id="服务配置分析"><a href="#服务配置分析" class="headerlink" title="服务配置分析"></a>服务配置分析</h2><p>可以发现，除了服务组件ruleManager用的方法是Update，其他服务组件的在匿名函数中通过各自的ApplyConfig方法，实现配置的管理</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">prometheus/cmd/prometheus/main.<span class="keyword">go</span></span><br><span class="line"> </span><br><span class="line">reloaders := []<span class="function"><span class="keyword">func</span><span class="params">(cfg *config.Config)</span> <span class="title">error</span></span>&#123;</span><br><span class="line">    remoteStorage.ApplyConfig, <span class="comment">//存储配置</span></span><br><span class="line">    webHandler.ApplyConfig,    <span class="comment">//web配置</span></span><br><span class="line">    notifierManager.ApplyConfig, <span class="comment">//notifier配置</span></span><br><span class="line">    scrapeManager.ApplyConfig,　　<span class="comment">//scrapeManger配置</span></span><br><span class="line">　　<span class="comment">//从配置文件中提取Section:scrape_configs</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(cfg *config.Config)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        c := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]sd_config.ServiceDiscoveryConfig)</span><br><span class="line">        <span class="keyword">for</span> _, v := <span class="keyword">range</span> cfg.ScrapeConfigs &#123;</span><br><span class="line">            c[v.JobName] = v.ServiceDiscoveryConfig</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> discoveryManagerScrape.ApplyConfig(c)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//从配置文件中提取Section:alerting</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(cfg *config.Config)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        c := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]sd_config.ServiceDiscoveryConfig)</span><br><span class="line">        <span class="keyword">for</span> _, v := <span class="keyword">range</span> cfg.AlertingConfig.AlertmanagerConfigs &#123;</span><br><span class="line">            <span class="comment">// AlertmanagerConfigs doesn't hold an unique identifier so we use the config hash as the identifier.</span></span><br><span class="line">            b, err := json.Marshal(v)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line">            c[fmt.Sprintf(<span class="string">"%x"</span>, md5.Sum(b))] = v.ServiceDiscoveryConfig</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> discoveryManagerNotify.ApplyConfig(c)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//从配置文件中提取Section:rule_files</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(cfg *config.Config)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">        <span class="comment">// Get all rule files matching the configuration paths.</span></span><br><span class="line">        <span class="keyword">var</span> files []<span class="keyword">string</span></span><br><span class="line">        <span class="keyword">for</span> _, pat := <span class="keyword">range</span> cfg.RuleFiles &#123;</span><br><span class="line">            fs, err := filepath.Glob(pat)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="comment">// The only error can be a bad pattern.</span></span><br><span class="line">                <span class="keyword">return</span> fmt.Errorf(<span class="string">"error retrieving rule files for %s: %s"</span>, pat, err)</span><br><span class="line">            &#125;</span><br><span class="line">            files = <span class="built_in">append</span>(files, fs...)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ruleManager.Update(time.Duration(cfg.GlobalConfig.EvaluationInterval), files)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，服务组件remoteStorage，webHandler，notifierManager和ScrapeManager的ApplyConfig方法，参数cfg *config.Config中传递的配置文件，是整个文件prometheus.yml，点击<a href="https://blog.csdn.net/weixin_43700106/article/details/117565266" target="_blank" rel="external">prometheus.yml</a>查看一个完整的配置文件示例</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prometheus/scrape/manager.<span class="keyword">go</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Manager)</span> <span class="title">ApplyConfig</span><span class="params">(cfg *config.Config)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而服务组件discoveryManagerScrape和discoveryManagerNotify的Appliconfig方法，参数中传递的配置文件，是文件中的一个Section</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prometheus/discovery/manager.<span class="keyword">go</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Manager)</span> <span class="title">ApplyConfig</span><span class="params">(cfg <span class="keyword">map</span>[<span class="keyword">string</span>]sd_config.ServiceDiscoveryConfig)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">     ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，需要利用匿名函数提前处理下，取出对应的Section</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">prometheus/cmd/prometheus/main.<span class="keyword">go</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//从配置文件中提取Section:scrape_configs</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(cfg *config.Config)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]sd_config.ServiceDiscoveryConfig)</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> cfg.ScrapeConfigs &#123;</span><br><span class="line">        c[v.JobName] = v.ServiceDiscoveryConfig</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> discoveryManagerScrape.ApplyConfig(c)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//从配置文件中提取Section:alerting</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(cfg *config.Config)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]sd_config.ServiceDiscoveryConfig)</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> cfg.AlertingConfig.AlertmanagerConfigs &#123;</span><br><span class="line">        <span class="comment">// AlertmanagerConfigs doesn't hold an unique identifier so we use the config hash as the identifier.</span></span><br><span class="line">        b, err := json.Marshal(v)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        c[fmt.Sprintf(<span class="string">"%x"</span>, md5.Sum(b))] = v.ServiceDiscoveryConfig</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> discoveryManagerNotify.ApplyConfig(c)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>服务组件ruleManager，在匿名函数中提取出Section:rule_files</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">prometheus/cmd/prometheus/main.<span class="keyword">go</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//从配置文件中提取Section:rule_files</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(cfg *config.Config)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// Get all rule files matching the configuration paths.</span></span><br><span class="line">    <span class="keyword">var</span> files []<span class="keyword">string</span></span><br><span class="line">    <span class="keyword">for</span> _, pat := <span class="keyword">range</span> cfg.RuleFiles &#123;</span><br><span class="line">        fs, err := filepath.Glob(pat)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// The only error can be a bad pattern.</span></span><br><span class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">"error retrieving rule files for %s: %s"</span>, pat, err)</span><br><span class="line">        &#125;</span><br><span class="line">        files = <span class="built_in">append</span>(files, fs...)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ruleManager.Update(time.Duration(cfg.GlobalConfig.EvaluationInterval), files)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>利用该组件内置的Update方法完成配置管理</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prometheus/rules/manager.<span class="keyword">go</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Manager)</span> <span class="title">Update</span><span class="params">(interval time.Duration, files []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，通过reloadConfig方法，加载各个服务组件的配置项</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">prometheus/cmd/prometheus/main.<span class="keyword">go</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reloadConfig</span><span class="params">(filename <span class="keyword">string</span>, logger log.Logger, rls ...<span class="keyword">func</span>(*config.Config)</span> <span class="title">error</span>) <span class="params">(err error)</span></span> &#123;</span><br><span class="line">level.Info(logger).Log(<span class="string">"msg"</span>, <span class="string">"Loading configuration file"</span>, <span class="string">"filename"</span>, filename)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">configSuccess.Set(<span class="number">1</span>)</span><br><span class="line">configSuccessTime.SetToCurrentTime()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">configSuccess.Set(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"> </span><br><span class="line">conf, err := config.LoadFile(filename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"couldn't load configuration (--config.file=%q): %v"</span>, filename, err)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">failed := <span class="literal">false</span></span><br><span class="line">　　<span class="comment">//通过一个for循环，加载各个服务组件的配置项</span></span><br><span class="line"><span class="keyword">for</span> _, rl := <span class="keyword">range</span> rls &#123;</span><br><span class="line"><span class="keyword">if</span> err := rl(conf); err != <span class="literal">nil</span> &#123;</span><br><span class="line">level.Error(logger).Log(<span class="string">"msg"</span>, <span class="string">"Failed to apply configuration"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">failed = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> failed &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"one or more errors occurred while applying the new configuration (--config.file=%q)"</span>, filename)</span><br><span class="line">&#125;</span><br><span class="line">promql.SetDefaultEvaluationInterval(time.Duration(conf.GlobalConfig.EvaluationInterval))</span><br><span class="line">level.Info(logger).Log(<span class="string">"msg"</span>, <span class="string">"Completed loading of configuration file"</span>, <span class="string">"filename"</span>, filename)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务启动分析"><a href="#服务启动分析" class="headerlink" title="服务启动分析"></a>服务启动分析</h2><p>这里引用了github.com/oklog/oklog/pkg/group包，实例化一个对象g，<a href="https://www.cnblogs.com/huanggze/p/11695602.html" target="_blank" rel="external">包详解</a></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">prometheus/cmd/prometheus/main.<span class="keyword">go</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// "github.com/oklog/oklog/pkg/group"</span></span><br><span class="line"><span class="keyword">var</span> g group.Group</span><br><span class="line">&#123;</span><br><span class="line">　　......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象g中包含各个服务组件的入口，通过调用Add方法把把这些入口添加到对象g中，以组件scrapeManager为例：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">prometheus/cmd/prometheus/main.<span class="keyword">go</span></span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Scrape manager.</span></span><br><span class="line">　　<span class="comment">//通过方法Add，把ScrapeManager组件添加到g中</span></span><br><span class="line">    g.Add(</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">            <span class="comment">// When the scrape manager receives a new targets list</span></span><br><span class="line">            <span class="comment">// it needs to read a valid config for each job.</span></span><br><span class="line">            <span class="comment">// It depends on the config being in sync with the discovery manager so</span></span><br><span class="line">            <span class="comment">// we wait until the config is fully loaded.</span></span><br><span class="line">            &lt;-reloadReady.C</span><br><span class="line">　　　　　　　<span class="comment">//ScrapeManager组件的启动函数</span></span><br><span class="line">            err := scrapeManager.Run(discoveryManagerScrape.SyncCh())</span><br><span class="line">            level.Info(logger).Log(<span class="string">"msg"</span>, <span class="string">"Scrape manager stopped"</span>)</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line">            <span class="comment">// Scrape manager needs to be stopped before closing the local TSDB</span></span><br><span class="line">            <span class="comment">// so that it doesn't try to write samples to a closed storage.</span></span><br><span class="line">            level.Info(logger).Log(<span class="string">"msg"</span>, <span class="string">"Stopping scrape manager..."</span>)</span><br><span class="line">            scrapeManager.Stop()</span><br><span class="line">        &#125;,</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过对象g，调用方法run，启动所有服务组件</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">prometheus/cmd/prometheus/main.<span class="keyword">go</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> err := g.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    level.Error(logger).Log(<span class="string">"err"</span>, err)</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">level.Info(logger).Log(<span class="string">"msg"</span>, <span class="string">"See you next time!"</span>)</span><br></pre></td></tr></table></figure><p>启动完成。</p><h2 id="main-函数注解"><a href="#main-函数注解" class="headerlink" title="main 函数注解"></a>main 函数注解</h2><p>prometheus/cmd/prometheus/main.go</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br><span class="line">1229</span><br><span class="line">1230</span><br><span class="line">1231</span><br><span class="line">1232</span><br><span class="line">1233</span><br><span class="line">1234</span><br><span class="line">1235</span><br><span class="line">1236</span><br><span class="line">1237</span><br><span class="line">1238</span><br><span class="line">1239</span><br><span class="line">1240</span><br><span class="line">1241</span><br><span class="line">1242</span><br><span class="line">1243</span><br><span class="line">1244</span><br><span class="line">1245</span><br><span class="line">1246</span><br><span class="line">1247</span><br><span class="line">1248</span><br><span class="line">1249</span><br><span class="line">1250</span><br><span class="line">1251</span><br><span class="line">1252</span><br><span class="line">1253</span><br><span class="line">1254</span><br><span class="line">1255</span><br><span class="line">1256</span><br><span class="line">1257</span><br><span class="line">1258</span><br><span class="line">1259</span><br><span class="line">1260</span><br><span class="line">1261</span><br><span class="line">1262</span><br><span class="line">1263</span><br><span class="line">1264</span><br><span class="line">1265</span><br><span class="line">1266</span><br><span class="line">1267</span><br><span class="line">1268</span><br><span class="line">1269</span><br><span class="line">1270</span><br><span class="line">1271</span><br><span class="line">1272</span><br><span class="line">1273</span><br><span class="line">1274</span><br><span class="line">1275</span><br><span class="line">1276</span><br><span class="line">1277</span><br><span class="line">1278</span><br><span class="line">1279</span><br><span class="line">1280</span><br><span class="line">1281</span><br><span class="line">1282</span><br><span class="line">1283</span><br><span class="line">1284</span><br><span class="line">1285</span><br><span class="line">1286</span><br><span class="line">1287</span><br><span class="line">1288</span><br><span class="line">1289</span><br><span class="line">1290</span><br><span class="line">1291</span><br><span class="line">1292</span><br><span class="line">1293</span><br><span class="line">1294</span><br><span class="line">1295</span><br><span class="line">1296</span><br><span class="line">1297</span><br><span class="line">1298</span><br><span class="line">1299</span><br><span class="line">1300</span><br><span class="line">1301</span><br><span class="line">1302</span><br><span class="line">1303</span><br><span class="line">1304</span><br><span class="line">1305</span><br><span class="line">1306</span><br><span class="line">1307</span><br><span class="line">1308</span><br><span class="line">1309</span><br><span class="line">1310</span><br><span class="line">1311</span><br><span class="line">1312</span><br><span class="line">1313</span><br><span class="line">1314</span><br><span class="line">1315</span><br><span class="line">1316</span><br><span class="line">1317</span><br><span class="line">1318</span><br><span class="line">1319</span><br><span class="line">1320</span><br><span class="line">1321</span><br><span class="line">1322</span><br><span class="line">1323</span><br><span class="line">1324</span><br><span class="line">1325</span><br><span class="line">1326</span><br><span class="line">1327</span><br><span class="line">1328</span><br><span class="line">1329</span><br><span class="line">1330</span><br><span class="line">1331</span><br><span class="line">1332</span><br><span class="line">1333</span><br><span class="line">1334</span><br><span class="line">1335</span><br><span class="line">1336</span><br><span class="line">1337</span><br><span class="line">1338</span><br><span class="line">1339</span><br><span class="line">1340</span><br><span class="line">1341</span><br><span class="line">1342</span><br><span class="line">1343</span><br><span class="line">1344</span><br><span class="line">1345</span><br><span class="line">1346</span><br><span class="line">1347</span><br><span class="line">1348</span><br><span class="line">1349</span><br><span class="line">1350</span><br><span class="line">1351</span><br><span class="line">1352</span><br><span class="line">1353</span><br><span class="line">1354</span><br><span class="line">1355</span><br><span class="line">1356</span><br><span class="line">1357</span><br><span class="line">1358</span><br><span class="line">1359</span><br><span class="line">1360</span><br><span class="line">1361</span><br><span class="line">1362</span><br><span class="line">1363</span><br><span class="line">1364</span><br><span class="line">1365</span><br><span class="line">1366</span><br><span class="line">1367</span><br><span class="line">1368</span><br><span class="line">1369</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright 2015 The Prometheus Authors</span></span><br><span class="line"><span class="comment">// Licensed under the Apache License, Version 2.0 (the "License");</span></span><br><span class="line"><span class="comment">// you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment">// You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment">// distributed under the License is distributed on an "AS IS" BASIS,</span></span><br><span class="line"><span class="comment">// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment">// See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment">// limitations under the License.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The main package for the Prometheus server executable.</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"math"</span></span><br><span class="line"><span class="string">"math/bits"</span></span><br><span class="line"><span class="string">"net"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">_ <span class="string">"net/http/pprof"</span> <span class="comment">// Comment this line to disable pprof endpoint.</span></span><br><span class="line"><span class="string">"net/url"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"os/signal"</span></span><br><span class="line"><span class="string">"path/filepath"</span></span><br><span class="line"><span class="string">"regexp"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"syscall"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/alecthomas/units"</span></span><br><span class="line"><span class="string">"github.com/go-kit/kit/log"</span></span><br><span class="line"><span class="string">"github.com/go-kit/kit/log/level"</span></span><br><span class="line">conntrack <span class="string">"github.com/mwitkow/go-conntrack"</span></span><br><span class="line"><span class="string">"github.com/oklog/run"</span></span><br><span class="line"><span class="string">"github.com/opentracing/opentracing-go"</span></span><br><span class="line"><span class="string">"github.com/pkg/errors"</span></span><br><span class="line"><span class="string">"github.com/prometheus/client_golang/prometheus"</span></span><br><span class="line"><span class="string">"github.com/prometheus/common/model"</span></span><br><span class="line"><span class="string">"github.com/prometheus/common/promlog"</span></span><br><span class="line">promlogflag <span class="string">"github.com/prometheus/common/promlog/flag"</span></span><br><span class="line"><span class="string">"github.com/prometheus/common/version"</span></span><br><span class="line">toolkit_web <span class="string">"github.com/prometheus/exporter-toolkit/web"</span></span><br><span class="line">toolkit_webflag <span class="string">"github.com/prometheus/exporter-toolkit/web/kingpinflag"</span></span><br><span class="line">jcfg <span class="string">"github.com/uber/jaeger-client-go/config"</span></span><br><span class="line">jprom <span class="string">"github.com/uber/jaeger-lib/metrics/prometheus"</span></span><br><span class="line"><span class="string">"go.uber.org/atomic"</span></span><br><span class="line">kingpin <span class="string">"gopkg.in/alecthomas/kingpin.v2"</span></span><br><span class="line">klog <span class="string">"k8s.io/klog"</span></span><br><span class="line">klogv2 <span class="string">"k8s.io/klog/v2"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/prometheus/prometheus/config"</span></span><br><span class="line"><span class="string">"github.com/prometheus/prometheus/discovery"</span></span><br><span class="line">_ <span class="string">"github.com/prometheus/prometheus/discovery/install"</span> <span class="comment">// Register service discovery implementations.</span></span><br><span class="line"><span class="string">"github.com/prometheus/prometheus/notifier"</span></span><br><span class="line"><span class="string">"github.com/prometheus/prometheus/pkg/exemplar"</span></span><br><span class="line"><span class="string">"github.com/prometheus/prometheus/pkg/labels"</span></span><br><span class="line"><span class="string">"github.com/prometheus/prometheus/pkg/logging"</span></span><br><span class="line"><span class="string">"github.com/prometheus/prometheus/pkg/relabel"</span></span><br><span class="line">prom_runtime <span class="string">"github.com/prometheus/prometheus/pkg/runtime"</span></span><br><span class="line"><span class="string">"github.com/prometheus/prometheus/promql"</span></span><br><span class="line"><span class="string">"github.com/prometheus/prometheus/rules"</span></span><br><span class="line"><span class="string">"github.com/prometheus/prometheus/scrape"</span></span><br><span class="line"><span class="string">"github.com/prometheus/prometheus/storage"</span></span><br><span class="line"><span class="string">"github.com/prometheus/prometheus/storage/remote"</span></span><br><span class="line"><span class="string">"github.com/prometheus/prometheus/tsdb"</span></span><br><span class="line"><span class="string">"github.com/prometheus/prometheus/util/strutil"</span></span><br><span class="line"><span class="string">"github.com/prometheus/prometheus/web"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line"><span class="comment">// 声明两个程序自身的监控指标</span></span><br><span class="line">configSuccess = prometheus.NewGauge(prometheus.GaugeOpts&#123;</span><br><span class="line">Name: <span class="string">"prometheus_config_last_reload_successful"</span>,</span><br><span class="line">Help: <span class="string">"Whether the last configuration reload attempt was successful."</span>,</span><br><span class="line">&#125;)</span><br><span class="line">configSuccessTime = prometheus.NewGauge(prometheus.GaugeOpts&#123;</span><br><span class="line">Name: <span class="string">"prometheus_config_last_reload_success_timestamp_seconds"</span>,</span><br><span class="line">Help: <span class="string">"Timestamp of the last successful configuration reload."</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认数据保留时间 15 天</span></span><br><span class="line">defaultRetentionString   = <span class="string">"15d"</span></span><br><span class="line">defaultRetentionDuration model.Duration</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">prometheus.MustRegister(version.NewCollector(<span class="string">"prometheus"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将默认数据保留时间从字符串转换为 model.Duration 类型，</span></span><br><span class="line"><span class="comment">// 其底层是 time.Duration 类型。</span></span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="comment">// model.ParseDuration 会对 defaultRetentionString 进行正则匹配，提取</span></span><br><span class="line"><span class="comment">// 各个单位的数值然后计算总的毫秒数</span></span><br><span class="line"><span class="comment">// 例如 "1y2w3d4h5m6s7ms" 就 解析成 [1y2w3d4h5m6s7ms 1y 1 2w 2 3d 3 4h 4 5m 5 6s 6 7ms 7]</span></span><br><span class="line"><span class="comment">// 然后计算乘积</span></span><br><span class="line">defaultRetentionDuration, err = model.ParseDuration(defaultRetentionString)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> flagConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">configFile <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">localStoragePath    <span class="keyword">string</span></span><br><span class="line">notifier            notifier.Options</span><br><span class="line">forGracePeriod      model.Duration</span><br><span class="line">outageTolerance     model.Duration</span><br><span class="line">resendDelay         model.Duration</span><br><span class="line">web                 web.Options</span><br><span class="line">tsdb                tsdbOptions</span><br><span class="line">lookbackDelta       model.Duration</span><br><span class="line">webTimeout          model.Duration</span><br><span class="line">queryTimeout        model.Duration</span><br><span class="line">queryConcurrency    <span class="keyword">int</span></span><br><span class="line">queryMaxSamples     <span class="keyword">int</span></span><br><span class="line">RemoteFlushDeadline model.Duration</span><br><span class="line"></span><br><span class="line">featureList []<span class="keyword">string</span></span><br><span class="line"><span class="comment">// These options are extracted from featureList</span></span><br><span class="line"><span class="comment">// for ease of use.</span></span><br><span class="line">enablePromQLAtModifier     <span class="keyword">bool</span></span><br><span class="line">enablePromQLNegativeOffset <span class="keyword">bool</span></span><br><span class="line">enableExpandExternalLabels <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">prometheusURL   <span class="keyword">string</span></span><br><span class="line">corsRegexString <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">promlogConfig promlog.Config</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// setFeatureListOptions sets the corresponding options from the featureList.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *flagConfig)</span> <span class="title">setFeatureListOptions</span><span class="params">(logger log.Logger)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">maxExemplars := c.tsdb.MaxExemplars</span><br><span class="line"><span class="comment">// Disabled at first. Value from the flag is used if exemplar-storage is set.</span></span><br><span class="line">c.tsdb.MaxExemplars = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> c.featureList &#123;</span><br><span class="line">opts := strings.Split(f, <span class="string">","</span>)</span><br><span class="line"><span class="keyword">for</span> _, o := <span class="keyword">range</span> opts &#123;</span><br><span class="line"><span class="keyword">switch</span> o &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"promql-at-modifier"</span>:</span><br><span class="line">c.enablePromQLAtModifier = <span class="literal">true</span></span><br><span class="line">level.Info(logger).Log(<span class="string">"msg"</span>, <span class="string">"Experimental promql-at-modifier enabled"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">"promql-negative-offset"</span>:</span><br><span class="line">c.enablePromQLNegativeOffset = <span class="literal">true</span></span><br><span class="line">level.Info(logger).Log(<span class="string">"msg"</span>, <span class="string">"Experimental promql-negative-offset enabled"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">"remote-write-receiver"</span>:</span><br><span class="line">c.web.RemoteWriteReceiver = <span class="literal">true</span></span><br><span class="line">level.Info(logger).Log(<span class="string">"msg"</span>, <span class="string">"Experimental remote-write-receiver enabled"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">"expand-external-labels"</span>:</span><br><span class="line">c.enableExpandExternalLabels = <span class="literal">true</span></span><br><span class="line">level.Info(logger).Log(<span class="string">"msg"</span>, <span class="string">"Experimental expand-external-labels enabled"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">"exemplar-storage"</span>:</span><br><span class="line">c.tsdb.MaxExemplars = maxExemplars</span><br><span class="line">level.Info(logger).Log(<span class="string">"msg"</span>, <span class="string">"Experimental in-memory exemplar storage enabled"</span>, <span class="string">"maxExemplars"</span>, maxExemplars)</span><br><span class="line"><span class="keyword">case</span> <span class="string">""</span>:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">level.Warn(logger).Log(<span class="string">"msg"</span>, <span class="string">"Unknown option for --enable-feature"</span>, <span class="string">"option"</span>, o)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> os.Getenv(<span class="string">"DEBUG"</span>) != <span class="string">""</span> &#123;</span><br><span class="line">runtime.SetBlockProfileRate(<span class="number">20</span>)</span><br><span class="line">runtime.SetMutexProfileFraction(<span class="number">20</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">oldFlagRetentionDuration model.Duration</span><br><span class="line">newFlagRetentionDuration model.Duration</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动配置项</span></span><br><span class="line">cfg := flagConfig&#123;</span><br><span class="line">notifier: notifier.Options&#123;</span><br><span class="line"><span class="comment">// 默认注册器注册 cpu 和 go 指标收集器</span></span><br><span class="line">Registerer: prometheus.DefaultRegisterer,</span><br><span class="line">&#125;,</span><br><span class="line">web: web.Options&#123;</span><br><span class="line">Registerer: prometheus.DefaultRegisterer,</span><br><span class="line">Gatherer:   prometheus.DefaultGatherer,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 初始化 go kit logger</span></span><br><span class="line">promlogConfig: promlog.Config&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kingpin 解析 Args[0]，即 prometheus，初始化 kingpin.Application</span></span><br><span class="line">a := kingpin.New(filepath.Base(os.Args[<span class="number">0</span>]), <span class="string">"The Prometheus monitoring server"</span>).UsageWriter(os.Stdout)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置一些标志位参数及其默认值</span></span><br><span class="line">a.Version(version.Print(<span class="string">"prometheus"</span>))</span><br><span class="line"></span><br><span class="line">a.HelpFlag.Short(<span class="string">'h'</span>)</span><br><span class="line"></span><br><span class="line">a.Flag(<span class="string">"config.file"</span>, <span class="string">"Prometheus configuration file path."</span>).</span><br><span class="line">Default(<span class="string">"prometheus.yml"</span>).StringVar(&amp;cfg.configFile)</span><br><span class="line"></span><br><span class="line">a.Flag(<span class="string">"web.listen-address"</span>, <span class="string">"Address to listen on for UI, API, and telemetry."</span>).</span><br><span class="line">Default(<span class="string">"0.0.0.0:9090"</span>).StringVar(&amp;cfg.web.ListenAddress)</span><br><span class="line"></span><br><span class="line">webConfig := toolkit_webflag.AddFlags(a)</span><br><span class="line"></span><br><span class="line"><span class="comment">// web 读取超时</span></span><br><span class="line">a.Flag(<span class="string">"web.read-timeout"</span>,</span><br><span class="line"><span class="string">"Maximum duration before timing out read of the request, and closing idle connections."</span>).</span><br><span class="line">Default(<span class="string">"5m"</span>).SetValue(&amp;cfg.webTimeout)</span><br><span class="line"></span><br><span class="line"><span class="comment">// web 的最大连接数</span></span><br><span class="line">a.Flag(<span class="string">"web.max-connections"</span>, <span class="string">"Maximum number of simultaneous connections."</span>).</span><br><span class="line">Default(<span class="string">"512"</span>).IntVar(&amp;cfg.web.MaxConnections)</span><br><span class="line"></span><br><span class="line">a.Flag(<span class="string">"web.external-url"</span>,</span><br><span class="line"><span class="string">"The URL under which Prometheus is externally reachable (for example, if Prometheus is served via a reverse proxy). Used for generating relative and absolute links back to Prometheus itself. If the URL has a path portion, it will be used to prefix all HTTP endpoints served by Prometheus. If omitted, relevant URL components will be derived automatically."</span>).</span><br><span class="line">PlaceHolder(<span class="string">"&lt;URL&gt;"</span>).StringVar(&amp;cfg.prometheusURL)</span><br><span class="line"></span><br><span class="line">a.Flag(<span class="string">"web.route-prefix"</span>,</span><br><span class="line"><span class="string">"Prefix for the internal routes of web endpoints. Defaults to path of --web.external-url."</span>).</span><br><span class="line">PlaceHolder(<span class="string">"&lt;path&gt;"</span>).StringVar(&amp;cfg.web.RoutePrefix)</span><br><span class="line"></span><br><span class="line">a.Flag(<span class="string">"web.user-assets"</span>, <span class="string">"Path to static asset directory, available at /user."</span>).</span><br><span class="line">PlaceHolder(<span class="string">"&lt;path&gt;"</span>).StringVar(&amp;cfg.web.UserAssetsPath)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 http 请求热加载配置文件或者关闭服务器</span></span><br><span class="line">a.Flag(<span class="string">"web.enable-lifecycle"</span>, <span class="string">"Enable shutdown and reload via HTTP request."</span>).</span><br><span class="line">Default(<span class="string">"false"</span>).BoolVar(&amp;cfg.web.EnableLifecycle)</span><br><span class="line"></span><br><span class="line">a.Flag(<span class="string">"web.enable-admin-api"</span>, <span class="string">"Enable API endpoints for admin control actions."</span>).</span><br><span class="line">Default(<span class="string">"false"</span>).BoolVar(&amp;cfg.web.EnableAdminAPI)</span><br><span class="line"></span><br><span class="line">a.Flag(<span class="string">"web.console.templates"</span>, <span class="string">"Path to the console template directory, available at /consoles."</span>).</span><br><span class="line">Default(<span class="string">"consoles"</span>).StringVar(&amp;cfg.web.ConsoleTemplatesPath)</span><br><span class="line"></span><br><span class="line">a.Flag(<span class="string">"web.console.libraries"</span>, <span class="string">"Path to the console library directory."</span>).</span><br><span class="line">Default(<span class="string">"console_libraries"</span>).StringVar(&amp;cfg.web.ConsoleLibrariesPath)</span><br><span class="line"></span><br><span class="line">a.Flag(<span class="string">"web.page-title"</span>, <span class="string">"Document title of Prometheus instance."</span>).</span><br><span class="line">Default(<span class="string">"Prometheus Time Series Collection and Processing Server"</span>).StringVar(&amp;cfg.web.PageTitle)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 限制访问源</span></span><br><span class="line">a.Flag(<span class="string">"web.cors.origin"</span>, <span class="string">`Regex for CORS origin. It is fully anchored. Example: 'https?://(domain1|domain2)\.com'`</span>).</span><br><span class="line">Default(<span class="string">".*"</span>).StringVar(&amp;cfg.corsRegexString)</span><br><span class="line"></span><br><span class="line">a.Flag(<span class="string">"storage.tsdb.path"</span>, <span class="string">"Base path for metrics storage."</span>).</span><br><span class="line">Default(<span class="string">"data/"</span>).StringVar(&amp;cfg.localStoragePath)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每两小时将 wal 落盘</span></span><br><span class="line">a.Flag(<span class="string">"storage.tsdb.min-block-duration"</span>, <span class="string">"Minimum duration of a data block before being persisted. For use in testing."</span>).</span><br><span class="line">Hidden().Default(<span class="string">"2h"</span>).SetValue(&amp;cfg.tsdb.MinBlockDuration)</span><br><span class="line"></span><br><span class="line">a.Flag(<span class="string">"storage.tsdb.max-block-duration"</span>,</span><br><span class="line"><span class="string">"Maximum duration compacted blocks may span. For use in testing. (Defaults to 10% of the retention period.)"</span>).</span><br><span class="line">Hidden().PlaceHolder(<span class="string">"&lt;duration&gt;"</span>).SetValue(&amp;cfg.tsdb.MaxBlockDuration)</span><br><span class="line"></span><br><span class="line">a.Flag(<span class="string">"storage.tsdb.max-block-chunk-segment-size"</span>,</span><br><span class="line"><span class="string">"The maximum size for a single chunk segment in a block. Example: 512MB"</span>).</span><br><span class="line">Hidden().PlaceHolder(<span class="string">"&lt;bytes&gt;"</span>).BytesVar(&amp;cfg.tsdb.MaxBlockChunkSegmentSize)</span><br><span class="line"></span><br><span class="line">a.Flag(<span class="string">"storage.tsdb.wal-segment-size"</span>,</span><br><span class="line"><span class="string">"Size at which to split the tsdb WAL segment files. Example: 100MB"</span>).</span><br><span class="line">Hidden().PlaceHolder(<span class="string">"&lt;bytes&gt;"</span>).BytesVar(&amp;cfg.tsdb.WALSegmentSize)</span><br><span class="line"></span><br><span class="line">a.Flag(<span class="string">"storage.tsdb.retention"</span>, <span class="string">"[DEPRECATED] How long to retain samples in storage. This flag has been deprecated, use \"storage.tsdb.retention.time\" instead."</span>).</span><br><span class="line">SetValue(&amp;oldFlagRetentionDuration)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存的时序数据的长度，默认15天，最多</span></span><br><span class="line">a.Flag(<span class="string">"storage.tsdb.retention.time"</span>, <span class="string">"How long to retain samples in storage. When this flag is set it overrides \"storage.tsdb.retention\". If neither this flag nor \"storage.tsdb.retention\" nor \"storage.tsdb.retention.size\" is set, the retention time defaults to "</span>+defaultRetentionString+<span class="string">". Units Supported: y, w, d, h, m, s, ms."</span>).</span><br><span class="line">SetValue(&amp;newFlagRetentionDuration)</span><br><span class="line"></span><br><span class="line">a.Flag(<span class="string">"storage.tsdb.retention.size"</span>, <span class="string">"[EXPERIMENTAL] Maximum number of bytes that can be stored for blocks. A unit is required, supported units: B, KB, MB, GB, TB, PB, EB. Ex: \"512MB\". This flag is experimental and can be changed in future releases."</span>).</span><br><span class="line">BytesVar(&amp;cfg.tsdb.MaxBytes)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不在 data 目录创建锁文件</span></span><br><span class="line">a.Flag(<span class="string">"storage.tsdb.no-lockfile"</span>, <span class="string">"Do not create lockfile in data directory."</span>).</span><br><span class="line">Default(<span class="string">"false"</span>).BoolVar(&amp;cfg.tsdb.NoLockfile)</span><br><span class="line"></span><br><span class="line">a.Flag(<span class="string">"storage.tsdb.allow-overlapping-blocks"</span>, <span class="string">"[EXPERIMENTAL] Allow overlapping blocks, which in turn enables vertical compaction and vertical query merge."</span>).</span><br><span class="line">Default(<span class="string">"false"</span>).BoolVar(&amp;cfg.tsdb.AllowOverlappingBlocks)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩 wal，默认压缩</span></span><br><span class="line">a.Flag(<span class="string">"storage.tsdb.wal-compression"</span>, <span class="string">"Compress the tsdb WAL."</span>).</span><br><span class="line">Default(<span class="string">"true"</span>).BoolVar(&amp;cfg.tsdb.WALCompression)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭或者重新加载配置前等待样本远程写落盘的时长，默认1分钟，应该是写 wal 的时间，不确定，远程读写没有接触过</span></span><br><span class="line">a.Flag(<span class="string">"storage.remote.flush-deadline"</span>, <span class="string">"How long to wait flushing sample on shutdown or config reload."</span>).</span><br><span class="line">Default(<span class="string">"1m"</span>).PlaceHolder(<span class="string">"&lt;duration&gt;"</span>).SetValue(&amp;cfg.RemoteFlushDeadline)</span><br><span class="line"></span><br><span class="line">a.Flag(<span class="string">"storage.remote.read-sample-limit"</span>, <span class="string">"Maximum overall number of samples to return via the remote read interface, in a single query. 0 means no limit. This limit is ignored for streamed response types."</span>).</span><br><span class="line">Default(<span class="string">"5e7"</span>).IntVar(&amp;cfg.web.RemoteReadSampleLimit)</span><br><span class="line"></span><br><span class="line">a.Flag(<span class="string">"storage.remote.read-concurrent-limit"</span>, <span class="string">"Maximum number of concurrent remote read calls. 0 means no limit."</span>).</span><br><span class="line">Default(<span class="string">"10"</span>).IntVar(&amp;cfg.web.RemoteReadConcurrencyLimit)</span><br><span class="line"></span><br><span class="line">a.Flag(<span class="string">"storage.remote.read-max-bytes-in-frame"</span>, <span class="string">"Maximum number of bytes in a single frame for streaming remote read response types before marshalling. Note that client might have limit on frame size as well. 1MB as recommended by protobuf by default."</span>).</span><br><span class="line">Default(<span class="string">"1048576"</span>).IntVar(&amp;cfg.web.RemoteReadBytesInFrame)</span><br><span class="line"></span><br><span class="line">a.Flag(<span class="string">"storage.exemplars.exemplars-limit"</span>, <span class="string">"[EXPERIMENTAL] Maximum number of exemplars to store in in-memory exemplar storage total. 0 disables the exemplar storage. This flag is effective only with --enable-feature=exemplar-storage."</span>).</span><br><span class="line">Default(<span class="string">"100000"</span>).IntVar(&amp;cfg.tsdb.MaxExemplars)</span><br><span class="line"></span><br><span class="line"><span class="comment">// rules 文件允许设置的 for 字段的最大值</span></span><br><span class="line">a.Flag(<span class="string">"rules.alert.for-outage-tolerance"</span>, <span class="string">"Max time to tolerate prometheus outage for restoring \"for\" state of alert."</span>).</span><br><span class="line">Default(<span class="string">"1h"</span>).SetValue(&amp;cfg.outageTolerance)</span><br><span class="line"></span><br><span class="line">a.Flag(<span class="string">"rules.alert.for-grace-period"</span>, <span class="string">"Minimum duration between alert and restored \"for\" state. This is maintained only for alerts with configured \"for\" time greater than grace period."</span>).</span><br><span class="line">Default(<span class="string">"10m"</span>).SetValue(&amp;cfg.forGracePeriod)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 间隔多久向 am 重发一次告警信息</span></span><br><span class="line">a.Flag(<span class="string">"rules.alert.resend-delay"</span>, <span class="string">"Minimum amount of time to wait before resending an alert to Alertmanager."</span>).</span><br><span class="line">Default(<span class="string">"1m"</span>).SetValue(&amp;cfg.resendDelay)</span><br><span class="line"></span><br><span class="line">a.Flag(<span class="string">"scrape.adjust-timestamps"</span>, <span class="string">"Adjust scrape timestamps by up to 2ms to align them to the intended schedule. See https://github.com/prometheus/prometheus/issues/7846 for more context. Experimental. This flag will be removed in a future release."</span>).</span><br><span class="line">Hidden().Default(<span class="string">"true"</span>).BoolVar(&amp;scrape.AlignScrapeTimestamps)</span><br><span class="line"></span><br><span class="line"><span class="comment">// pending 状态的告警队列长度</span></span><br><span class="line">a.Flag(<span class="string">"alertmanager.notification-queue-capacity"</span>, <span class="string">"The capacity of the queue for pending Alertmanager notifications."</span>).</span><br><span class="line">Default(<span class="string">"10000"</span>).IntVar(&amp;cfg.notifier.QueueCapacity)</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Remove in Prometheus 3.0.</span></span><br><span class="line"><span class="comment">// 发送给 am 告警的超时时长</span></span><br><span class="line">alertmanagerTimeout := a.Flag(<span class="string">"alertmanager.timeout"</span>, <span class="string">"[DEPRECATED] This flag has no effect."</span>).Hidden().String()</span><br><span class="line"></span><br><span class="line">a.Flag(<span class="string">"query.lookback-delta"</span>, <span class="string">"The maximum lookback duration for retrieving metrics during expression evaluations and federation."</span>).</span><br><span class="line">Default(<span class="string">"5m"</span>).SetValue(&amp;cfg.lookbackDelta)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询表达式超时时长，默认2分钟</span></span><br><span class="line">a.Flag(<span class="string">"query.timeout"</span>, <span class="string">"Maximum time a query may take before being aborted."</span>).</span><br><span class="line">Default(<span class="string">"2m"</span>).SetValue(&amp;cfg.queryTimeout)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并发查询的数量，感觉 cpu 和内存资源比较充裕的话可以适当放大</span></span><br><span class="line">a.Flag(<span class="string">"query.max-concurrency"</span>, <span class="string">"Maximum number of queries executed concurrently."</span>).</span><br><span class="line">Default(<span class="string">"20"</span>).IntVar(&amp;cfg.queryConcurrency)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一次查询最多加载到内存的样本数，也是最多返回的样本数</span></span><br><span class="line">a.Flag(<span class="string">"query.max-samples"</span>, <span class="string">"Maximum number of samples a single query can load into memory. Note that queries will fail if they try to load more samples than this into memory, so this also limits the number of samples a query can return."</span>).</span><br><span class="line">Default(<span class="string">"50000000"</span>).IntVar(&amp;cfg.queryMaxSamples)</span><br><span class="line"></span><br><span class="line">a.Flag(<span class="string">"enable-feature"</span>, <span class="string">"Comma separated feature names to enable. Valid options: promql-at-modifier, promql-negative-offset, remote-write-receiver, exemplar-storage, expand-external-labels. See https://prometheus.io/docs/prometheus/latest/disabled_features/ for more details."</span>).</span><br><span class="line">Default(<span class="string">""</span>).StringsVar(&amp;cfg.featureList)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加日志设置的标志位参数，有日志级别（[debug, info, warn, error]"）和日志格式（[logfmt, json]）</span></span><br><span class="line">promlogflag.AddFlags(a, &amp;cfg.promlogConfig)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析、校验参数</span></span><br><span class="line">_, err := a.Parse(os.Args[<span class="number">1</span>:])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintln(os.Stderr, errors.Wrapf(err, <span class="string">"Error parsing commandline arguments"</span>))</span><br><span class="line">a.Usage(os.Args[<span class="number">1</span>:])</span><br><span class="line">os.Exit(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据配置文件初始化 logger</span></span><br><span class="line">logger := promlog.New(&amp;cfg.promlogConfig)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := cfg.setFeatureListOptions(logger); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintln(os.Stderr, errors.Wrapf(err, <span class="string">"Error parsing feature list"</span>))</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检验配置参数</span></span><br><span class="line">cfg.web.ExternalURL, err = computeExternalURL(cfg.prometheusURL, cfg.web.ListenAddress)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintln(os.Stderr, errors.Wrapf(err, <span class="string">"parse external URL %q"</span>, cfg.prometheusURL))</span><br><span class="line">os.Exit(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cfg.web.CORSOrigin, err = compileCORSRegexString(cfg.corsRegexString)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintln(os.Stderr, errors.Wrapf(err, <span class="string">"could not compile CORS regex string %q"</span>, cfg.corsRegexString))</span><br><span class="line">os.Exit(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> *alertmanagerTimeout != <span class="string">""</span> &#123;</span><br><span class="line">level.Warn(logger).Log(<span class="string">"msg"</span>, <span class="string">"The flag --alertmanager.timeout has no effect and will be removed in the future."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Throw error for invalid config before starting other components.</span></span><br><span class="line"><span class="comment">// 校验命令行参数配置的 prometheus 配置文件是否有效，如果 配置文件（yml）为空就使用默认配置</span></span><br><span class="line"><span class="comment">// 校验后并没有声明 config 对象并把解析结果赋值给它，这里仅仅是解析。</span></span><br><span class="line"><span class="keyword">if</span> _, err := config.LoadFile(cfg.configFile, <span class="literal">false</span>, log.NewNopLogger()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">level.Error(logger).Log(<span class="string">"msg"</span>, fmt.Sprintf(<span class="string">"Error loading config (--config.file=%s)"</span>, cfg.configFile), <span class="string">"err"</span>, err)</span><br><span class="line">os.Exit(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Now that the validity of the config is established, set the config</span></span><br><span class="line"><span class="comment">// success metrics accordingly, although the config isn't really loaded</span></span><br><span class="line"><span class="comment">// yet. This will happen later (including setting these metrics again),</span></span><br><span class="line"><span class="comment">// but if we don't do it now, the metrics will stay at zero until the</span></span><br><span class="line"><span class="comment">// startup procedure is complete, which might take long enough to</span></span><br><span class="line"><span class="comment">// trigger alerts about an invalid config.</span></span><br><span class="line"><span class="comment">// 配置文件的有效性已经确立，即便尚未加载配置，将自身的 metrics 里的 prometheus_config_last_reload_successful 设置为1。</span></span><br><span class="line"><span class="comment">// 后面会加载配置并再次设置这个 metric，但是如果现在不做这一步，这个 metric 会一直为 0 直到启动过程完成，</span></span><br><span class="line"><span class="comment">// prometheus_config_last_reload_successful 为 0 的时间也就是启动的时间足够长就可能触发配置无效的告警。</span></span><br><span class="line">configSuccess.Set(<span class="number">1</span>)</span><br><span class="line">configSuccessTime.SetToCurrentTime()</span><br><span class="line"></span><br><span class="line">cfg.web.ReadTimeout = time.Duration(cfg.webTimeout)</span><br><span class="line"><span class="comment">// Default -web.route-prefix to path of -web.external-url.</span></span><br><span class="line"><span class="keyword">if</span> cfg.web.RoutePrefix == <span class="string">""</span> &#123;</span><br><span class="line">cfg.web.RoutePrefix = cfg.web.ExternalURL.Path</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// RoutePrefix must always be at least '/'.</span></span><br><span class="line">cfg.web.RoutePrefix = <span class="string">"/"</span> + strings.Trim(cfg.web.RoutePrefix, <span class="string">"/"</span>)</span><br><span class="line"></span><br><span class="line">&#123; <span class="comment">// Time retention settings.</span></span><br><span class="line"><span class="keyword">if</span> oldFlagRetentionDuration != <span class="number">0</span> &#123;</span><br><span class="line">level.Warn(logger).Log(<span class="string">"deprecation_notice"</span>, <span class="string">"'storage.tsdb.retention' flag is deprecated use 'storage.tsdb.retention.time' instead."</span>)</span><br><span class="line">cfg.tsdb.RetentionDuration = oldFlagRetentionDuration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// When the new flag is set it takes precedence.</span></span><br><span class="line"><span class="keyword">if</span> newFlagRetentionDuration != <span class="number">0</span> &#123;</span><br><span class="line">cfg.tsdb.RetentionDuration = newFlagRetentionDuration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> cfg.tsdb.RetentionDuration == <span class="number">0</span> &amp;&amp; cfg.tsdb.MaxBytes == <span class="number">0</span> &#123;</span><br><span class="line">cfg.tsdb.RetentionDuration = defaultRetentionDuration</span><br><span class="line">level.Info(logger).Log(<span class="string">"msg"</span>, <span class="string">"No time or size retention was set so using the default time retention"</span>, <span class="string">"duration"</span>, defaultRetentionDuration)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for overflows. This limits our max retention to 100y.</span></span><br><span class="line"><span class="comment">// 如果设置的时序数据保留时长溢出整数，就限制为 100 年。最大可设置的值为292y。</span></span><br><span class="line"><span class="keyword">if</span> cfg.tsdb.RetentionDuration &lt; <span class="number">0</span> &#123;</span><br><span class="line">y, err := model.ParseDuration(<span class="string">"100y"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">cfg.tsdb.RetentionDuration = y</span><br><span class="line">level.Warn(logger).Log(<span class="string">"msg"</span>, <span class="string">"Time retention value is too high. Limiting to: "</span>+y.String())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123; <span class="comment">// Max block size  settings.</span></span><br><span class="line"><span class="keyword">if</span> cfg.tsdb.MaxBlockDuration == <span class="number">0</span> &#123;</span><br><span class="line">maxBlockDuration, err := model.ParseDuration(<span class="string">"31d"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// When the time retention is set and not too big use to define the max block duration.</span></span><br><span class="line"><span class="keyword">if</span> cfg.tsdb.RetentionDuration != <span class="number">0</span> &amp;&amp; cfg.tsdb.RetentionDuration/<span class="number">10</span> &lt; maxBlockDuration &#123;</span><br><span class="line">maxBlockDuration = cfg.tsdb.RetentionDuration / <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cfg.tsdb.MaxBlockDuration = maxBlockDuration</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置默认的指标估值时间间隔</span></span><br><span class="line">noStepSubqueryInterval := &amp;safePromQLNoStepSubqueryInterval&#123;&#125;</span><br><span class="line">noStepSubqueryInterval.Set(config.DefaultGlobalConfig.EvaluationInterval)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Above level 6, the k8s client would log bearer tokens in clear-text.</span></span><br><span class="line">klog.ClampLevel(<span class="number">6</span>)</span><br><span class="line">klog.SetLogger(log.With(logger, <span class="string">"component"</span>, <span class="string">"k8s_client_runtime"</span>))</span><br><span class="line">klogv2.ClampLevel(<span class="number">6</span>)</span><br><span class="line">klogv2.SetLogger(log.With(logger, <span class="string">"component"</span>, <span class="string">"k8s_client_runtime"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印启动日志</span></span><br><span class="line">level.Info(logger).Log(<span class="string">"msg"</span>, <span class="string">"Starting Prometheus"</span>, <span class="string">"version"</span>, version.Info())</span><br><span class="line"><span class="comment">// 32位系统兼容性提示信息</span></span><br><span class="line"><span class="keyword">if</span> bits.UintSize &lt; <span class="number">64</span> &#123;</span><br><span class="line">level.Warn(logger).Log(<span class="string">"msg"</span>, <span class="string">"This Prometheus binary has not been compiled for a 64-bit architecture. Due to virtual memory constraints of 32-bit systems, it is highly recommended to switch to a 64-bit binary of Prometheus."</span>, <span class="string">"GOARCH"</span>, runtime.GOARCH)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印系统信息日志</span></span><br><span class="line">level.Info(logger).Log(<span class="string">"build_context"</span>, version.BuildContext())</span><br><span class="line">level.Info(logger).Log(<span class="string">"host_details"</span>, prom_runtime.Uname())</span><br><span class="line">level.Info(logger).Log(<span class="string">"fd_limits"</span>, prom_runtime.FdLimits())</span><br><span class="line">level.Info(logger).Log(<span class="string">"vm_limits"</span>, prom_runtime.VMLimits())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明和 scraper 和存储相关结构体变量</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">localStorage  = &amp;readyStorage&#123;&#125;</span><br><span class="line">scraper       = &amp;readyScrapeManager&#123;&#125;</span><br><span class="line">remoteStorage = remote.NewStorage(log.With(logger, <span class="string">"component"</span>, <span class="string">"remote"</span>), prometheus.DefaultRegisterer, localStorage.StartTime, cfg.localStoragePath, time.Duration(cfg.RemoteFlushDeadline), scraper)</span><br><span class="line">fanoutStorage = storage.NewFanout(logger, localStorage, remoteStorage)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line"><span class="comment">// cancel web 的 context</span></span><br><span class="line">ctxWeb, cancelWeb = context.WithCancel(context.Background())</span><br><span class="line">ctxRule           = context.Background()</span><br><span class="line"></span><br><span class="line"><span class="comment">// notifier 是用于向 am 发送告警的</span></span><br><span class="line">notifierManager = notifier.NewManager(&amp;cfg.notifier, log.With(logger, <span class="string">"component"</span>, <span class="string">"notifier"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// cancel scrape 的 context</span></span><br><span class="line">ctxScrape, cancelScrape = context.WithCancel(context.Background())</span><br><span class="line"><span class="comment">// 声明 discovery manager，将其 context 设置为 scrape 的 context</span></span><br><span class="line">discoveryManagerScrape  = discovery.NewManager(ctxScrape, log.With(logger, <span class="string">"component"</span>, <span class="string">"discovery manager scrape"</span>), discovery.Name(<span class="string">"scrape"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一共有两个 discovery.Manager 一个是上面的 scrape，一个是下面的 notify</span></span><br><span class="line">ctxNotify, cancelNotify = context.WithCancel(context.Background())</span><br><span class="line">discoveryManagerNotify  = discovery.NewManager(ctxNotify, log.With(logger, <span class="string">"component"</span>, <span class="string">"discovery manager notify"</span>), discovery.Name(<span class="string">"notify"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 scrapeManager，fanout Storage 是一个读写多个底层存储的代理</span></span><br><span class="line">scrapeManager = scrape.NewManager(log.With(logger, <span class="string">"component"</span>, <span class="string">"scrape manager"</span>), fanoutStorage)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 promql 的引擎配置</span></span><br><span class="line">opts = promql.EngineOpts&#123;</span><br><span class="line">Logger:                   log.With(logger, <span class="string">"component"</span>, <span class="string">"query engine"</span>),</span><br><span class="line">Reg:                      prometheus.DefaultRegisterer,</span><br><span class="line">MaxSamples:               cfg.queryMaxSamples,</span><br><span class="line">Timeout:                  time.Duration(cfg.queryTimeout),</span><br><span class="line">ActiveQueryTracker:       promql.NewActiveQueryTracker(cfg.localStoragePath, cfg.queryConcurrency, log.With(logger, <span class="string">"component"</span>, <span class="string">"activeQueryTracker"</span>)),</span><br><span class="line">LookbackDelta:            time.Duration(cfg.lookbackDelta),</span><br><span class="line">NoStepSubqueryIntervalFn: noStepSubqueryInterval.Get,</span><br><span class="line">EnableAtModifier:         cfg.enablePromQLAtModifier,</span><br><span class="line">EnableNegativeOffset:     cfg.enablePromQLNegativeOffset,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  声明 promql 的 quieryEngine</span></span><br><span class="line">queryEngine = promql.NewEngine(opts)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 ruleManager</span></span><br><span class="line">ruleManager = rules.NewManager(&amp;rules.ManagerOptions&#123;</span><br><span class="line">Appendable:      fanoutStorage,</span><br><span class="line">Queryable:       localStorage,</span><br><span class="line">QueryFunc:       rules.EngineQueryFunc(queryEngine, fanoutStorage),</span><br><span class="line">NotifyFunc:      sendAlerts(notifierManager, cfg.web.ExternalURL.String()),</span><br><span class="line">Context:         ctxRule,</span><br><span class="line">ExternalURL:     cfg.web.ExternalURL,</span><br><span class="line">Registerer:      prometheus.DefaultRegisterer,</span><br><span class="line">Logger:          log.With(logger, <span class="string">"component"</span>, <span class="string">"rule manager"</span>),</span><br><span class="line">OutageTolerance: time.Duration(cfg.outageTolerance),</span><br><span class="line">ForGracePeriod:  time.Duration(cfg.forGracePeriod),</span><br><span class="line">ResendDelay:     time.Duration(cfg.resendDelay),</span><br><span class="line">&#125;)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 scraper 的 scrapeManager 字段值</span></span><br><span class="line">scraper.Set(scrapeManager)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从命令行解析的配置项都赋值给 cfg.web 的配置项</span></span><br><span class="line">cfg.web.Context = ctxWeb</span><br><span class="line">cfg.web.TSDBRetentionDuration = cfg.tsdb.RetentionDuration</span><br><span class="line">cfg.web.TSDBMaxBytes = cfg.tsdb.MaxBytes</span><br><span class="line">cfg.web.TSDBDir = cfg.localStoragePath</span><br><span class="line">cfg.web.LocalStorage = localStorage</span><br><span class="line">cfg.web.Storage = fanoutStorage</span><br><span class="line">cfg.web.ExemplarStorage = localStorage</span><br><span class="line">cfg.web.QueryEngine = queryEngine</span><br><span class="line">cfg.web.ScrapeManager = scrapeManager</span><br><span class="line">cfg.web.RuleManager = ruleManager</span><br><span class="line">cfg.web.Notifier = notifierManager</span><br><span class="line">cfg.web.LookbackDelta = time.Duration(cfg.lookbackDelta)</span><br><span class="line"></span><br><span class="line">cfg.web.Version = &amp;web.PrometheusVersion&#123;</span><br><span class="line">Version:   version.Version,</span><br><span class="line">Revision:  version.Revision,</span><br><span class="line">Branch:    version.Branch,</span><br><span class="line">BuildUser: version.BuildUser,</span><br><span class="line">BuildDate: version.BuildDate,</span><br><span class="line">GoVersion: version.GoVersion,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把 Prometheus 启动的配置参数都记录在这个 map 里</span></span><br><span class="line">cfg.web.Flags = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Exclude kingpin default flags to expose only Prometheus ones.</span></span><br><span class="line">boilerplateFlags := kingpin.New(<span class="string">""</span>, <span class="string">""</span>).Version(<span class="string">""</span>)</span><br><span class="line"><span class="keyword">for</span> _, f := <span class="keyword">range</span> a.Model().Flags &#123;</span><br><span class="line"><span class="keyword">if</span> boilerplateFlags.GetFlag(f.Name) != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cfg.web.Flags[f.Name] = f.Value.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Depends on cfg.web.ScrapeManager so needs to be after cfg.web.ScrapeManager = scrapeManager.</span></span><br><span class="line">webHandler := web.New(log.With(logger, <span class="string">"component"</span>, <span class="string">"web"</span>), &amp;cfg.web)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Monitor outgoing connections on default transport with conntrack.</span></span><br><span class="line">http.DefaultTransport.(*http.Transport).DialContext = conntrack.NewDialContextFunc(</span><br><span class="line">conntrack.DialWithTracing(),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明多个 reloader</span></span><br><span class="line">reloaders := []reloader&#123;</span><br><span class="line">&#123;</span><br><span class="line">name:     <span class="string">"remote_storage"</span>,</span><br><span class="line">reloader: remoteStorage.ApplyConfig,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">name:     <span class="string">"web_handler"</span>,</span><br><span class="line">reloader: webHandler.ApplyConfig,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">name: <span class="string">"query_engine"</span>,</span><br><span class="line">reloader: <span class="function"><span class="keyword">func</span><span class="params">(cfg *config.Config)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> cfg.GlobalConfig.QueryLogFile == <span class="string">""</span> &#123;</span><br><span class="line">queryEngine.SetQueryLogger(<span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">l, err := logging.NewJSONFileLogger(cfg.GlobalConfig.QueryLogFile)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">queryEngine.SetQueryLogger(l)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;, &#123;</span><br><span class="line"><span class="comment">// The Scrape and notifier managers need to reload before the Discovery manager as</span></span><br><span class="line"><span class="comment">// they need to read the most updated config when receiving the new targets list.</span></span><br><span class="line"><span class="comment">// scrape 和 notifier manager 要在 discovery manager 之前重新加载，因为它们要在获取新的监控目标之前重新配置。</span></span><br><span class="line">name:     <span class="string">"scrape"</span>,</span><br><span class="line">reloader: scrapeManager.ApplyConfig,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">name: <span class="string">"scrape_sd"</span>,</span><br><span class="line">reloader: <span class="function"><span class="keyword">func</span><span class="params">(cfg *config.Config)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]discovery.Configs)</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> cfg.ScrapeConfigs &#123;</span><br><span class="line">c[v.JobName] = v.ServiceDiscoveryConfigs</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> discoveryManagerScrape.ApplyConfig(c)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">name:     <span class="string">"notify"</span>,</span><br><span class="line">reloader: notifierManager.ApplyConfig,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">name: <span class="string">"notify_sd"</span>,</span><br><span class="line">reloader: <span class="function"><span class="keyword">func</span><span class="params">(cfg *config.Config)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]discovery.Configs)</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> cfg.AlertingConfig.AlertmanagerConfigs.ToMap() &#123;</span><br><span class="line">c[k] = v.ServiceDiscoveryConfigs</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> discoveryManagerNotify.ApplyConfig(c)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">name: <span class="string">"rules"</span>,</span><br><span class="line">reloader: <span class="function"><span class="keyword">func</span><span class="params">(cfg *config.Config)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// Get all rule files matching the configuration paths.</span></span><br><span class="line"><span class="keyword">var</span> files []<span class="keyword">string</span></span><br><span class="line"><span class="keyword">for</span> _, pat := <span class="keyword">range</span> cfg.RuleFiles &#123;</span><br><span class="line">fs, err := filepath.Glob(pat)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// The only error can be a bad pattern.</span></span><br><span class="line"><span class="keyword">return</span> errors.Wrapf(err, <span class="string">"error retrieving rule files for %s"</span>, pat)</span><br><span class="line">&#125;</span><br><span class="line">files = <span class="built_in">append</span>(files, fs...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ruleManager.Update(</span><br><span class="line">time.Duration(cfg.GlobalConfig.EvaluationInterval),</span><br><span class="line">files,</span><br><span class="line">cfg.GlobalConfig.ExternalLabels,</span><br><span class="line">)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册自身的 metric</span></span><br><span class="line">prometheus.MustRegister(configSuccess)</span><br><span class="line">prometheus.MustRegister(configSuccessTime)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start all components while we wait for TSDB to open but only load</span></span><br><span class="line"><span class="comment">// initial config and mark ourselves as ready after it completed.</span></span><br><span class="line"><span class="comment">// 在等待开启 TSDB 的时候启动所有的组件，进加载初始配置，全部启动完成后标记为 ready。</span></span><br><span class="line"><span class="comment">// 这个 channel 初始化 DB 完成的信号</span></span><br><span class="line">dbOpen := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// sync.Once is used to make sure we can close the channel at different execution stages(SIGTERM or when the config is loaded).</span></span><br><span class="line"><span class="comment">// sync.Once 用于确保在不同的执行阶段（SIGTERM 或加载完配置）关闭 channel。</span></span><br><span class="line"><span class="keyword">type</span> closeOnce <span class="keyword">struct</span> &#123;</span><br><span class="line">C     <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">once  sync.Once</span><br><span class="line">Close <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function">// <span class="title">Wait</span> <span class="title">until</span> <span class="title">the</span> <span class="title">server</span> <span class="title">is</span> <span class="title">ready</span> <span class="title">to</span> <span class="title">handle</span> <span class="title">reloading</span>.</span></span><br><span class="line"><span class="function">// 等待直到 <span class="title">server</span> 准备好处理配置重加载。</span></span><br><span class="line"><span class="function"><span class="title">reloadReady</span> := &amp;<span class="title">closeOnce</span></span>&#123;</span><br><span class="line">C: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">&#125;</span><br><span class="line">reloadReady.Close = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">reloadReady.once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">close</span>(reloadReady.C)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动 jaeger 链路追踪</span></span><br><span class="line">closer, err := initTracing(logger)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">level.Error(logger).Log(<span class="string">"msg"</span>, <span class="string">"Unable to init tracing"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">os.Exit(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> closer.Close()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动 web 服务</span></span><br><span class="line">listener, err := webHandler.Listener()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">level.Error(logger).Log(<span class="string">"msg"</span>, <span class="string">"Unable to start web listener"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证额外的 web 配置，比如 tsl</span></span><br><span class="line">err = toolkit_web.Validate(*webConfig)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">level.Error(logger).Log(<span class="string">"msg"</span>, <span class="string">"Unable to validate web configuration file"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// oklog.run.Group 和 google errgroup 功能相近，维护一组并发任务的执行。</span></span><br><span class="line"><span class="keyword">var</span> g run.Group</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Termination handler.</span></span><br><span class="line">term := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">signal.Notify(term, os.Interrupt, syscall.SIGTERM)</span><br><span class="line">cancel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="comment">// 接收信号退出</span></span><br><span class="line">g.Add(</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// Don't forget to release the reloadReady channel so that waiting blocks can exit normally.</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-term:</span><br><span class="line">level.Warn(logger).Log(<span class="string">"msg"</span>, <span class="string">"Received SIGTERM, exiting gracefully..."</span>)</span><br><span class="line">reloadReady.Close()</span><br><span class="line"><span class="keyword">case</span> &lt;-webHandler.Quit():</span><br><span class="line">level.Warn(logger).Log(<span class="string">"msg"</span>, <span class="string">"Received termination request via web service, exiting gracefully..."</span>)</span><br><span class="line"><span class="keyword">case</span> &lt;-cancel:</span><br><span class="line">reloadReady.Close()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line"><span class="built_in">close</span>(cancel)</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Scrape discovery manager.</span></span><br><span class="line">g.Add(</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">err := discoveryManagerScrape.Run()</span><br><span class="line">level.Info(logger).Log(<span class="string">"msg"</span>, <span class="string">"Scrape discovery manager stopped"</span>)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line">level.Info(logger).Log(<span class="string">"msg"</span>, <span class="string">"Stopping scrape discovery manager..."</span>)</span><br><span class="line">cancelScrape()</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Notify discovery manager.</span></span><br><span class="line">g.Add(</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">err := discoveryManagerNotify.Run()</span><br><span class="line">level.Info(logger).Log(<span class="string">"msg"</span>, <span class="string">"Notify discovery manager stopped"</span>)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line">level.Info(logger).Log(<span class="string">"msg"</span>, <span class="string">"Stopping notify discovery manager..."</span>)</span><br><span class="line">cancelNotify()</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Scrape manager.</span></span><br><span class="line">g.Add(</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// When the scrape manager receives a new targets list</span></span><br><span class="line"><span class="comment">// it needs to read a valid config for each job.</span></span><br><span class="line"><span class="comment">// It depends on the config being in sync with the discovery manager so</span></span><br><span class="line"><span class="comment">// we wait until the config is fully loaded.</span></span><br><span class="line"><span class="comment">// scrape manager 获取到新的抓取目标列表时，它需要读取每个 job 的合法的配置。</span></span><br><span class="line"><span class="comment">// 这依赖于正在被 discovery manager 同步的配置文件，所以要等到配置加载完成。</span></span><br><span class="line">&lt;-reloadReady.C</span><br><span class="line"></span><br><span class="line">err := scrapeManager.Run(discoveryManagerScrape.SyncCh())</span><br><span class="line">level.Info(logger).Log(<span class="string">"msg"</span>, <span class="string">"Scrape manager stopped"</span>)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line"><span class="comment">// Scrape manager needs to be stopped before closing the local TSDB</span></span><br><span class="line"><span class="comment">// so that it doesn't try to write samples to a closed storage.</span></span><br><span class="line">level.Info(logger).Log(<span class="string">"msg"</span>, <span class="string">"Stopping scrape manager..."</span>)</span><br><span class="line">scrapeManager.Stop()</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Reload handler.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Make sure that sighup handler is registered with a redirect to the channel before the potentially</span></span><br><span class="line"><span class="comment">// long and synchronous tsdb init.</span></span><br><span class="line"><span class="comment">// tsdb 初始化时间可能很长，确保 sighup 处理函数在这之前注册完成。</span></span><br><span class="line">hup := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">signal.Notify(hup, syscall.SIGHUP)</span><br><span class="line">cancel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">g.Add(</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">&lt;-reloadReady.C</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-hup:</span><br><span class="line"><span class="keyword">if</span> err := reloadConfig(cfg.configFile, cfg.enableExpandExternalLabels, logger, noStepSubqueryInterval, reloaders...); err != <span class="literal">nil</span> &#123;</span><br><span class="line">level.Error(logger).Log(<span class="string">"msg"</span>, <span class="string">"Error reloading config"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> rc := &lt;-webHandler.Reload():</span><br><span class="line"><span class="keyword">if</span> err := reloadConfig(cfg.configFile, cfg.enableExpandExternalLabels, logger, noStepSubqueryInterval, reloaders...); err != <span class="literal">nil</span> &#123;</span><br><span class="line">level.Error(logger).Log(<span class="string">"msg"</span>, <span class="string">"Error reloading config"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">rc &lt;- err</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">rc &lt;- <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> &lt;-cancel:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line"><span class="comment">// Wait for any in-progress reloads to complete to avoid</span></span><br><span class="line"><span class="comment">// reloading things after they have been shutdown.</span></span><br><span class="line">cancel &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Initial configuration loading.</span></span><br><span class="line">cancel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">g.Add(</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-dbOpen:</span><br><span class="line"><span class="comment">// In case a shutdown is initiated before the dbOpen is released</span></span><br><span class="line"><span class="keyword">case</span> &lt;-cancel:</span><br><span class="line">reloadReady.Close()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := reloadConfig(cfg.configFile, cfg.enableExpandExternalLabels, logger, noStepSubqueryInterval, reloaders...); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.Wrapf(err, <span class="string">"error loading config from %q"</span>, cfg.configFile)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reloadReady.Close()</span><br><span class="line"></span><br><span class="line">webHandler.Ready()</span><br><span class="line">level.Info(logger).Log(<span class="string">"msg"</span>, <span class="string">"Server is ready to receive web requests."</span>)</span><br><span class="line">&lt;-cancel</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line"><span class="built_in">close</span>(cancel)</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Rule manager.</span></span><br><span class="line">g.Add(</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">&lt;-reloadReady.C</span><br><span class="line">ruleManager.Run()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line">ruleManager.Stop()</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// TSDB.</span></span><br><span class="line">opts := cfg.tsdb.ToTSDBOptions()</span><br><span class="line">cancel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">g.Add(</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">level.Info(logger).Log(<span class="string">"msg"</span>, <span class="string">"Starting TSDB ..."</span>)</span><br><span class="line"><span class="keyword">if</span> cfg.tsdb.WALSegmentSize != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> cfg.tsdb.WALSegmentSize &lt; <span class="number">10</span>*<span class="number">1024</span>*<span class="number">1024</span> || cfg.tsdb.WALSegmentSize &gt; <span class="number">256</span>*<span class="number">1024</span>*<span class="number">1024</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">"flag 'storage.tsdb.wal-segment-size' must be set between 10MB and 256MB"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> cfg.tsdb.MaxBlockChunkSegmentSize != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> cfg.tsdb.MaxBlockChunkSegmentSize &lt; <span class="number">1024</span>*<span class="number">1024</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">"flag 'storage.tsdb.max-block-chunk-segment-size' must be set over 1MB"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">db, err := openDBWithMetrics(</span><br><span class="line">cfg.localStoragePath,</span><br><span class="line">logger,</span><br><span class="line">prometheus.DefaultRegisterer,</span><br><span class="line">&amp;opts,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.Wrapf(err, <span class="string">"opening storage failed"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> fsType := prom_runtime.Statfs(cfg.localStoragePath); fsType &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"NFS_SUPER_MAGIC"</span>:</span><br><span class="line">level.Warn(logger).Log(<span class="string">"fs_type"</span>, fsType, <span class="string">"msg"</span>, <span class="string">"This filesystem is not supported and may lead to data corruption and data loss. Please carefully read https://prometheus.io/docs/prometheus/latest/storage/ to learn more about supported filesystems."</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">level.Info(logger).Log(<span class="string">"fs_type"</span>, fsType)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">level.Info(logger).Log(<span class="string">"msg"</span>, <span class="string">"TSDB started"</span>)</span><br><span class="line">level.Debug(logger).Log(<span class="string">"msg"</span>, <span class="string">"TSDB options"</span>,</span><br><span class="line"><span class="string">"MinBlockDuration"</span>, cfg.tsdb.MinBlockDuration,</span><br><span class="line"><span class="string">"MaxBlockDuration"</span>, cfg.tsdb.MaxBlockDuration,</span><br><span class="line"><span class="string">"MaxBytes"</span>, cfg.tsdb.MaxBytes,</span><br><span class="line"><span class="string">"NoLockfile"</span>, cfg.tsdb.NoLockfile,</span><br><span class="line"><span class="string">"RetentionDuration"</span>, cfg.tsdb.RetentionDuration,</span><br><span class="line"><span class="string">"WALSegmentSize"</span>, cfg.tsdb.WALSegmentSize,</span><br><span class="line"><span class="string">"AllowOverlappingBlocks"</span>, cfg.tsdb.AllowOverlappingBlocks,</span><br><span class="line"><span class="string">"WALCompression"</span>, cfg.tsdb.WALCompression,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">startTimeMargin := <span class="keyword">int64</span>(<span class="number">2</span> * time.Duration(cfg.tsdb.MinBlockDuration).Seconds() * <span class="number">1000</span>)</span><br><span class="line">localStorage.Set(db, startTimeMargin)</span><br><span class="line"><span class="built_in">close</span>(dbOpen)</span><br><span class="line">&lt;-cancel</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := fanoutStorage.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">level.Error(logger).Log(<span class="string">"msg"</span>, <span class="string">"Error stopping storage"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(cancel)</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Web handler.</span></span><br><span class="line">g.Add(</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := webHandler.Run(ctxWeb, listener, *webConfig); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.Wrapf(err, <span class="string">"error starting web server"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line">cancelWeb()</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Notifier.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Calling notifier.Stop() before ruleManager.Stop() will cause a panic if the ruleManager isn't running,</span></span><br><span class="line"><span class="comment">// so keep this interrupt after the ruleManager.Stop().</span></span><br><span class="line"><span class="comment">// 如果 ruleManager不在运行，在调用 ruleManager.Stop() 之前调用 notifier.Stop() 会引发 pannic，</span></span><br><span class="line"><span class="comment">// 所以确保在 ruleManager.Stop() 中断 notifier。</span></span><br><span class="line">g.Add(</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// When the notifier manager receives a new targets list</span></span><br><span class="line"><span class="comment">// it needs to read a valid config for each job.</span></span><br><span class="line"><span class="comment">// It depends on the config being in sync with the discovery manager</span></span><br><span class="line"><span class="comment">// so we wait until the config is fully loaded.</span></span><br><span class="line">&lt;-reloadReady.C</span><br><span class="line"></span><br><span class="line">notifierManager.Run(discoveryManagerNotify.SyncCh())</span><br><span class="line">level.Info(logger).Log(<span class="string">"msg"</span>, <span class="string">"Notifier manager stopped"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line">notifierManager.Stop()</span><br><span class="line">&#125;,</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := g.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">level.Error(logger).Log(<span class="string">"err"</span>, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">level.Info(logger).Log(<span class="string">"msg"</span>, <span class="string">"See you next time!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">openDBWithMetrics</span><span class="params">(dir <span class="keyword">string</span>, logger log.Logger, reg prometheus.Registerer, opts *tsdb.Options)</span> <span class="params">(*tsdb.DB, error)</span></span> &#123;</span><br><span class="line">db, err := tsdb.Open(</span><br><span class="line">dir,</span><br><span class="line">log.With(logger, <span class="string">"component"</span>, <span class="string">"tsdb"</span>),</span><br><span class="line">reg,</span><br><span class="line">opts,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reg.MustRegister(</span><br><span class="line">prometheus.NewGaugeFunc(prometheus.GaugeOpts&#123;</span><br><span class="line">Name: <span class="string">"prometheus_tsdb_lowest_timestamp_seconds"</span>,</span><br><span class="line">Help: <span class="string">"Lowest timestamp value stored in the database."</span>,</span><br><span class="line">&#125;, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">bb := db.Blocks()</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(bb) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">float64</span>(db.Head().MinTime() / <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">float64</span>(db.Blocks()[<span class="number">0</span>].Meta().MinTime / <span class="number">1000</span>)</span><br><span class="line">&#125;), prometheus.NewGaugeFunc(prometheus.GaugeOpts&#123;</span><br><span class="line">Name: <span class="string">"prometheus_tsdb_head_min_time_seconds"</span>,</span><br><span class="line">Help: <span class="string">"Minimum time bound of the head block."</span>,</span><br><span class="line">&#125;, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">float64</span></span> &#123; <span class="keyword">return</span> <span class="keyword">float64</span>(db.Head().MinTime() / <span class="number">1000</span>) &#125;),</span><br><span class="line">prometheus.NewGaugeFunc(prometheus.GaugeOpts&#123;</span><br><span class="line">Name: <span class="string">"prometheus_tsdb_head_max_time_seconds"</span>,</span><br><span class="line">Help: <span class="string">"Maximum timestamp of the head block."</span>,</span><br><span class="line">&#125;, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">float64</span></span> &#123; <span class="keyword">return</span> <span class="keyword">float64</span>(db.Head().MaxTime() / <span class="number">1000</span>) &#125;),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> db, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> safePromQLNoStepSubqueryInterval <span class="keyword">struct</span> &#123;</span><br><span class="line">value atomic.Int64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">durationToInt64Millis</span><span class="params">(d time.Duration)</span> <span class="title">int64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">int64</span>(d / time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *safePromQLNoStepSubqueryInterval)</span> <span class="title">Set</span><span class="params">(ev model.Duration)</span></span> &#123;</span><br><span class="line">i.value.Store(durationToInt64Millis(time.Duration(ev)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *safePromQLNoStepSubqueryInterval)</span> <span class="title">Get</span><span class="params">(<span class="keyword">int64</span>)</span> <span class="title">int64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> i.value.Load()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> reloader <span class="keyword">struct</span> &#123;</span><br><span class="line">name     <span class="keyword">string</span></span><br><span class="line">reloader <span class="function"><span class="keyword">func</span><span class="params">(*config.Config)</span> <span class="title">error</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">reloadConfig</span><span class="params">(filename <span class="keyword">string</span>, expandExternalLabels <span class="keyword">bool</span>, logger log.Logger, noStepSuqueryInterval *safePromQLNoStepSubqueryInterval, rls ...reloader)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">start := time.Now()</span><br><span class="line">timings := []<span class="keyword">interface</span>&#123;&#125;&#123;&#125;</span><br><span class="line">level.Info(logger).Log(<span class="string">"msg"</span>, <span class="string">"Loading configuration file"</span>, <span class="string">"filename"</span>, filename)</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">configSuccess.Set(<span class="number">1</span>)</span><br><span class="line">configSuccessTime.SetToCurrentTime()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">configSuccess.Set(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">conf, err := config.LoadFile(filename, expandExternalLabels, logger)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.Wrapf(err, <span class="string">"couldn't load configuration (--config.file=%q)"</span>, filename)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">failed := <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> _, rl := <span class="keyword">range</span> rls &#123;</span><br><span class="line">rstart := time.Now()</span><br><span class="line"><span class="keyword">if</span> err := rl.reloader(conf); err != <span class="literal">nil</span> &#123;</span><br><span class="line">level.Error(logger).Log(<span class="string">"msg"</span>, <span class="string">"Failed to apply configuration"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">failed = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">timings = <span class="built_in">append</span>(timings, rl.name, time.Since(rstart))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> failed &#123;</span><br><span class="line"><span class="keyword">return</span> errors.Errorf(<span class="string">"one or more errors occurred while applying the new configuration (--config.file=%q)"</span>, filename)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">noStepSuqueryInterval.Set(conf.GlobalConfig.EvaluationInterval)</span><br><span class="line">l := []<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">"msg"</span>, <span class="string">"Completed loading of configuration file"</span>, <span class="string">"filename"</span>, filename, <span class="string">"totalDuration"</span>, time.Since(start)&#125;</span><br><span class="line">level.Info(logger).Log(<span class="built_in">append</span>(l, timings...)...)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startsOrEndsWithQuote</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> strings.HasPrefix(s, <span class="string">"\""</span>) || strings.HasPrefix(s, <span class="string">"'"</span>) ||</span><br><span class="line">strings.HasSuffix(s, <span class="string">"\""</span>) || strings.HasSuffix(s, <span class="string">"'"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compileCORSRegexString compiles given string and adds anchors</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compileCORSRegexString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(*regexp.Regexp, error)</span></span> &#123;</span><br><span class="line">r, err := relabel.NewRegexp(s)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r.Regexp, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// computeExternalURL computes a sanitized external URL from a raw input. It infers unset</span></span><br><span class="line"><span class="comment">// URL parts from the OS and the given listen address.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">computeExternalURL</span><span class="params">(u, listenAddr <span class="keyword">string</span>)</span> <span class="params">(*url.URL, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> u == <span class="string">""</span> &#123;</span><br><span class="line">hostname, err := os.Hostname()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">_, port, err := net.SplitHostPort(listenAddr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">u = fmt.Sprintf(<span class="string">"http://%s:%s/"</span>, hostname, port)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> startsOrEndsWithQuote(u) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"URL must not begin or end with quotes"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eu, err := url.Parse(u)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ppref := strings.TrimRight(eu.Path, <span class="string">"/"</span>)</span><br><span class="line"><span class="keyword">if</span> ppref != <span class="string">""</span> &amp;&amp; !strings.HasPrefix(ppref, <span class="string">"/"</span>) &#123;</span><br><span class="line">ppref = <span class="string">"/"</span> + ppref</span><br><span class="line">&#125;</span><br><span class="line">eu.Path = ppref</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> eu, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> sender <span class="keyword">interface</span> &#123;</span><br><span class="line">Send(alerts ...*notifier.Alert)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sendAlerts implements the rules.NotifyFunc for a Notifier.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendAlerts</span><span class="params">(s sender, externalURL <span class="keyword">string</span>)</span> <span class="title">rules</span>.<span class="title">NotifyFunc</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, expr <span class="keyword">string</span>, alerts ...*rules.Alert)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> res []*notifier.Alert</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, alert := <span class="keyword">range</span> alerts &#123;</span><br><span class="line">a := &amp;notifier.Alert&#123;</span><br><span class="line">StartsAt:     alert.FiredAt,</span><br><span class="line">Labels:       alert.Labels,</span><br><span class="line">Annotations:  alert.Annotations,</span><br><span class="line">GeneratorURL: externalURL + strutil.TableLinkForExpression(expr),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !alert.ResolvedAt.IsZero() &#123;</span><br><span class="line">a.EndsAt = alert.ResolvedAt</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">a.EndsAt = alert.ValidUntil</span><br><span class="line">&#125;</span><br><span class="line">res = <span class="built_in">append</span>(res, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(alerts) &gt; <span class="number">0</span> &#123;</span><br><span class="line">s.Send(res...)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// readyStorage implements the Storage interface while allowing to set the actual</span></span><br><span class="line"><span class="comment">// storage at a later point in time.</span></span><br><span class="line"><span class="keyword">type</span> readyStorage <span class="keyword">struct</span> &#123;</span><br><span class="line">mtx             sync.RWMutex</span><br><span class="line">db              *tsdb.DB</span><br><span class="line">startTimeMargin <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the storage.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *readyStorage)</span> <span class="title">Set</span><span class="params">(db *tsdb.DB, startTimeMargin <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">s.mtx.Lock()</span><br><span class="line"><span class="keyword">defer</span> s.mtx.Unlock()</span><br><span class="line"></span><br><span class="line">s.db = db</span><br><span class="line">s.startTimeMargin = startTimeMargin</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get is internal, you should use readyStorage as the front implementation layer.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *readyStorage)</span> <span class="title">get</span><span class="params">()</span> *<span class="title">tsdb</span>.<span class="title">DB</span></span> &#123;</span><br><span class="line">s.mtx.RLock()</span><br><span class="line">x := s.db</span><br><span class="line">s.mtx.RUnlock()</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StartTime implements the Storage interface.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *readyStorage)</span> <span class="title">StartTime</span><span class="params">()</span> <span class="params">(<span class="keyword">int64</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x := s.get(); x != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">var</span> startTime <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(x.Blocks()) &gt; <span class="number">0</span> &#123;</span><br><span class="line">startTime = x.Blocks()[<span class="number">0</span>].Meta().MinTime</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">startTime = time.Now().Unix() * <span class="number">1000</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Add a safety margin as it may take a few minutes for everything to spin up.</span></span><br><span class="line"><span class="keyword">return</span> startTime + s.startTimeMargin, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> math.MaxInt64, tsdb.ErrNotReady</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Querier implements the Storage interface.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *readyStorage)</span> <span class="title">Querier</span><span class="params">(ctx context.Context, mint, maxt <span class="keyword">int64</span>)</span> <span class="params">(storage.Querier, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x := s.get(); x != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x.Querier(ctx, mint, maxt)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, tsdb.ErrNotReady</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ChunkQuerier implements the Storage interface.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *readyStorage)</span> <span class="title">ChunkQuerier</span><span class="params">(ctx context.Context, mint, maxt <span class="keyword">int64</span>)</span> <span class="params">(storage.ChunkQuerier, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x := s.get(); x != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x.ChunkQuerier(ctx, mint, maxt)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, tsdb.ErrNotReady</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *readyStorage)</span> <span class="title">ExemplarQuerier</span><span class="params">(ctx context.Context)</span> <span class="params">(storage.ExemplarQuerier, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x := s.get(); x != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x.ExemplarQuerier(ctx)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, tsdb.ErrNotReady</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Appender implements the Storage interface.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *readyStorage)</span> <span class="title">Appender</span><span class="params">(ctx context.Context)</span> <span class="title">storage</span>.<span class="title">Appender</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x := s.get(); x != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x.Appender(ctx)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> notReadyAppender&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> notReadyAppender <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n notReadyAppender)</span> <span class="title">Append</span><span class="params">(ref <span class="keyword">uint64</span>, l labels.Labels, t <span class="keyword">int64</span>, v <span class="keyword">float64</span>)</span> <span class="params">(<span class="keyword">uint64</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, tsdb.ErrNotReady</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n notReadyAppender)</span> <span class="title">AppendExemplar</span><span class="params">(ref <span class="keyword">uint64</span>, l labels.Labels, e exemplar.Exemplar)</span> <span class="params">(<span class="keyword">uint64</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, tsdb.ErrNotReady</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n notReadyAppender)</span> <span class="title">Commit</span><span class="params">()</span> <span class="title">error</span></span> &#123; <span class="keyword">return</span> tsdb.ErrNotReady &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n notReadyAppender)</span> <span class="title">Rollback</span><span class="params">()</span> <span class="title">error</span></span> &#123; <span class="keyword">return</span> tsdb.ErrNotReady &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close implements the Storage interface.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *readyStorage)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x := s.get(); x != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x.Close()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CleanTombstones implements the api_v1.TSDBAdminStats and api_v2.TSDBAdmin interfaces.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *readyStorage)</span> <span class="title">CleanTombstones</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x := s.get(); x != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x.CleanTombstones()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tsdb.ErrNotReady</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete implements the api_v1.TSDBAdminStats and api_v2.TSDBAdmin interfaces.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *readyStorage)</span> <span class="title">Delete</span><span class="params">(mint, maxt <span class="keyword">int64</span>, ms ...*labels.Matcher)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x := s.get(); x != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x.Delete(mint, maxt, ms...)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tsdb.ErrNotReady</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Snapshot implements the api_v1.TSDBAdminStats and api_v2.TSDBAdmin interfaces.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *readyStorage)</span> <span class="title">Snapshot</span><span class="params">(dir <span class="keyword">string</span>, withHead <span class="keyword">bool</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x := s.get(); x != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x.Snapshot(dir, withHead)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tsdb.ErrNotReady</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stats implements the api_v1.TSDBAdminStats interface.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *readyStorage)</span> <span class="title">Stats</span><span class="params">(statsByLabelName <span class="keyword">string</span>)</span> <span class="params">(*tsdb.Stats, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> x := s.get(); x != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x.Head().Stats(statsByLabelName), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, tsdb.ErrNotReady</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ErrNotReady is returned if the underlying scrape manager is not ready yet.</span></span><br><span class="line"><span class="keyword">var</span> ErrNotReady = errors.New(<span class="string">"Scrape manager not ready"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReadyScrapeManager allows a scrape manager to be retrieved. Even if it's set at a later point in time.</span></span><br><span class="line"><span class="keyword">type</span> readyScrapeManager <span class="keyword">struct</span> &#123;</span><br><span class="line">mtx sync.RWMutex</span><br><span class="line">m   *scrape.Manager</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the scrape manager.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rm *readyScrapeManager)</span> <span class="title">Set</span><span class="params">(m *scrape.Manager)</span></span> &#123;</span><br><span class="line">rm.mtx.Lock()</span><br><span class="line"><span class="keyword">defer</span> rm.mtx.Unlock()</span><br><span class="line"></span><br><span class="line">rm.m = m</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the scrape manager. If is not ready, return an error.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rm *readyScrapeManager)</span> <span class="title">Get</span><span class="params">()</span> <span class="params">(*scrape.Manager, error)</span></span> &#123;</span><br><span class="line">rm.mtx.RLock()</span><br><span class="line"><span class="keyword">defer</span> rm.mtx.RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> rm.m != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> rm.m, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ErrNotReady</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tsdbOptions is tsdb.Option version with defined units.</span></span><br><span class="line"><span class="comment">// This is required as tsdb.Option fields are unit agnostic (time).</span></span><br><span class="line"><span class="keyword">type</span> tsdbOptions <span class="keyword">struct</span> &#123;</span><br><span class="line">WALSegmentSize           units.Base2Bytes</span><br><span class="line">MaxBlockChunkSegmentSize units.Base2Bytes</span><br><span class="line">RetentionDuration        model.Duration</span><br><span class="line">MaxBytes                 units.Base2Bytes</span><br><span class="line">NoLockfile               <span class="keyword">bool</span></span><br><span class="line">AllowOverlappingBlocks   <span class="keyword">bool</span></span><br><span class="line">WALCompression           <span class="keyword">bool</span></span><br><span class="line">StripeSize               <span class="keyword">int</span></span><br><span class="line">MinBlockDuration         model.Duration</span><br><span class="line">MaxBlockDuration         model.Duration</span><br><span class="line">MaxExemplars             <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(opts tsdbOptions)</span> <span class="title">ToTSDBOptions</span><span class="params">()</span> <span class="title">tsdb</span>.<span class="title">Options</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> tsdb.Options&#123;</span><br><span class="line">WALSegmentSize:           <span class="keyword">int</span>(opts.WALSegmentSize),</span><br><span class="line">MaxBlockChunkSegmentSize: <span class="keyword">int64</span>(opts.MaxBlockChunkSegmentSize),</span><br><span class="line">RetentionDuration:        <span class="keyword">int64</span>(time.Duration(opts.RetentionDuration) / time.Millisecond),</span><br><span class="line">MaxBytes:                 <span class="keyword">int64</span>(opts.MaxBytes),</span><br><span class="line">NoLockfile:               opts.NoLockfile,</span><br><span class="line">AllowOverlappingBlocks:   opts.AllowOverlappingBlocks,</span><br><span class="line">WALCompression:           opts.WALCompression,</span><br><span class="line">StripeSize:               opts.StripeSize,</span><br><span class="line">MinBlockDuration:         <span class="keyword">int64</span>(time.Duration(opts.MinBlockDuration) / time.Millisecond),</span><br><span class="line">MaxBlockDuration:         <span class="keyword">int64</span>(time.Duration(opts.MaxBlockDuration) / time.Millisecond),</span><br><span class="line">MaxExemplars:             opts.MaxExemplars,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initTracing</span><span class="params">(logger log.Logger)</span> <span class="params">(io.Closer, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// Set tracing configuration defaults.</span></span><br><span class="line">cfg := &amp;jcfg.Configuration&#123;</span><br><span class="line">ServiceName: <span class="string">"prometheus"</span>,</span><br><span class="line">Disabled:    <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Available options can be seen here:</span></span><br><span class="line"><span class="comment">// https://github.com/jaegertracing/jaeger-client-go#environment-variables</span></span><br><span class="line">cfg, err := cfg.FromEnv()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">"unable to get tracing config from environment"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jLogger := jaegerLogger&#123;logger: log.With(logger, <span class="string">"component"</span>, <span class="string">"tracing"</span>)&#125;</span><br><span class="line"></span><br><span class="line">tracer, closer, err := cfg.NewTracer(</span><br><span class="line">jcfg.Logger(jLogger),</span><br><span class="line">jcfg.Metrics(jprom.New()),</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">"unable to init tracing"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">opentracing.SetGlobalTracer(tracer)</span><br><span class="line"><span class="keyword">return</span> closer, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> jaegerLogger <span class="keyword">struct</span> &#123;</span><br><span class="line">logger log.Logger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l jaegerLogger)</span> <span class="title">Error</span><span class="params">(msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">level.Error(l.logger).Log(<span class="string">"msg"</span>, msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l jaegerLogger)</span> <span class="title">Infof</span><span class="params">(msg <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">keyvals := []<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">"msg"</span>, fmt.Sprintf(msg, args...)&#125;</span><br><span class="line">level.Info(l.logger).Log(keyvals...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="https://blog.csdn.net/dengxiafubi/article/details/102845639" target="_blank" rel="external">https://blog.csdn.net/dengxiafubi/article/details/102845639</a></p><p><a href="https://so.csdn.net/so/search?q=Prometheus%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0&amp;t=blog&amp;u=qq_35753140" target="_blank" rel="external">https://so.csdn.net/so/search?q=Prometheus%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0&amp;t=blog&amp;u=qq_35753140</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p id=&quot;div-border-top-green&quot;&gt;人的一生更是如此不要去看低每一个人，更不要以自己现有的权利去欺压别人。现在混得好不代表以后就混的好，时刻提醒自己你今天奋斗了吗？&lt;br&gt;&lt;/p&gt;

&lt;p&gt;以下包括链接中的分析皆是平时网上学习以及自己用到的一些知识，简单做个总结，基于版本2.27&lt;/p&gt;
&lt;h2 id=&quot;架构总览&quot;&gt;&lt;a href=&quot;#架构总览&quot; class=&quot;headerlink&quot; title=&quot;架构总览&quot;&gt;&lt;/a&gt;架构总览&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/prometheus-prometheus-6.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Prometheus" scheme="https://magiceses.github.io/categories/Prometheus/"/>
    
    
      <category term="Prometheus" scheme="https://magiceses.github.io/tags/Prometheus/"/>
    
  </entry>
  
  <entry>
    <title>Prometheus 安装(二进制和Docker)</title>
    <link href="https://magiceses.github.io/2020/10/02/prometheus-prometheus-1-%E5%AE%89%E8%A3%85/"/>
    <id>https://magiceses.github.io/2020/10/02/prometheus-prometheus-1-安装/</id>
    <published>2020-10-02T15:25:24.000Z</published>
    <updated>2021-10-02T04:44:09.808Z</updated>
    
    <content type="html"><![CDATA[<p id="div-border-top-green">走好自己的路就要有自己的思考，有坚定的意志，坚持自己的信念，坚持自己的追求，不能放松对自己的要求，更不能糊里糊涂地度过自己的人生。人生不能虚度，自己要对得起自己。<br></p><h1 id="二进制包安装"><a href="#二进制包安装" class="headerlink" title="二进制包安装"></a>二进制包安装</h1><p>我们可以到 Prometheus 二进制安装包<a href="https://prometheus.io/download/" target="_blank" rel="external">下载页面</a>，根据自己的操作系统选择下载对应的安装包。下面我们将以 Amazon Linux 2 作为演示。</p><p>下载版本 <code>v2.17.1</code>。</p><a id="more"></a><h2 id="下载-Prometheus-Server"><a href="#下载-Prometheus-Server" class="headerlink" title="下载 Prometheus Server"></a>下载 Prometheus Server</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/prometheus/prometheus/releases/download/v2.17.1/prometheus-2.17.1.linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">tar xf prometheus-2.17.1.linux-amd64.tar.gz</span><br><span class="line">mv prometheus-2.17.1.linux-amd64/prometheus /usr/<span class="built_in">local</span>/bin/</span><br></pre></td></tr></table></figure><h2 id="配置启动文件"><a href="#配置启动文件" class="headerlink" title="配置启动文件"></a>配置启动文件</h2><p>因为是生产环境，我们为其配置启动文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/systemd/system/prometheus.service</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Prometheus Server</span><br><span class="line">After=network.target</span><br><span class="line">Documentation=https://prometheus.io/docs/introduction/overview/</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">WorkingDirectory=/home/data/prometheus/</span><br><span class="line">ExecStart=/usr/local/bin/prometheus \</span><br><span class="line">  --config.file=/etc/prometheus/prometheus.yml \</span><br><span class="line">  --web.read-timeout=5m \</span><br><span class="line">  --web.max-connections=512 \</span><br><span class="line">  --storage.tsdb.retention=15d \</span><br><span class="line">  --storage.tsdb.path=/home/data/prometheus \</span><br><span class="line">  --query.timeout=2m</span><br><span class="line"></span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>Prometheus 通过在目标节点的 HTTP 端口上采集 metrics（遥测专用词，度量指标）来监控目标节点（以下会称为“采样目标”）。因为 Prometheus 也以相同的方式暴露自己的数据，所以他也可以采集和检查自己的健康状况。</p><p>我们把配置文件转移到标准目录<code>/etc/prometheus/</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /etc/prometheus</span><br><span class="line">mv prometheus-2.17.1.linux-amd64/prometheus.yml /etc/prometheus</span><br></pre></td></tr></table></figure><p>初始的配置文件比较简单，如下，自带了一个 job，来监控 prometheus server 的状态。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line"><span class="attr">  scrape_interval:</span>     <span class="number">15</span><span class="string">s</span> </span><br><span class="line"><span class="attr">  evaluation_interval:</span> <span class="number">15</span><span class="string">s</span></span><br><span class="line"></span><br><span class="line"><span class="attr">alerting:</span></span><br><span class="line"><span class="attr">  alertmanagers:</span></span><br><span class="line"><span class="attr">  - static_configs:</span></span><br><span class="line"><span class="attr">    - targets:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rule_files:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line"><span class="attr">  - job_name:</span> <span class="string">'prometheus'</span></span><br><span class="line"><span class="attr">    static_configs:</span></span><br><span class="line"><span class="attr">      - targets:</span> <span class="string">['localhost:9090']</span></span><br></pre></td></tr></table></figure><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start prometheus</span><br><span class="line">systemctl enable prometheus</span><br></pre></td></tr></table></figure><h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><p>启动好之后，prometheus 服务会监听在端口 9090，我们使用 IP + Port，即可查看 prometheus 简单的图像界面：</p><p><img src="/images/prometheus-prometheus-0.png" alt="image-20200410205833898"></p><ol><li>可以看出 Prometheus 二进制安装非常方便，没有依赖，自带查询 web 界面。</li><li>在生产环境中，我们可以将 Prometheus 添加到 init 配置里，或者使用 supervisord 作为服务自启动。</li></ol><h1 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h1><p>首先确保你已安装了最新版本的 Docker, 如果没有安装请点击<a href="https://docs.docker.com/engine/installation/" target="_blank" rel="external">这里</a>。</p><p>下面我将以 Mac 版本的 Docker 作为演示。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">    -p 9090:9090 \</span><br><span class="line">    -v /etc/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml \</span><br><span class="line">    prom/prometheus</span><br></pre></td></tr></table></figure><h2 id="Docker-管理-prometheus"><a href="#Docker-管理-prometheus" class="headerlink" title="Docker 管理 prometheus"></a>Docker 管理 prometheus</h2><p>运行 docker ps 查看所有服务:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID        IMAGE                           COMMAND                  CREATED             STATUS              PORTS                      NAMES</span><br><span class="line">e9ebc2435387        quay.io/prometheus/prometheus   &quot;/bin/prometheus -...&quot;   26 minutes ago      Up 26 minutes       0.0.0.0:9090-&gt;9090/tcp   prometheus</span><br></pre></td></tr></table></figure><p>运行 <code>docker start prometheus</code> 启动服务</p><p>运行 <code>docker stats prometheus</code> 查看 prometheus 状态</p><p>运行 <code>docker stop prometheus</code> 停止服务</p><h1 id="node-export-安装"><a href="#node-export-安装" class="headerlink" title="node_export 安装"></a>node_export 安装</h1><p><a href="https://github.com/prometheus/node_exporter" target="_blank" rel="external">node_exporter</a> 主要用于 *NIX 系统监控, 用 Golang 编写。</p><h2 id="二进制安装"><a href="#二进制安装" class="headerlink" title="二进制安装"></a>二进制安装</h2><p>下载地址：<a href="https://prometheus.io/download/" target="_blank" rel="external">https://prometheus.io/download/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/prometheus/node_exporter/releases/download/v0.18.1/node_exporter-0.18.1.linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">tar xf node_exporter-0.18.1.linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">mv node_exporter-0.18.1.linux-amd64/node_exporter /usr/local/bin/</span><br></pre></td></tr></table></figure><h2 id="配置启动文件-1"><a href="#配置启动文件-1" class="headerlink" title="配置启动文件"></a>配置启动文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/systemd/system/node_export.service</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Node Export</span><br><span class="line">After=network.target</span><br><span class="line">Documentation=https://prometheus.io/docs/guides/node-exporter/</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">WorkingDirectory=/tmp/</span><br><span class="line">ExecStart=/usr/local/bin/node_exporter </span><br><span class="line"></span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start node_export</span><br><span class="line">systemctl enable node_export</span><br></pre></td></tr></table></figure><h2 id="加入监控"><a href="#加入监控" class="headerlink" title="加入监控"></a>加入监控</h2><p>我们手动加入 prometheus 监控，修改其配置文件，再尾部增加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- job_name: &apos;node_export&apos;</span><br><span class="line">  static_configs:</span><br><span class="line">    - targets: </span><br><span class="line">      - localhost:9100</span><br><span class="line">      - web1:9100</span><br><span class="line">      - web2:9100</span><br><span class="line">      - web3:9100</span><br><span class="line">      - web4:9100</span><br></pre></td></tr></table></figure><blockquote><p>prometheus 服务器需要可以解析这些地址，我们可以修改其 /etc/hosts 文件。</p></blockquote><h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --net=&quot;host&quot; \</span><br><span class="line">  --pid=&quot;host&quot; \</span><br><span class="line">  -v &quot;/:/host:ro,rslave&quot; \</span><br><span class="line">  quay.io/prometheus/node-exporter \</span><br><span class="line">  --path.rootfs=/host</span><br></pre></td></tr></table></figure><h1 id="grafana-rpm-安装"><a href="#grafana-rpm-安装" class="headerlink" title="grafana rpm 安装"></a>grafana rpm 安装</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>下载地址：<a href="https://grafana.com/grafana/download" target="_blank" rel="external">https://grafana.com/grafana/download</a></p><p>我推荐使用 rpm 包进行安装，这样很多依赖可以自动解决，而且也配置好了启动脚本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://dl.grafana.com/oss/release/grafana-6.7.2-1.x86_64.rpm</span><br><span class="line">sudo yum install grafana-6.7.2-1.x86_64.rpm</span><br></pre></td></tr></table></figure><h2 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> grafana-server</span><br><span class="line">systemctl start grafana-server</span><br></pre></td></tr></table></figure><h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><p>访问 IP + Port，grafana 默认的启动 port 是 3000，初始账号和密码都是 admin，下面是登陆之后的界面，我这里截图是已经配置好数据源的。</p><p><img src="/images/prometheus-prometheus-1.png" alt="image-20200410235820764"></p><h2 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h2><p>grafana 支持的数据源非常多，我们这里选择 prometheus。</p><p><img src="/images/prometheus-prometheus-2.png" alt="image-20200410235935430"></p><p>因为我们的 grafana 和 prometheus 在同一台机器上面，地址填写 localhost:9090 即可。</p><p><img src="/images/prometheus-prometheus-3.png" alt="image-20200411000041835"></p><h2 id="导入模板"><a href="#导入模板" class="headerlink" title="导入模板"></a>导入模板</h2><p>开始我们可能不会制作模板，我们先导入一个模板，只需要输入其编号即可。更多的官方 Dashboard 请参见：</p><p><a href="https://grafana.com/grafana/dashboards?orderBy=name&amp;direction=asc" target="_blank" rel="external">https://grafana.com/grafana/dashboards?orderBy=name&amp;direction=asc</a></p><p><img src="/images/prometheus-prometheus-4.png" alt="image-20200411000223078"></p><h2 id="查看效果"><a href="#查看效果" class="headerlink" title="查看效果"></a>查看效果</h2><p><img src="/images/prometheus-prometheus-5.png" alt="image-20200411000413028"></p><p>原文：<a href="https://blog.51cto.com/wzlinux/2489659" target="_blank" rel="external">https://blog.51cto.com/wzlinux/2489659</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p id=&quot;div-border-top-green&quot;&gt;走好自己的路就要有自己的思考，有坚定的意志，坚持自己的信念，坚持自己的追求，不能放松对自己的要求，更不能糊里糊涂地度过自己的人生。人生不能虚度，自己要对得起自己。&lt;br&gt;&lt;/p&gt;

&lt;h1 id=&quot;二进制包安装&quot;&gt;&lt;a href=&quot;#二进制包安装&quot; class=&quot;headerlink&quot; title=&quot;二进制包安装&quot;&gt;&lt;/a&gt;二进制包安装&lt;/h1&gt;&lt;p&gt;我们可以到 Prometheus 二进制安装包&lt;a href=&quot;https://prometheus.io/download/&quot;&gt;下载页面&lt;/a&gt;，根据自己的操作系统选择下载对应的安装包。下面我们将以 Amazon Linux 2 作为演示。&lt;/p&gt;
&lt;p&gt;下载版本 &lt;code&gt;v2.17.1&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Prometheus" scheme="https://magiceses.github.io/categories/Prometheus/"/>
    
    
      <category term="Prometheus" scheme="https://magiceses.github.io/tags/Prometheus/"/>
    
  </entry>
  
  <entry>
    <title>Prometheus 简单使用</title>
    <link href="https://magiceses.github.io/2020/10/01/prometheus-prometheus-0-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>https://magiceses.github.io/2020/10/01/prometheus-prometheus-0-简单使用/</id>
    <published>2020-10-01T05:25:24.000Z</published>
    <updated>2021-10-02T08:03:57.177Z</updated>
    
    <content type="html"><![CDATA[<p id="div-border-top-green">与其每天担心未来，不如努力现在。别对自己丧失信心，成长的路上，只有奋斗才能给你最大的安全感。<br></p><h1 id="Prometheus-简介"><a href="#Prometheus-简介" class="headerlink" title="Prometheus 简介"></a>Prometheus 简介</h1><h2 id="Prometheus-是啥"><a href="#Prometheus-是啥" class="headerlink" title="Prometheus 是啥"></a>Prometheus 是啥</h2><p>Prometheus 是一套开源的系统监控报警框架。它启发于 Google 的 borgmon 监控系统，由工作在 SoundCloud 的 google 前员工在 2012 年创建，作为社区开源项目进行开发，并于 2015 年正式发布。2016 年，Prometheus 正式加入 Cloud Native Computing Foundation，成为受欢迎度仅次于 Kubernetes 的项目。</p><a id="more"></a><h2 id="Prometheus-优点"><a href="#Prometheus-优点" class="headerlink" title="Prometheus 优点"></a>Prometheus 优点</h2><ul><li>强大的多维度数据模型：<ol><li>时间序列数据通过 metric 名和键值对来区分。</li><li>所有的 metrics 都可以设置任意的多维标签。</li><li>数据模型更随意，不需要刻意设置为以点分隔的字符串。</li><li>可以对数据模型进行聚合，切割和切片操作。</li><li>支持双精度浮点类型，标签可以设为全 unicode。</li></ol></li><li>灵活而强大的查询语句（PromQL）：在同一个查询语句，可以对多个 metrics 进行乘法、加法、连接、取分数位等操作。</li><li>易于管理： Prometheus server 是一个单独的二进制文件，可直接在本地工作，不依赖于分布式存储。</li><li>高效：平均每个采样点仅占 3.5 bytes，且一个 Prometheus server 可以处理数百万的 metrics。</li><li>使用 pull 模式采集时间序列数据，这样不仅有利于本机测试而且可以避免有问题的服务器推送坏的 metrics。</li><li>可以采用 push gateway 的方式把时间序列数据推送至 Prometheus server 端。</li><li>可以通过服务发现或者静态配置去获取监控的 targets。</li><li>有多种可视化图形界面。</li><li>易于伸缩。</li></ul><h2 id="Prometheus-组件"><a href="#Prometheus-组件" class="headerlink" title="Prometheus 组件"></a>Prometheus 组件</h2><p>Prometheus 生态圈中包含了多个组件，其中许多组件是可选的：</p><ul><li><strong>Prometheus Server</strong>: 用于收集和存储时间序列数据。</li><li><strong>Client Library</strong>: 客户端库，为需要监控的服务生成相应的 metrics 并暴露给 Prometheus server。当 Prometheus server 来 pull 时，直接返回实时状态的 metrics。</li><li><strong>Push Gateway</strong>: 主要用于短期的 jobs。由于这类 jobs 存在时间较短，可能在 Prometheus 来 pull 之前就消失了。为此，这次 jobs 可以直接向 Prometheus server 端推送它们的 metrics。这种方式主要用于服务层面的 metrics，对于机器层面的 metrices，需要使用 node exporter。</li><li><strong>Exporters</strong>: 用于暴露已有的第三方服务的 metrics 给 Prometheus。</li><li><strong>Alertmanager</strong>: 从 Prometheus server 端接收到 alerts 后，会进行去除重复数据，分组，并路由到对收的接受方式，发出报警。常见的接收方式有：电子邮件，pagerduty，OpsGenie, webhook 等。</li><li>一些其他的工具。</li></ul><h2 id="Prometheus-架构"><a href="#Prometheus-架构" class="headerlink" title="Prometheus 架构"></a>Prometheus 架构</h2><p><img src="/Users/stark/Documents/mdPicture/151049-824797.png" alt="img"></p><p>从这个架构图，也可以看出 Prometheus 的主要模块包含， Server, Exporters, Pushgateway, PromQL, Alertmanager, WebUI 等。</p><p>它大致使用逻辑是这样：</p><ol><li>Prometheus server 定期从静态配置的 targets 或者服务发现的 targets 拉取数据。</li><li>当新拉取的数据大于配置内存缓存区的时候，Prometheus 会将数据持久化到磁盘（如果使用 remote storage 将持久化到云端）。</li><li>Prometheus 可以配置 rules，然后定时查询数据，当条件触发的时候，会将 alert 推送到配置的 Alertmanager。</li><li>Alertmanager 收到警告的时候，可以根据配置，聚合，去重，降噪，最后发送警告。</li><li>可以使用 API， Prometheus Console 或者 Grafana 查询和聚合数据。</li></ol><h2 id="Prometheus-适用于什么场景"><a href="#Prometheus-适用于什么场景" class="headerlink" title="Prometheus 适用于什么场景"></a>Prometheus 适用于什么场景</h2><p>Prometheus 适用于记录文本格式的时间序列，它既适用于以机器为中心的监控，也适用于高度动态的面向服务架构的监控。在微服务的世界中，它对多维数据收集和查询的支持有特殊优势。Prometheus 是专为提高系统可靠性而设计的，它可以在断电期间快速诊断问题，每个 Prometheus Server 都是相互独立的，不依赖于网络存储或其他远程服务。当基础架构出现故障时，你可以通过 Prometheus 快速定位故障点，而且不会消耗大量的基础架构资源。</p><h2 id="Prometheus-不适合什么场景"><a href="#Prometheus-不适合什么场景" class="headerlink" title="Prometheus 不适合什么场景"></a>Prometheus 不适合什么场景</h2><p>Prometheus 非常重视可靠性，即使在出现故障的情况下，你也可以随时查看有关系统的可用统计信息。如果你需要百分之百的准确度，例如按请求数量计费，那么 Prometheus 不太适合你，因为它收集的数据可能不够详细完整。这种情况下，你最好使用其他系统来收集和分析数据以进行计费，并使用 Prometheus 来监控系统的其余部分。</p><h1 id="Prometheus-数据模型"><a href="#Prometheus-数据模型" class="headerlink" title="Prometheus 数据模型"></a>Prometheus 数据模型</h1><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>Prometheus 所有采集的监控数据均以指标（metric）的形式保存在内置的<a href="https://www.wikiwand.com/zh/時間序列" target="_blank" rel="external">时间序列</a>数据库当中（TSDB）：属于同一指标名称，同一标签集合的、有时间戳标记的数据流。除了存储的时间序列，Prometheus 还可以根据查询请求产生临时的、衍生的时间序列作为返回结果。</p><h3 id="指标名称和标签"><a href="#指标名称和标签" class="headerlink" title="指标名称和标签"></a>指标名称和标签</h3><p>每一条时间序列由指标名称（Metrics Name）以及一组标签（键值对）唯一标识。其中指标的名称（metric name）可以反映被监控样本的含义（例如，<code>http_requests_total</code> — 表示当前系统接收到的 HTTP 请求总量），指标名称只能由 ASCII 字符、数字、下划线以及冒号组成，同时必须匹配正则表达式 <code>[a-zA-Z_:][a-zA-Z0-9_:]*</code>。</p><blockquote><p><strong>[info] 注意</strong></p><p>冒号用来表示用户自定义的记录规则，不能在 exporter 中或监控对象直接暴露的指标中使用冒号来定义指标名称。</p></blockquote><p>通过使用标签，Prometheus 开启了强大的多维数据模型：对于相同的指标名称，通过不同标签列表的集合，会形成特定的度量维度实例（例如：所有包含度量名称为 <code>/api/tracks</code> 的 http 请求，打上 <code>method=POST</code> 的标签，就会形成具体的 http 请求）。该查询语言在这些指标和标签列表的基础上进行过滤和聚合。改变任何度量指标上的任何标签值（包括添加或删除指标），都会创建新的时间序列。</p><p>标签的名称只能由 ASCII 字符、数字以及下划线组成并满足正则表达式 <code>[a-zA-Z_][a-zA-Z0-9_]*</code>。其中以 <code>__</code> 作为前缀的标签，是系统保留的关键字，只能在系统内部使用。标签的值则可以包含任何 <code>Unicode</code> 编码的字符。</p><h3 id="时序样本"><a href="#时序样本" class="headerlink" title="时序样本"></a>时序样本</h3><p>在时间序列中的每一个点称为一个样本（sample），样本由以下三部分组成：</p><ul><li>指标（metric）：指标名称和描述当前样本特征的 labelsets；</li><li>时间戳（timestamp）：一个精确到毫秒的时间戳；</li><li>样本值（value）： 一个 folat64 的浮点型数据表示当前样本的值。</li></ul><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>通过如下表达方式表示指定指标名称和指定标签集合的时间序列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;metric name&gt;&#123;&lt;label name&gt;=&lt;label value&gt;, ...&#125; value timestamps</span><br></pre></td></tr></table></figure><p>例如，指标名称为 <code>api_http_requests_total</code>，标签为 <code>method=&quot;POST&quot;</code> 和 <code>handler=&quot;/messages&quot;</code> 的时间序列可以表示为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api_http_requests_total&#123;method=&quot;POST&quot;, handler=&quot;/messages&quot;&#125;</span><br></pre></td></tr></table></figure><p>这与 <a href="http://opentsdb.net/" target="_blank" rel="external">OpenTSDB</a> 中使用的标记法相同。</p><h2 id="指标类型"><a href="#指标类型" class="headerlink" title="指标类型"></a>指标类型</h2><p>Prometheus 的客户端库中提供了四种核心的指标类型。但这些类型只是在客户端库（客户端可以根据不同的数据类型调用不同的 API 接口）和在线协议中，实际在 Prometheus server 中并不对指标类型进行区分，而是简单地把这些指标统一视为无类型的时间序列。不过，将来我们会努力改变这一现状的。</p><h3 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h3><ul><li>一种累加的 metric，典型的应用如：请求的个数，结束的任务数， 出现的错误数等等。</li></ul><p>例如 Prometheus server 中 <code>http_requests_total</code>, 表示 Prometheus 处理的 http 请求总数，我们可以使用 <code>delta</code>, 很容易得到任意区间数据的增量，这个会在 PromQL 一节中细讲。</p><p><img src="/Users/stark/Documents/mdPicture/152346-582157.png" alt="image-20200410152345078"></p><h3 id="Gauge"><a href="#Gauge" class="headerlink" title="Gauge"></a>Gauge</h3><ul><li>一种常规的 metric，典型的应用如：温度，运行的 goroutines 的个数。</li><li>可以任意加减。</li></ul><p>例如 Prometheus server 中 <code>go_goroutines</code>, 表示 Prometheus 当前 goroutines 的数量。</p><p><img src="/Users/stark/Documents/mdPicture/152303-862227.png" alt="image-20200410152301768"></p><h3 id="Histogram"><a href="#Histogram" class="headerlink" title="Histogram"></a>Histogram</h3><ul><li>可以理解为柱状图，典型的应用如：请求持续时间，响应大小。</li><li>可以对观察结果采样，分组及统计。</li></ul><p>例如，查询prometheus_http_request_duration_seconds_sum{handler=“/api/v1/query”,instance=“localhost:9090”,job=“prometheus”}时，返回结果如下：</p><p><img src="/Users/stark/Documents/mdPicture/152806-378296.png" alt="image-20200410152805983"></p><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a><strong>Summary</strong></h3><ul><li>类似于 Histogram, 典型的应用如：请求持续时间，响应大小。</li><li>提供观测值的 count 和 sum 功能。</li><li>提供百分位的功能，即可以按百分比划分跟踪结果。</li></ul><h2 id="instance-和-jobs"><a href="#instance-和-jobs" class="headerlink" title="instance 和 jobs"></a>instance 和 jobs</h2><p>Prometheus 中，将任意一个独立的数据源（target）称之为实例（instance）。包含相同类型的实例的集合称之为作业（job）。 如下是一个含有四个重复实例的作业：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- job: api-server</span><br><span class="line">    - instance 1: 1.2.3.4:5670</span><br><span class="line">    - instance 2: 1.2.3.4:5671</span><br><span class="line">    - instance 3: 5.6.7.8:5670</span><br><span class="line">    - instance 4: 5.6.7.8:5671</span><br></pre></td></tr></table></figure><p><strong>自生成标签和时序</strong></p><p>Prometheus 在采集数据的同时，会自动在时序的基础上添加标签，作为数据源（target）的标识，以便区分：</p><ul><li><code>job</code>: The configured job name that the target belongs to.</li><li><code>instance</code>: The <code>&lt;host&gt;:&lt;port&gt;</code> part of the target’s URL that was scraped.</li></ul><p>如果其中任一标签已经在此前采集的数据中存在，那么将会根据 <code>honor_labels</code> 设置选项来决定新标签。详见官网解释： <a href="https://prometheus.io/docs/operating/configuration/#" target="_blank" rel="external">scrape configuration documentation</a></p><p>对每一个实例而言，Prometheus 按照以下时序来存储所采集的数据样本：</p><ul><li><code>up{job=&quot;&lt;job-name&gt;&quot;, instance=&quot;&lt;instance-id&gt;&quot;}</code>: 1 表示该实例正常工作</li><li><code>up{job=&quot;&lt;job-name&gt;&quot;, instance=&quot;&lt;instance-id&gt;&quot;}</code>: 0 表示该实例故障</li><li><code>scrape_duration_seconds{job=&quot;&lt;job-name&gt;&quot;, instance=&quot;&lt;instance-id&gt;&quot;}</code> 表示拉取数据的时间间隔</li><li><code>scrape_samples_post_metric_relabeling{job=&quot;&lt;job-name&gt;&quot;, instance=&quot;&lt;instance-id&gt;&quot;}</code> 表示采用重定义标签（relabeling）操作后仍然剩余的样本数</li><li><code>scrape_samples_scraped{job=&quot;&lt;job-name&gt;&quot;, instance=&quot;&lt;instance-id&gt;&quot;}</code> 表示从该数据源获取的样本数</li></ul><p>其中 <code>up</code> 时序可以有效应用于监控该实例是否正常工作。</p><h1 id="Export"><a href="#Export" class="headerlink" title="Export"></a>Export</h1><h2 id="文本格式"><a href="#文本格式" class="headerlink" title="文本格式"></a>文本格式</h2><p>在讨论 Exporter 之前，有必要先介绍一下 Prometheus 文本数据格式，因为一个 Exporter 本质上就是将收集的数据，转化为对应的文本格式，并提供 http 请求。</p><p>Exporter 收集的数据转化的文本内容以行 (<code>\n</code>) 为单位，空行将被忽略, 文本内容最后一行为空行</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>文本内容，如果以 <code>#</code> 开头通常表示注释。</p><ul><li>以 <code># HELP</code> 开头表示 metric 帮助说明。</li><li>以 <code># TYPE</code> 开头表示定义 metric 类型，包含 <code>counter</code>, <code>gauge</code>, <code>histogram</code>, <code>summary</code>, 和 <code>untyped</code> 类型。</li><li>其他表示一般注释，供阅读使用，将被 Prometheus 忽略。</li></ul><h3 id="采样数据"><a href="#采样数据" class="headerlink" title="采样数据"></a>采样数据</h3><p>内容如果不以 <code>#</code> 开头，表示采样数据。它通常紧挨着类型定义行，满足以下格式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">metric_name [</span><br><span class="line">  "&#123;" label_name "=" `"` label_value `"` &#123; "," label_name "=" `"` label_value `"` &#125; [ "," ] "&#125;"</span><br><span class="line">] value [ timestamp ]</span><br><span class="line">1.2.3.</span><br></pre></td></tr></table></figure><p>下面是一个完整的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># HELP http_requests_total The total number of HTTP requests.</span><br><span class="line"># TYPE http_requests_total counter</span><br><span class="line">http_requests_total&#123;method=&quot;post&quot;,code=&quot;200&quot;&#125; 1027 1395066363000</span><br><span class="line">http_requests_total&#123;method=&quot;post&quot;,code=&quot;400&quot;&#125;    3 1395066363000</span><br><span class="line"></span><br><span class="line"># Escaping in label values:</span><br><span class="line">msdos_file_access_time_seconds&#123;path=&quot;C:\\DIR\\FILE.TXT&quot;,error=&quot;Cannot find file:\n\&quot;FILE.TXT\&quot;&quot;&#125; 1.458255915e9</span><br><span class="line"></span><br><span class="line"># Minimalistic line:</span><br><span class="line">metric_without_timestamp_and_labels 12.47</span><br><span class="line"></span><br><span class="line"># A weird metric from before the epoch:</span><br><span class="line">something_weird&#123;problem=&quot;division by zero&quot;&#125; +Inf -3982045</span><br><span class="line"></span><br><span class="line"># A histogram, which has a pretty complex representation in the text format:</span><br><span class="line"># HELP http_request_duration_seconds A histogram of the request duration.</span><br><span class="line"># TYPE http_request_duration_seconds histogram</span><br><span class="line">http_request_duration_seconds_bucket&#123;le=&quot;0.05&quot;&#125; 24054</span><br><span class="line">http_request_duration_seconds_bucket&#123;le=&quot;0.1&quot;&#125; 33444</span><br><span class="line">http_request_duration_seconds_bucket&#123;le=&quot;0.2&quot;&#125; 100392</span><br><span class="line">http_request_duration_seconds_bucket&#123;le=&quot;0.5&quot;&#125; 129389</span><br><span class="line">http_request_duration_seconds_bucket&#123;le=&quot;1&quot;&#125; 133988</span><br><span class="line">http_request_duration_seconds_bucket&#123;le=&quot;+Inf&quot;&#125; 144320</span><br><span class="line">http_request_duration_seconds_sum 53423</span><br><span class="line">http_request_duration_seconds_count 144320</span><br><span class="line"></span><br><span class="line"># Finally a summary, which has a complex representation, too:</span><br><span class="line"># HELP rpc_duration_seconds A summary of the RPC duration in seconds.</span><br><span class="line"># TYPE rpc_duration_seconds summary</span><br><span class="line">rpc_duration_seconds&#123;quantile=&quot;0.01&quot;&#125; 3102</span><br><span class="line">rpc_duration_seconds&#123;quantile=&quot;0.05&quot;&#125; 3272</span><br><span class="line">rpc_duration_seconds&#123;quantile=&quot;0.5&quot;&#125; 4773</span><br><span class="line">rpc_duration_seconds&#123;quantile=&quot;0.9&quot;&#125; 9001</span><br><span class="line">rpc_duration_seconds&#123;quantile=&quot;0.99&quot;&#125; 76656</span><br><span class="line">rpc_duration_seconds_sum 1.7560473e+07</span><br><span class="line">rpc_duration_seconds_count 2693</span><br></pre></td></tr></table></figure><p>需要特别注意的是，假设采样数据 metric 叫做 <code>x</code>, 如果 <code>x</code> 是 <code>histogram</code> 或 <code>summary</code> 类型必需满足以下条件：</p><ul><li>采样数据的总和应表示为 <code>x_sum</code>。</li><li>采样数据的总量应表示为 <code>x_count</code>。</li><li><code>summary</code> 类型的采样数据的 quantile 应表示为 <code>x{quantile=&quot;y&quot;}</code>。</li><li><code>histogram</code> 类型的采样分区统计数据将表示为 <code>x_bucket{le=&quot;y&quot;}</code>。</li><li><code>histogram</code> 类型的采样必须包含 <code>x_bucket{le=&quot;+Inf&quot;}</code>, 它的值等于 <code>x_count</code> 的值。</li><li><code>summary</code> 和 <code>historam</code> 中 <code>quantile</code> 和 <code>le</code> 必需按从小到大顺序排列。</li></ul><h2 id="常用查询"><a href="#常用查询" class="headerlink" title="常用查询"></a>常用查询</h2><p>收集到 node_exporter 的数据后，我们可以使用 PromQL 进行一些业务查询和监控，下面是一些比较常见的查询。</p><p>注意：以下查询均以单个节点作为例子，如果大家想查看所有节点，将 <code>instance=&quot;xxx&quot;</code> 去掉即可。</p><h3 id="CPU-使用率"><a href="#CPU-使用率" class="headerlink" title="CPU 使用率"></a>CPU 使用率</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100 - (avg by (instance) (irate(node_cpu_seconds_total&#123;mode=<span class="string">"idle"</span>&#125;[5m])) * 100)</span><br><span class="line">1.</span><br></pre></td></tr></table></figure><h3 id="CPU-各-mode-占比率"><a href="#CPU-各-mode-占比率" class="headerlink" title="CPU 各 mode 占比率"></a>CPU 各 mode 占比率</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">avg by (instance, mode) (irate(node_cpu_seconds_total[5m])) * 100</span><br><span class="line">1.</span><br></pre></td></tr></table></figure><h3 id="机器平均负载"><a href="#机器平均负载" class="headerlink" title="机器平均负载"></a>机器平均负载</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node_load1&#123;instance="xxx"&#125; // 1分钟负载</span><br><span class="line">node_load5&#123;instance="xxx"&#125; // 5分钟负载</span><br><span class="line">node_load15&#123;instance="xxx"&#125; // 15分钟负载</span><br><span class="line">1.2.3.</span><br></pre></td></tr></table></figure><h3 id="内存使用率"><a href="#内存使用率" class="headerlink" title="内存使用率"></a>内存使用率</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100 - ((node_memory_MemFree_bytes+node_memory_Cached_bytes+node_memory_Buffers_bytes)/node_memory_MemTotal_bytes) * 100</span><br><span class="line">1.</span><br></pre></td></tr></table></figure><h3 id="磁盘使用率"><a href="#磁盘使用率" class="headerlink" title="磁盘使用率"></a>磁盘使用率</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100 - node_filesystem_free&#123;instance="xxx",fstype!~"rootfs|selinuxfs|autofs|rpc_pipefs|tmpfs|udev|none|devpts|sysfs|debugfs|fuse.*"&#125; / node_filesystem_size&#123;instance="xxx",fstype!~"rootfs|selinuxfs|autofs|rpc_pipefs|tmpfs|udev|none|devpts|sysfs|debugfs|fuse.*"&#125; * 100</span><br><span class="line">1.</span><br></pre></td></tr></table></figure><p>或者你也可以直接使用 {fstype=“xxx”} 来指定想查看的磁盘信息</p><h3 id="网络-IO"><a href="#网络-IO" class="headerlink" title="网络 IO"></a>网络 IO</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 上行带宽</span><br><span class="line">sum by (instance) (irate(node_network_receive_bytes&#123;instance="xxx",device!~"bond.*?|lo"&#125;[5m])/128)</span><br><span class="line"></span><br><span class="line">// 下行带宽</span><br><span class="line">sum by (instance) (irate(node_network_transmit_bytes&#123;instance="xxx",device!~"bond.*?|lo"&#125;[5m])/128)</span><br><span class="line">1.2.3.4.5.</span><br></pre></td></tr></table></figure><h3 id="网卡出-入包"><a href="#网卡出-入包" class="headerlink" title="网卡出/入包"></a>网卡出/入包</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 入包量</span><br><span class="line">sum by (instance) (rate(node_network_receive_bytes&#123;instance="xxx",device!="lo"&#125;[5m]))</span><br><span class="line"></span><br><span class="line">// 出包量</span><br><span class="line">sum by (instance) (rate(node_network_transmit_bytes&#123;instance="xxx",device!="lo"&#125;[5m]))</span><br><span class="line">1.2.3.4.5.</span><br></pre></td></tr></table></figure><h1 id="Prometheus-配置详解"><a href="#Prometheus-配置详解" class="headerlink" title="Prometheus 配置详解"></a>Prometheus 配置详解</h1><p>要想知道一个工具是如何运行的，那么了解其配置参数，对了解整个工具以及后续的瓶颈了解、优化是非常有帮助的。</p><p>官方文档说明: <a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/" target="_blank" rel="external">https://prometheus.io/docs/prometheus/latest/configuration/configuration/</a></p><p>Prometheus 配置分为两个部分，命令行传递的不可变配置，配置文件传递的可变配置。所谓不可变是指进程进行运行中是不可以动态更新。</p><p>Prometheus提供了两个可执行文件：prometheus 和 promtool，前者用于prometheus server的启停，后者为prometheus调试工具，常用于配置文件检查。</p><p>prometheus 常用参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-h, --help                              显示帮助信息</span><br><span class="line">    --version                           显示版本</span><br><span class="line">    --config.file=&quot;prometheus.yml&quot;      指定配置文件</span><br><span class="line">    --web.listen-address=&quot;0.0.0.0:9090&quot; 指定监听的端口</span><br><span class="line">    --web.max-connections=512           最大连接数</span><br><span class="line">    --web.enable-lifecycle              是否开启reload和shutdown的远程API</span><br><span class="line">    --web.enable-admin-api              是否开启管理API</span><br><span class="line">    --web.console.templates=&quot;consoles&quot;  控制台模板目录</span><br><span class="line">    --web.console.libraries=&quot;console_libraries&quot;  控制台库文件目录</span><br><span class="line">    --storage.tsdb.path=&quot;data/&quot;         数据存储路径</span><br><span class="line">    --storage.tsdb.retention.time       数据保留时间，默认15天</span><br><span class="line">    --query.timeout=2m                  查询超时时间</span><br><span class="line">    --query.max-concurrency=20          最大并发查询数量</span><br><span class="line">    --query.max-samples=50000000        单次查询返回的最大样本数</span><br><span class="line">    --log.level=info                    日志级别: [debug, info, warn, error]</span><br><span class="line">    --log.format=logfmt                 日志输出格式：[logfmt, json]</span><br></pre></td></tr></table></figure><p>promtool 常用参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">check config &lt;config-files&gt;...  检查配置文件</span><br><span class="line">check rules &lt;rule-files&gt;...     检查规则文件</span><br></pre></td></tr></table></figure><h2 id="热加载"><a href="#热加载" class="headerlink" title="热加载"></a>热加载</h2><p>Prometheus改变参数可以通过命令行参数以及配置文件，其中命令行参数只要是修改系统参数，例如存储路径的指定或者挂载磁盘<br>Prometheus可以在运行时重新加载它的配置。 如果新配置格式不正确，则更改将不会应用。 通过向Prometheus进程发送<code>SIGHUP</code>或向<code>/-/reload</code>端点发送HTTP POST请求（启用<code>--web.enable-lifecycle</code>标志时）来触发配置reload。 这也将重新加载任何配置的规则文件。</p><p>prometheus通过<code>--config.file</code>命令行参数指定配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">配置热加载：</span><br><span class="line">#1.  kill -HUP pid # 发送 SIGHUP 信号给prometheus进程</span><br><span class="line">#2.  curl -X POST http://IP/-/reload # 调用 /-/reload API，仅在启用 --web.enable-lifecycle 状态下</span><br></pre></td></tr></table></figure><h2 id="通用类型"><a href="#通用类型" class="headerlink" title="通用类型"></a>通用类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. &lt;boolean&gt;：true false</span><br><span class="line">2. &lt;duration&gt;：与正则表达式[0-9]+(ms|[smhdwy])匹配的持续时间</span><br><span class="line">3. &lt;labelname&gt;：与正则表达式匹配的字符串[a-zA-Z_][a-zA-Z0-9_]*</span><br><span class="line">4. &lt;labelvalue&gt;：一个unicode字符串</span><br><span class="line">5. &lt;filename&gt;：当前工作目录中的有效路径</span><br><span class="line">6. &lt;host&gt;：一个有效的字符串，由一个主机名或IP后跟一个可选的端口号组成</span><br><span class="line">7. &lt;path&gt;：有效的URL路径</span><br><span class="line">8. &lt;scheme&gt;：可以取值为http或https的字符串</span><br><span class="line">9. &lt;string&gt;：一个常规字符串</span><br><span class="line">10. &lt;secret&gt;：一个常用的密码字符串，例如密码</span><br><span class="line">11. &lt;tmpl_string&gt;：在使用前被模板扩展的字符串</span><br></pre></td></tr></table></figure><h2 id="配置文件格式"><a href="#配置文件格式" class="headerlink" title="配置文件格式"></a>配置文件格式</h2><p>原始配置文件内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># my global config</span></span><br><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="comment"># 默认情况下抓取目标的频率.</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">scrape_interval:</span> <span class="string">&lt;duration&gt;</span> <span class="string">| default = 1m ]</span></span><br><span class="line"><span class="string">  # 抓取超时时间.</span></span><br><span class="line"><span class="string">  [ scrape_timeout: &lt;duration&gt; | default = 10s ]</span></span><br><span class="line"><span class="string">  # 评估规则的频率.</span></span><br><span class="line"><span class="string">  [ evaluation_interval: &lt;duration&gt; | default = 1m ]</span></span><br><span class="line"><span class="string">  # 与外部系统通信时对时间序列或者告警信息添加的标签，如remote storage、alertmanager等</span></span><br><span class="line"><span class="string"></span><span class="attr">  external_labels:</span></span><br><span class="line">    <span class="string">[</span> <span class="string">&lt;labelname&gt;:</span> <span class="string">&lt;labelvalue&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line">  <span class="comment"># PromQL查询日志，reload操作会重新打开日志</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">query_log_file:</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 警报指定与Alertmanager相关的设置.</span></span><br><span class="line"><span class="attr">alerting:</span></span><br><span class="line">  <span class="comment"># 告警标签重写</span></span><br><span class="line"><span class="attr">  alert_relabel_configs:</span></span><br><span class="line">    <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;relabel_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line">  <span class="comment"># alertmanager 配置</span></span><br><span class="line"><span class="attr">  alertmanagers:</span></span><br><span class="line"><span class="attr">  - static_configs:</span></span><br><span class="line"><span class="attr">    - targets:</span></span><br><span class="line">      <span class="comment"># - alertmanager:9093</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 规则文件指定了一个globs列表. </span></span><br><span class="line"><span class="comment"># 从所有匹配的文件中读取规则和警报. </span></span><br><span class="line"><span class="comment"># 根据 global 的 'evaluation_interval'.</span></span><br><span class="line"><span class="attr">rule_files:</span></span><br><span class="line">  <span class="comment"># - "first_rules.yml"</span></span><br><span class="line">  <span class="comment"># - "second_rules.yml"</span></span><br><span class="line">  <span class="comment"># - "/etc/config/rules/*.yml" # 代表rules目录下的所有以.yml结尾的文件</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># A scrape configuration containing exactly one endpoint to scrape:</span></span><br><span class="line"><span class="comment"># Here it's Prometheus itself.</span></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="comment"># The job name is added as a label `job=` to any timeseries scraped from this config.</span></span><br><span class="line"><span class="attr">  - job_name:</span> <span class="string">'prometheus'</span></span><br><span class="line">    <span class="comment"># metrics_path defaults to '/metrics'</span></span><br><span class="line">    <span class="comment"># scheme defaults to 'http'.</span></span><br><span class="line"><span class="attr">    static_configs:</span></span><br><span class="line"><span class="attr">    - targets:</span> <span class="string">['localhost:9090']</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 与远程写入功能相关的设置.</span></span><br><span class="line"><span class="attr">remote_write:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;remote_write&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 与远程读取功能相关的设置.</span></span><br><span class="line"><span class="attr">remote_read:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;remote_read&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br></pre></td></tr></table></figure><blockquote><p>global: 全局配置（如果有内部单独设定，会覆盖这个参数）<br>alerting: 告警插件定义。这里会设定alertmanager这个报警插件。<br>rule_files: 告警规则。 按照设定参数进行扫描加载，用于自定义报警规则，其报警媒介和route路由由alertmanager插件实现。<br>scrape_configs:采集配置。配置数据源，包含分组job_name以及具体target。又分为静态配置和服务发现</p></blockquote><h2 id="global-模块"><a href="#global-模块" class="headerlink" title="global 模块"></a>global 模块</h2><p>global配置是一个全局的配置，如果没有对每一个<code>job（scrape_configs下的job_name项）</code>配置，就采用全局的配置。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># my global config</span></span><br><span class="line"><span class="attr">global:</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">scrape_interval:</span> <span class="number">15</span><span class="string">s</span> <span class="comment"># 默认15s 全局每次数据收集的间隔</span></span><br><span class="line"><span class="attr">evaluation_interval:</span> <span class="number">15</span><span class="string">s</span> <span class="comment"># 规则扫描时间间隔是15秒，默认不填写是 1分钟</span></span><br><span class="line"><span class="attr">scrape_timeout:</span> <span class="number">5</span><span class="string">s</span>    <span class="comment">#超时时间</span></span><br><span class="line"><span class="attr">external_labels:</span> <span class="comment"># 用于外部系统标签的，不是用于metrics(度量)数据</span></span><br></pre></td></tr></table></figure><p>常用的命令行参数(prometheus插件基本都是二进制的，可以通过二进制文件 -h了解参数用于自定义启动参数，否则默认)</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./prometheus</span> <span class="bullet">-h</span></span><br><span class="line"><span class="bullet">-</span><span class="bullet">-config.file="/opt/config/prometheus.yml"</span>  <span class="comment"># 读取指定配置文件</span></span><br><span class="line"><span class="bullet">-</span><span class="bullet">-web.listen-address="0.0.0.0:9090"</span>  <span class="comment"># 指定prometheus运行端口 </span></span><br><span class="line"><span class="bullet">-</span><span class="bullet">-log.level=info</span> <span class="comment"># 日志级别</span></span><br><span class="line"><span class="bullet">-</span><span class="bullet">-alertmanager.timeout=10s</span> <span class="comment"># 与报警组件的超时时间</span></span><br></pre></td></tr></table></figure><h2 id="alerting-模块"><a href="#alerting-模块" class="headerlink" title="alerting 模块"></a>alerting 模块</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 警报指定与Alertmanager相关的设置.</span></span><br><span class="line"><span class="attr">alerting:</span></span><br><span class="line">  <span class="comment"># 告警标签重写</span></span><br><span class="line"><span class="attr">  alert_relabel_configs:</span></span><br><span class="line">    <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;relabel_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line">  <span class="comment"># alertmanager 配置</span></span><br><span class="line"><span class="attr">  alertmanagers:</span></span><br><span class="line"><span class="attr">  - static_configs:</span></span><br><span class="line"><span class="attr">    - targets:</span></span><br><span class="line">      <span class="comment"># - alertmanager:9093</span></span><br></pre></td></tr></table></figure><p>这里定义和prometheus集成的alertmanager插件，用于监控报警。</p><h3 id="alert-relabel-configs"><a href="#alert-relabel-configs" class="headerlink" title="alert_relabel_configs"></a>alert_relabel_configs</h3><p>警报重新标记在发送到Alertmanager之前应用于警报。 它具有与目标重新标记相同的配置格式和操作。 外部标签后应用警报重新标记。</p><p>这样做的一个用途是确保具有不同外部标签的HA对Prometheus服务器发送相同的警报。</p><h3 id="alertmanager-config"><a href="#alertmanager-config" class="headerlink" title="alertmanager_config"></a>alertmanager_config</h3><p><code>alertmanager</code>部分指定Prometheus服务器向其发送警报的Alertmanager实例。 它还提供参数以配置如何与这些Alertmanagers进行通信。</p><p>Alertmanagers可以通过<code>static_configs</code>参数静态配置，也可以使用其中一种支持的服务发现机制动态发现。</p><p>此外，<code>relabel_configs</code>允许从发现的实体中选择Alertmanagers，并对使用的API路径提供高级修改，该路径通过<code>__alerts_path__</code>标签公开。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 推送警报时按目标Alertmanager超时。</span></span><br><span class="line"><span class="string">[</span> <span class="attr">timeout:</span> <span class="string">&lt;duration&gt;</span> <span class="string">| default = 10s ]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 将推送HTTP路径警报的前缀。</span></span><br><span class="line"><span class="string">[ path_prefix: &lt;path&gt; | default = / ]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 配置用于请求的协议方案。</span></span><br><span class="line"><span class="string">[ scheme: &lt;scheme&gt; | default = http ]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 使用配置的用户名和密码在每个请求上设置`Authorization`标头。 password和password_file是互斥的。</span></span><br><span class="line"><span class="string"></span><span class="attr">basic_auth:</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">username:</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">password:</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">password_file:</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用配置的承载令牌在每个请求上设置“Authorization”标头。 它与`bearer_token_file`互斥。</span></span><br><span class="line"><span class="string">[</span> <span class="attr">bearer_token:</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用配置的承载令牌在每个请求上设置“Authorization”标头。 它与`bearer_token`互斥。</span></span><br><span class="line"><span class="string">[</span> <span class="attr">bearer_token_file:</span> <span class="string">/path/to/bearer/token/file</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置scrape请求的TLS设置。</span></span><br><span class="line"><span class="attr">tls_config:</span></span><br><span class="line">  <span class="string">[</span> <span class="string">&lt;tls_config&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选的代理URL。</span></span><br><span class="line"><span class="string">[</span> <span class="attr">proxy_url:</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Azure服务发现配置列表。</span></span><br><span class="line"><span class="attr">azure_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;azure_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"><span class="comment"># Consul服务发现配置列表。</span></span><br><span class="line"><span class="attr">consul_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;consul_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"><span class="comment"># DNS服务发现配置列表。</span></span><br><span class="line"><span class="attr">dns_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;dns_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"><span class="comment"># ECS服务发现配置列表。</span></span><br><span class="line"><span class="attr">ec2_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;ec2_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"><span class="comment"># 文件服务发现配置列表。</span></span><br><span class="line"><span class="attr">file_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;file_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"><span class="comment"># GCE服务发现配置列表。</span></span><br><span class="line"><span class="attr">gce_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;gce_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"><span class="comment"># K8S服务发现配置列表。</span></span><br><span class="line"><span class="attr">kubernetes_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;kubernetes_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"><span class="comment"># Marathon服务发现配置列表。</span></span><br><span class="line"><span class="attr">marathon_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;marathon_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"><span class="comment"># AirBnB's Nerve 服务发现配置列表。</span></span><br><span class="line"><span class="attr">nerve_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;nerve_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"><span class="comment"># Zookepper服务发现配置列表。</span></span><br><span class="line"><span class="attr">serverset_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;serverset_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"><span class="comment"># Triton服务发现配置列表。</span></span><br><span class="line"><span class="attr">triton_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;triton_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"><span class="comment"># 标记为静态配置的Alertmanagers列表。</span></span><br><span class="line"><span class="attr">static_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;static_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对发现的alertmanager进行筛选和标签重写，比如API中PATH</span></span><br><span class="line"><span class="attr">relabel_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;relabel_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br></pre></td></tr></table></figure><h2 id="rule-files-模块"><a href="#rule-files-模块" class="headerlink" title="rule_files 模块"></a>rule_files 模块</h2><p>这个主要是用来设置告警规则，基于设定什么指标进行报警（类似触发器trigger）。这里设定好规则以后，prometheus会根据全局global设定的evaluation_interval参数进行扫描加载，规则改动后会自动加载。其报警媒介和route路由由alertmanager插件实现。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Load rules once and periodically evaluate them according to the global 'evaluation_interval'.</span></span><br><span class="line"><span class="attr">rule_files:</span></span><br><span class="line">  <span class="comment"># - "first_rules.yml"</span></span><br><span class="line">  <span class="comment"># - "second_rules.yml"</span></span><br><span class="line">  <span class="comment"># - "/etc/config/rules/*.yml" # 代表rules目录下的所有以.yml结尾的文件</span></span><br></pre></td></tr></table></figure><p>规则文件分为两种：记录规则(recording rule)和报警规则(altering rule)。报警规则在告警管理中。recording rules 目的是将常用的复杂查询结果周期性写入数据库，避免频繁计算带来的资源消耗，一般将dashboard中复杂查询写入recording rules 中。</p><h3 id="recording-rule"><a href="#recording-rule" class="headerlink" title="recording rule"></a>recording rule</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># recording rule</span></span><br><span class="line"><span class="attr">groups:</span></span><br><span class="line">  <span class="comment"># 组名，配置文件中不能重复</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">    <span class="comment"># 多久计算计算一次</span></span><br><span class="line">    <span class="string">[</span> <span class="attr">interval:</span> <span class="string">&lt;duration&gt;</span> <span class="string">| default = global.evaluation_interval ]</span></span><br><span class="line"><span class="string"></span><span class="attr">    rules:</span></span><br><span class="line">      <span class="comment"># 入库的指标名称</span></span><br><span class="line"><span class="attr">      - record:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">        <span class="comment"># PromQL表达式</span></span><br><span class="line"><span class="attr">        expr:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">        <span class="comment"># 标签</span></span><br><span class="line"><span class="attr">    labels:</span></span><br><span class="line">      <span class="string">[</span> <span class="string">&lt;labelname&gt;:</span> <span class="string">&lt;labelvalue&gt;</span> <span class="string">]</span></span><br></pre></td></tr></table></figure><h3 id="altering-rule"><a href="#altering-rule" class="headerlink" title="altering rule"></a>altering rule</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># alerting rule</span></span><br><span class="line"><span class="attr">groups:</span></span><br><span class="line">  <span class="comment"># 组名，一个文件中唯一标识</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line">    <span class="string">[</span> <span class="attr">interval:</span> <span class="string">&lt;duration&gt;</span> <span class="string">| default = global.evaluation_interval ]</span></span><br><span class="line"><span class="string"></span><span class="attr">    rules:</span></span><br><span class="line"><span class="attr">      - alert:</span> <span class="string">&lt;string&gt;</span> <span class="comment"># 报警名称</span></span><br><span class="line"><span class="attr">        expr:</span> <span class="string">&lt;string&gt;</span>  <span class="comment"># 报警规则表达式</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">for:</span> <span class="string">&lt;duration&gt;</span> <span class="string">| default = 0s ] # 当触发条件持续指定时间再发送告警，发送前告警为pending</span></span><br><span class="line"><span class="string"></span><span class="attr">  labels:</span>         <span class="comment"># 告警标签</span></span><br><span class="line">      <span class="string">[</span> <span class="string">&lt;labelname&gt;:</span> <span class="string">&lt;tmpl_string&gt;</span> <span class="string">]</span> <span class="comment"># 会覆盖已有的标签，用于后面alertmanager中筛选</span></span><br><span class="line"><span class="attr">  annotations:</span>         <span class="comment"># 告警注释</span></span><br><span class="line">    <span class="string">[</span> <span class="string">&lt;labelname&gt;:</span> <span class="string">&lt;tmpl_string&gt;</span> <span class="string">]</span>   <span class="comment"># 一般添加发送邮件的内容、标题等等。常用字段有:summary,description</span></span><br></pre></td></tr></table></figure><h2 id="scrape-configs-模块"><a href="#scrape-configs-模块" class="headerlink" title="scrape_configs 模块"></a>scrape_configs 模块</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">scrape_configs</span> <span class="string">默认规则：</span></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="comment"># The job name is added as a label `job=` to any timeseries scraped from this config.</span></span><br><span class="line"><span class="attr">  - job_name:</span> <span class="string">'prometheus'</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># metrics_path defaults to '/metrics'</span></span><br><span class="line">    <span class="comment"># scheme defaults to 'http'.</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">    static_configs:</span></span><br><span class="line"><span class="attr">    - targets:</span> <span class="string">['localhost:9090']</span></span><br></pre></td></tr></table></figure><p>prometheus获取数据源target的方式有多种，如静态配置和服务发现配置，prometheus支持多种服务发现，在prometheus中的服务发现主要分为以下几种：</p><ul><li>static_configs：静态服务发现</li><li>kubernetes_sd_configs: 基于Kubernetes的服务发现，这章讲的内容</li><li>consul_sd_configs: Consul 服务发现</li><li>dns_sd_configs: DNS 服务发现</li><li>file_sd_configs: 文件服务发现</li><li>……</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认分配给已抓取指标的job名称。</span></span><br><span class="line"><span class="attr">job_name:</span> <span class="string">&lt;job_name&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从job中抓取目标的频率.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">scrape_interval:</span> <span class="string">&lt;duration&gt;</span> <span class="string">| default = &lt;global_config.scrape_interval&gt; ]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 抓取此job时，每次抓取超时时间.</span></span><br><span class="line"><span class="string">[ scrape_timeout: &lt;duration&gt; | default = &lt;global_config.scrape_timeout&gt; ]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 从目标获取指标的HTTP资源路径.</span></span><br><span class="line"><span class="string">[ metrics_path: &lt;path&gt; | default = /metrics ]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># honor_labels控制Prometheus如何处理已经存在于已抓取数据中的标签与Prometheus将附加服务器端的标签之间的冲突（"job"和"instance"标签，手动配置的目标标签以及服务发现实现生成的标签）。</span></span><br><span class="line"><span class="string"># </span></span><br><span class="line"><span class="string"># 如果honor_labels设置为"true"，则通过保留已抓取数据的标签值并忽略冲突的服务器端标签来解决标签冲突。</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string"># 如果honor_labels设置为"false"，则通过将已抓取数据中的冲突标签重命名为"exported_ &lt;original-label&gt;"（例如"exported_instance"，"exported_job"）然后附加服务器端标签来解决标签冲突。 这对于联合等用例很有用，其中应保留目标中指定的所有标签。</span></span><br><span class="line"><span class="string"># </span></span><br><span class="line"><span class="string"># 请注意，任何全局配置的"external_labels"都不受此设置的影响。 在与外部系统通信时，它们始终仅在时间序列尚未具有给定标签时应用，否则将被忽略。</span></span><br><span class="line"><span class="string"># </span></span><br><span class="line"><span class="string">[ honor_labels: &lt;boolean&gt; | default = false ]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 配置用于请求的协议方案.</span></span><br><span class="line"><span class="string">[ scheme: &lt;scheme&gt; | default = http ]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 可选的HTTP URL参数.</span></span><br><span class="line"><span class="string"></span><span class="attr">params:</span></span><br><span class="line">  <span class="string">[</span> <span class="string">&lt;string&gt;:</span> <span class="string">[&lt;string&gt;,</span> <span class="string">...]</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用配置的用户名和密码在每个scrape请求上设置`Authorization`标头。 password和password_file是互斥的。</span></span><br><span class="line"><span class="attr">basic_auth:</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">username:</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">password:</span> <span class="string">&lt;secret&gt;</span> <span class="string">]</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">password_file:</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用配置的承载令牌在每个scrape请求上设置`Authorization`标头。 它`bearer_token_file`和是互斥的。</span></span><br><span class="line"><span class="string">[</span> <span class="attr">bearer_token:</span> <span class="string">&lt;secret&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用配置的承载令牌在每个scrape请求上设置`Authorization`标头。 它`bearer_token`和是互斥的。</span></span><br><span class="line"><span class="string">[</span> <span class="attr">bearer_token_file:</span> <span class="string">/path/to/bearer/token/file</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置scrape请求的TLS设置.</span></span><br><span class="line"><span class="attr">tls_config:</span></span><br><span class="line">  <span class="string">[</span> <span class="string">&lt;tls_config&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选的代理URL.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">proxy_url:</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Azure服务发现配置列表.</span></span><br><span class="line"><span class="attr">azure_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;azure_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Consul服务发现配置列表.</span></span><br><span class="line"><span class="attr">consul_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;consul_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># DNS服务发现配置列表。</span></span><br><span class="line"><span class="attr">dns_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;dns_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># EC2服务发现配置列表。</span></span><br><span class="line"><span class="attr">ec2_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;ec2_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># OpenStack服务发现配置列表。</span></span><br><span class="line"><span class="attr">openstack_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;openstack_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件服务发现配置列表。</span></span><br><span class="line"><span class="attr">file_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;file_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># GCE服务发现配置列表。</span></span><br><span class="line"><span class="attr">gce_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;gce_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Kubernetes服务发现配置列表。</span></span><br><span class="line"><span class="attr">kubernetes_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;kubernetes_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Marathon服务发现配置列表。</span></span><br><span class="line"><span class="attr">marathon_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;marathon_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># AirBnB的神经服务发现配置列表。</span></span><br><span class="line"><span class="attr">nerve_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;nerve_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Zookeeper Serverset服务发现配置列表。</span></span><br><span class="line"><span class="attr">serverset_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;serverset_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Triton服务发现配置列表。</span></span><br><span class="line"><span class="attr">triton_sd_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;triton_sd_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 静态抓取目标配置，一般只有极个别场景才会配置，否则会导致主配置文件更新频繁，并且很臃肿</span></span><br><span class="line"><span class="attr">static_configs:</span></span><br><span class="line">  <span class="comment"># 指定抓取目标的地址</span></span><br><span class="line"><span class="attr">  targets:</span></span><br><span class="line">    <span class="string">[</span> <span class="bullet">-</span> <span class="string">'&lt;host&gt;'</span> <span class="string">]</span></span><br><span class="line">  <span class="comment"># 对采集到的数据指定额外的标签</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line">    <span class="string">[</span> <span class="string">&lt;labelname&gt;:</span> <span class="string">&lt;labelvalue&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># target 标签重写规则</span></span><br><span class="line"><span class="attr">relabel_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;relabel_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># metrics 标签重写规则。</span></span><br><span class="line"><span class="attr">metric_relabel_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;relabel_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 样本数限制，超过规定之则被丢弃。0表示不限制</span></span><br><span class="line"><span class="string">[</span> <span class="attr">sample_limit:</span> <span class="string">&lt;int&gt;</span> <span class="string">| default = 0 ]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># target 数量限制，超过的将被丢弃，目前为实验性功能。0表示不限制</span></span><br><span class="line"><span class="string">[ target_limit: &lt;int&gt; | default = 0 ]</span></span><br></pre></td></tr></table></figure><h3 id="tls-config"><a href="#tls-config" class="headerlink" title="tls_config"></a>tls_config</h3><p><code>tls_config</code>允许配置TLS连接。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用于验证API服务器证书的CA证书。</span></span><br><span class="line"><span class="string">[</span> <span class="attr">ca_file:</span> <span class="string">&lt;filename&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于服务器的客户端证书身份验证的证书和密钥文件。</span></span><br><span class="line"><span class="string">[</span> <span class="attr">cert_file:</span> <span class="string">&lt;filename&gt;</span> <span class="string">]</span></span><br><span class="line"><span class="string">[</span> <span class="attr">key_file:</span> <span class="string">&lt;filename&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ServerName扩展名，用于指示服务器的名称。</span></span><br><span class="line"><span class="comment"># https://tools.ietf.org/html/rfc4366#section-3.1</span></span><br><span class="line"><span class="string">[</span> <span class="attr">server_name:</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁用服务器证书的验证。</span></span><br><span class="line"><span class="string">[</span> <span class="attr">insecure_skip_verify:</span> <span class="string">&lt;boolean&gt;</span> <span class="string">]</span></span><br></pre></td></tr></table></figure><h3 id="file-sd-config"><a href="#file-sd-config" class="headerlink" title="file_sd_config"></a>file_sd_config</h3><p>配置target 的文件可以是json也可以是yaml，推荐使用yaml，方便查看。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主配置文件中 &lt;file_sd_config&gt;</span></span><br><span class="line"><span class="comment"># 配置target的文件列表</span></span><br><span class="line"><span class="attr">files:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;filename_pattern&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从这些文件中读取配置的时间间隔</span></span><br><span class="line"><span class="string">[</span> <span class="attr">refresh_interval:</span> <span class="string">&lt;duration&gt;</span> <span class="string">| default = 5m ]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 自动发现文件配置案例</span></span><br><span class="line"><span class="string"></span><span class="attr">- targets:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">address1</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">address2</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    labelname1:</span> <span class="string">labelvalue1</span></span><br><span class="line"><span class="attr">    labelname2:</span> <span class="string">labelvalue2</span></span><br></pre></td></tr></table></figure><h3 id="dns-sd-config"><a href="#dns-sd-config" class="headerlink" title="dns_sd_config"></a>dns_sd_config</h3><p>基于DNS的服务发现配置允许指定一组DNS域名，这些域名会定期查询以发现目标列表。 要联系的DNS服务器从<code>/etc/resolv.conf</code>中读取。</p><p>此服务发现方法仅支持基本的DNS A，AAAA和SRV记录查询，但不支持RFC6763中指定的高级DNS-SD方法。</p><p>在重新标记阶段，元标签<code>__meta_dns_name</code>在每个目标上可用，并设置为生成已发现目标的记录名称。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 要查询的DNS域名列表。</span></span><br><span class="line"><span class="attr">names:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;domain_name&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要执行的DNS查询的类型。</span></span><br><span class="line"><span class="string">[</span> <span class="attr">type:</span> <span class="string">&lt;query_type&gt;</span> <span class="string">| default = 'SRV' ]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 查询类型不是SRV时使用的端口号。</span></span><br><span class="line"><span class="string">[ port: &lt;number&gt;]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 提供名称后刷新的时间。</span></span><br><span class="line"><span class="string">[ refresh_interval: &lt;duration&gt; | default = 30s ]</span></span><br></pre></td></tr></table></figure><p>其中<code>&lt;domain_name&gt;</code>是有效的DNS域名。 其中<code>&lt;query_type&gt;</code>是SRV，A或AAAA。</p><h3 id="consul-sd-configs"><a href="#consul-sd-configs" class="headerlink" title="consul_sd_configs"></a>consul_sd_configs</h3><p>consul 是基于go语言写的注册中心，在生产中可以作为prometheus自动发现的中间件。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># consul 地址信息</span></span><br><span class="line"><span class="string">[</span> <span class="attr">server:</span> <span class="string">&lt;host&gt;</span> <span class="string">| default = "localhost:8500" ]</span></span><br><span class="line"><span class="string">[ token: &lt;secret&gt; ]</span></span><br><span class="line"><span class="string">[ datacenter: &lt;string&gt; ]</span></span><br><span class="line"><span class="string">[ scheme: &lt;string&gt; | default = "http" ]</span></span><br><span class="line"><span class="string">[ username: &lt;string&gt; ]</span></span><br><span class="line"><span class="string">[ password: &lt;secret&gt; ]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span><span class="attr">tls_config:</span></span><br><span class="line">  <span class="string">[</span> <span class="string">&lt;tls_config&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动发现请求访问哪些服务，默认是所有服务</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 过滤目标节点，只有全部包含这些tag的服务地址才会给prometheus认定为target</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过元数据的键值对节点进行过滤</span></span><br><span class="line"><span class="string">[</span> <span class="attr">node_meta:</span></span><br><span class="line">  <span class="string">[</span> <span class="string">&lt;string&gt;:</span> <span class="string">&lt;string&gt;</span> <span class="string">...</span> <span class="string">]</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The string by which Consul tags are joined into the tag label.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">tag_separator:</span> <span class="string">&lt;string&gt;</span> <span class="string">| default = , ]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># Allow stale Consul results (see https://www.consul.io/api/features/consistency.html). Will reduce load on Consul.</span></span><br><span class="line"><span class="string">[ allow_stale: &lt;boolean&gt; | default = true ]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 访问consul的时间间隔</span></span><br><span class="line"><span class="string">[ refresh_interval: &lt;duration&gt; | default = 30s ]</span></span><br></pre></td></tr></table></figure><h3 id="kubernetes-sd-config"><a href="#kubernetes-sd-config" class="headerlink" title="kubernetes_sd_config"></a>kubernetes_sd_config</h3><p>Kubernetes SD配置允许从<a href="https://kubernetes.io/" target="_blank" rel="external">Kubernetes</a>的RESTAPI中检索scrape目标，并始终与群集状态保持同步。</p><p>可以配置以下<code>role</code>类型之一来发现目标：</p><ul><li>node</li><li>service</li><li>pod</li><li>endpoints</li><li>ingress</li></ul><h4 id="node"><a href="#node" class="headerlink" title="node"></a>node</h4><p><code>node</code>角色发现每个群集节点有一个目标，其地址默认为Kubelet的HTTP端口。 目标地址默认为<code>NodeInternalIP</code>，<code>NodeExternalIP</code>，<code>NodeLegacyHostIP</code>和<code>NodeHostName</code>的地址类型顺序中Kubernetes节点对象的第一个现有地址。</p><p>可用元标签：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__meta_kubernetes_node_name: 节点名称</span><br><span class="line">__meta_kubernetes_node_label_&lt;labelname&gt;: node的labels</span><br><span class="line">__meta_kubernetes_node_annotation_&lt;annotationname&gt;: node的annotation</span><br><span class="line">__meta_kubernetes_node_address_&lt;address_type&gt;: 如果存在四个值中(NodeInternalIP, NodeExternalIP, NodeLegacyHostIP, and NodeHostName)的一个</span><br></pre></td></tr></table></figure><p>此外，节点的<code>instance</code>标签将设置为从API服务器检索的节点名称。</p><h4 id="service"><a href="#service" class="headerlink" title="service"></a>service</h4><p><code>service</code>角色为每个服务发现每个服务端口的目标。 这对于服务的黑盒监控通常很有用。 该地址将设置为服务的Kubernetes DNS名称和相应的服务端口。</p><p>可用元标签：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__meta_kubernetes_namespace：服务对象的命名空间。</span><br><span class="line">__meta_kubernetes_service_annotation_&lt;annotationname&gt;：服务对象的注释。</span><br><span class="line">__meta_kubernetes_service_cluster_ip：服务的群集IP地址。 （不适用于ExternalName类型的服务）</span><br><span class="line">__meta_kubernetes_service_external_name：服务的DNS名称。 （适用于ExternalName类型的服务）</span><br><span class="line">__meta_kubernetes_service_label_ &lt;labelname&gt;：服务对象的标签。</span><br><span class="line">__meta_kubernetes_service_name：服务对象的名称。</span><br><span class="line">__meta_kubernetes_service_port_name：目标服务端口的名称。</span><br><span class="line">__meta_kubernetes_service_port_number：目标的服务端口号。</span><br><span class="line">__meta_kubernetes_service_port_protocol：目标服务端口的协议。</span><br></pre></td></tr></table></figure><h4 id="pod"><a href="#pod" class="headerlink" title="pod"></a>pod</h4><p><code>pod</code>角色发现所有<code>pod</code>并将其容器暴露为目标。 对于容器的每个声明端口，将生成单个目标。 如果容器没有指定端口，则会创建每个容器的无端口目标，以通过重新标记手动添加端口。</p><p>可用元标签：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">__meta_kubernetes_namespace：pod对象的命名空间。</span><br><span class="line">__meta_kubernetes_pod_name：pod对象的名称。</span><br><span class="line">__meta_kubernetes_pod_ip：pod对象的pod IP。</span><br><span class="line">__meta_kubernetes_pod_label_ &lt;labelname&gt;：pod对象的标签。</span><br><span class="line">__meta_kubernetes_pod_annotation_ &lt;annotationname&gt;：pod对象的注释。</span><br><span class="line">__meta_kubernetes_pod_container_name：目标地址指向的容器的名称。</span><br><span class="line">__meta_kubernetes_pod_container_port_name：容器端口的名称。</span><br><span class="line">__meta_kubernetes_pod_container_port_number：容器端口号。</span><br><span class="line">__meta_kubernetes_pod_container_port_protocol：容器端口的协议。</span><br><span class="line">__meta_kubernetes_pod_ready：对于pod的就绪状态，设置为true或false。</span><br><span class="line">__meta_kubernetes_pod_phase：在生命周期中设置为Pending，Running，Succeeded，Failed或Unknown。</span><br><span class="line">__meta_kubernetes_pod_node_name：将pod安排到的节点的名称。</span><br><span class="line">__meta_kubernetes_pod_host_ip：pod对象的当前主机IP。</span><br><span class="line">__meta_kubernetes_pod_uid：pod对象的UID。</span><br><span class="line">__meta_kubernetes_pod_controller_kind：对象类型的pod控制器。</span><br><span class="line">__meta_kubernetes_pod_controller_name：pod控制器的名称。</span><br></pre></td></tr></table></figure><h4 id="endpoints"><a href="#endpoints" class="headerlink" title="endpoints"></a>endpoints</h4><p><code>endpoints</code>角色从列出的服务端点发现目标。 对于每个端点地址，每个端口发现一个目标。 如果端点由<code>pod</code>支持，则<code>pod</code>的所有其他容器端口（未绑定到端点端口）也会被发现为目标。</p><p>可用元标签：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__meta_kubernetes_namespace：端点对象的命名空间。</span><br><span class="line">__meta_kubernetes_endpoints_name：端点对象的名称。对于直接从端点列表中发现的所有目标（不是从底层pod中另外推断的那些），附加以下标签：</span><br><span class="line">__meta_kubernetes_endpoint_ready：对端点的就绪状态设置为true或false。</span><br><span class="line">__meta_kubernetes_endpoint_port_name：端点端口的名称。</span><br><span class="line">__meta_kubernetes_endpoint_port_protocol：端点端口的协议。</span><br><span class="line">__meta_kubernetes_endpoint_address_target_kind：端点地址目标的种类。</span><br><span class="line">__meta_kubernetes_endpoint_address_target_name：端点地址目标的名称。</span><br></pre></td></tr></table></figure><p>如果端点属于某个服务，则会附加角色：服务发现的所有标签。<br>对于由pod支持的所有目标，将附加角色的所有标签：pod发现。</p><h4 id="ingress"><a href="#ingress" class="headerlink" title="ingress"></a>ingress</h4><p><code>ingress</code>角色发现每个入口的每个路径的目标。 这通常用于黑盒监控入口。 地址将设置为入口规范中指定的主机。</p><p>可用元标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__meta_kubernetes_namespace：入口对象的名称空间。</span><br><span class="line">__meta_kubernetes_ingress_name：入口对象的名称。</span><br><span class="line">__meta_kubernetes_ingress_label_ &lt;labelname&gt;：入口对象的标签。</span><br><span class="line">__meta_kubernetes_ingress_annotation_&lt;annotationname&gt;：入口对象的注释。</span><br><span class="line">__meta_kubernetes_ingress_scheme：入口的协议方案，如果设置了TLS配置，则为https。 默认为http。</span><br><span class="line">__meta_kubernetes_ingress_path：来自入口规范的路径。 默认为/。</span><br></pre></td></tr></table></figure><p>有关Kubernetes发现的配置选项，请参见下文：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 访问Kubernetes API的信息。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># API服务器地址。 如果保留为空，则假定Prometheus在集群内部运行并自动发现API服务器，并在/var/run/secrets/kubernetes.io/serviceaccount/上使用pod的CA证书和不记名令牌文件。</span></span><br><span class="line"><span class="string">[</span> <span class="attr">api_server:</span> <span class="string">&lt;host&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 应该被发现的实体的Kubernetes角色。</span></span><br><span class="line"><span class="attr">role:</span> <span class="string">&lt;role&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于向API服务器进行身份验证的可选身份验证信息。请注意，`basic_auth`，`bearer_token`和`bearer_token_file`选项是互斥的.password和password_file是互斥的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选的HTTP基本认证信息。</span></span><br><span class="line"><span class="attr">basic_auth:</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">username:</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">password:</span> <span class="string">&lt;secret&gt;</span> <span class="string">]</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">password_file:</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选的承载令牌认证信息。</span></span><br><span class="line"><span class="string">[</span> <span class="attr">bearer_token:</span> <span class="string">&lt;secret&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选的承载令牌文件认证信息。</span></span><br><span class="line"><span class="string">[</span> <span class="attr">bearer_token_file:</span> <span class="string">&lt;filename&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选的代理URL。</span></span><br><span class="line"><span class="string">[</span> <span class="attr">proxy_url:</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># TLS配置。</span></span><br><span class="line"><span class="attr">tls_config:</span></span><br><span class="line">  <span class="string">[</span> <span class="string">&lt;tls_config&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选命名空间发现 如果省略，则使用所有名称空间。</span></span><br><span class="line"><span class="attr">namespaces:</span></span><br><span class="line"><span class="attr">  names:</span></span><br><span class="line">    <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span></span><br></pre></td></tr></table></figure><p>其中<code>&lt;role&gt;</code>必须是<code>endpoints</code>，<code>service</code>，<code>pod</code>，<code>node</code>或<code>ingress</code>。</p><p>有关为Kubernetes配置Prometheus的详细<a href="https://github.com/prometheus/prometheus/blob/release-2.8/documentation/examples/prometheus-kubernetes.yml" target="_blank" rel="external">示例</a>，请参阅此示例Prometheus配置文件。</p><p>您可能希望查看第三方Prometheus<a href="https://github.com/coreos/prometheus-operator" target="_blank" rel="external">操作</a>，它可以在Kubernetes上自动执行Prometheus设置。</p><h3 id="static-config"><a href="#static-config" class="headerlink" title="static_config"></a>static_config</h3><p>static_config允许指定目标列表和它们的公共标签集。 这是在scrape配置中指定静态目标的规范方法。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 静态配置指定的目标。</span></span><br><span class="line"><span class="attr">targets:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">'&lt;host&gt;'</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分配给从目标中已抓取的所有指标的标签。</span></span><br><span class="line"><span class="attr">labels:</span></span><br><span class="line">  <span class="string">[</span> <span class="string">&lt;labelname&gt;:</span> <span class="string">&lt;labelvalue&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br></pre></td></tr></table></figure><h3 id="relabel-config"><a href="#relabel-config" class="headerlink" title="relabel_config"></a>relabel_config</h3><p>重新标记是一个功能强大的工具，可以在目标的标签集被抓取之前重写它，每个采集配置可以配置多个重写标签设置，并按照配置的顺序来应用于每个目标的标签集。</p><p>目标重新标签之后，以__开头的标签将从标签集中删除的。</p><p>如果使用只需要临时的存储临时标签值的，可以使用_tmp作为前缀标识。</p><p><strong>relabel的action类型</strong></p><ul><li>replace: regex匹配source_labels，替换为 replacement ，写入 target_label</li><li>keep：删除regex与source_labels不匹配的target</li><li>drop: 删除regex与source_labels匹配的target</li><li>labelmap: 对所有标签key进行regex匹配(不是source_labels)，将原标签的key替换为replacement指定的key，通常用于改写 <code>__</code> 开头的标签</li><li>labeldrop: 对所有标签key进行regex匹配(不是source_labels)，匹配到的标签被删除(不是target被删除)</li><li>labelkeep: 对所有标签key进行regex匹配(不是source_labels)，不匹配到的标签被删除(不是target被删除)</li><li>hashmod: 当一个job中监控目标数量太多时(自动发现中容易出现)，将任务分散到不同的机器上。hashmod会将 source_labels值哈希后采用 modulus 取余数，并赋值到一个标签，然后在接下来的relabel中进行保留或者剔除，这样能实现每个prometheus采集一部分target数据</li></ul><p>对于标签重写规则重点关注下。本节针对不同 action 进行 target 的标签重写，实验环境如下: 在 prometheus-72 上启动三个 node_exporter 实例，分别监听 8081, 8082, 8083 端口，prometheus-72 从这三个 node_exporter 中采集数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@prometheus-72 ~]# jobs</span><br><span class="line">[1]   Running                 /opt/apps/node_exporter/node_exporter --log.level=error --web.listen-address=&quot;:8081&quot; &amp;</span><br><span class="line">[2]-  Running                 /opt/apps/node_exporter/node_exporter --log.level=error --web.listen-address=&quot;:8082&quot; &amp;</span><br><span class="line">[3]+  Running                 /opt/apps/node_exporter/node_exporter --log.level=error --web.listen-address=&quot;:8083&quot; &amp;</span><br></pre></td></tr></table></figure><h4 id="action-replace"><a href="#action-replace" class="headerlink" title="action: replace"></a>action: replace</h4><p>重写规则之前：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[root@prometheus-72</span> <span class="string">prometheus]#</span> <span class="string">cat</span> <span class="string">prometheus.yml</span> </span><br><span class="line"><span class="attr">global:</span></span><br><span class="line"><span class="attr">  scrape_interval:</span>     <span class="number">60</span><span class="string">s</span></span><br><span class="line"><span class="attr">  external_labels:</span></span><br><span class="line"><span class="attr">    monitor:</span> <span class="string">'codelab-monitor'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line"><span class="attr">  - job_name:</span> <span class="string">'node'</span></span><br><span class="line"><span class="attr">    static_configs:</span></span><br><span class="line"><span class="attr">      - targets:</span> <span class="string">["10.4.7.72:8081"]</span></span><br><span class="line"><span class="attr">        labels:</span></span><br><span class="line"><span class="attr">          app:</span> <span class="string">app-01</span></span><br><span class="line"><span class="attr">          env:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">          role:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">      - targets:</span> <span class="string">["10.4.7.72:8082"]</span></span><br><span class="line"><span class="attr">        labels:</span></span><br><span class="line"><span class="attr">          app:</span> <span class="string">app-02</span></span><br><span class="line"><span class="attr">          env:</span> <span class="string">prod</span></span><br><span class="line"><span class="attr">          role:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">      - targets:</span> <span class="string">["10.4.7.72:8083"]</span></span><br><span class="line"><span class="attr">        labels:</span></span><br><span class="line"><span class="attr">          app:</span> <span class="string">app-02</span></span><br><span class="line"><span class="attr">          env:</span> <span class="string">prod</span></span><br><span class="line"><span class="attr">          role:</span> <span class="string">slave</span></span><br></pre></td></tr></table></figure><p><img src="/Users/stark/Documents/mdPicture/v2-b1941b40a97078f539a5b1330bda4d27_1440w.jpg" alt="img"></p><p>添加新标签host，使其格式为: master-dev-72</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line"><span class="attr">  scrape_interval:</span>     <span class="number">60</span><span class="string">s</span></span><br><span class="line"><span class="attr">  external_labels:</span></span><br><span class="line"><span class="attr">    monitor:</span> <span class="string">'codelab-monitor'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line"><span class="attr">  - job_name:</span> <span class="string">'node'</span></span><br><span class="line"><span class="attr">    static_configs:</span></span><br><span class="line"><span class="attr">      - targets:</span> <span class="string">["10.4.7.72:8081"]</span></span><br><span class="line"><span class="attr">        labels:</span></span><br><span class="line"><span class="attr">          app:</span> <span class="string">app-01</span></span><br><span class="line"><span class="attr">          env:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">          role:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">      - targets:</span> <span class="string">["10.4.7.72:8082"]</span></span><br><span class="line"><span class="attr">        labels:</span></span><br><span class="line"><span class="attr">          app:</span> <span class="string">app-02</span></span><br><span class="line"><span class="attr">          env:</span> <span class="string">prod</span></span><br><span class="line"><span class="attr">          role:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">      - targets:</span> <span class="string">["10.4.7.72:8083"]</span></span><br><span class="line"><span class="attr">        labels:</span></span><br><span class="line"><span class="attr">          app:</span> <span class="string">app-02</span></span><br><span class="line"><span class="attr">          env:</span> <span class="string">prod</span></span><br><span class="line"><span class="attr">          role:</span> <span class="string">slave</span></span><br><span class="line"><span class="attr">    relabel_configs:</span></span><br><span class="line"><span class="attr">      - source_labels:</span> <span class="string">["role",</span> <span class="string">"env"</span><span class="string">,</span> <span class="string">"__address__"</span><span class="string">]</span></span><br><span class="line"><span class="attr">        target_label:</span> <span class="string">host</span></span><br><span class="line"><span class="attr">        regex:</span> <span class="string">(.+);(.+);([0-9]&#123;1,3&#125;\.)&#123;3&#125;([0-9]+):[0-9]+</span> <span class="comment"># source_labels默认 ; 拼接</span></span><br><span class="line"><span class="attr">        replacement:</span> <span class="string">$1-$2-$4</span></span><br></pre></td></tr></table></figure><p><img src="/Users/stark/Documents/mdPicture/v2-e50d6ab7222a91290374f9cec06d7da8_1440w.jpg" alt="img"></p><h4 id="action-keep"><a href="#action-keep" class="headerlink" title="action: keep"></a>action: keep</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line"><span class="attr">  scrape_interval:</span>     <span class="number">60</span><span class="string">s</span></span><br><span class="line"><span class="attr">  external_labels:</span></span><br><span class="line"><span class="attr">    monitor:</span> <span class="string">'codelab-monitor'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line"><span class="attr">  - job_name:</span> <span class="string">'node'</span></span><br><span class="line"><span class="attr">    static_configs:</span></span><br><span class="line"><span class="attr">      - targets:</span> <span class="string">["10.4.7.72:8081"]</span></span><br><span class="line"><span class="attr">        labels:</span></span><br><span class="line"><span class="attr">          app:</span> <span class="string">app-01</span></span><br><span class="line"><span class="attr">          env:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">          role:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">      - targets:</span> <span class="string">["10.4.7.72:8082"]</span></span><br><span class="line"><span class="attr">        labels:</span></span><br><span class="line"><span class="attr">          app:</span> <span class="string">app-02</span></span><br><span class="line"><span class="attr">          env:</span> <span class="string">prod</span></span><br><span class="line"><span class="attr">          role:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">      - targets:</span> <span class="string">["10.4.7.72:8083"]</span></span><br><span class="line"><span class="attr">        labels:</span></span><br><span class="line"><span class="attr">          app:</span> <span class="string">app-02</span></span><br><span class="line"><span class="attr">          env:</span> <span class="string">prod</span></span><br><span class="line"><span class="attr">          role:</span> <span class="string">slave</span></span><br><span class="line"><span class="attr">    relabel_configs:</span></span><br><span class="line"><span class="attr">      - source_labels:</span> <span class="string">["role",</span> <span class="string">"env"</span><span class="string">,</span> <span class="string">"__address__"</span><span class="string">]</span></span><br><span class="line"><span class="attr">        target_label:</span> <span class="string">host</span></span><br><span class="line"><span class="attr">        regex:</span> <span class="string">(.+);(.+);([0-9]&#123;1,3&#125;\.)&#123;3&#125;([0-9]+):[0-9]+</span> <span class="comment"># source_labels默认 ; 拼接</span></span><br><span class="line"><span class="attr">        replacement:</span> <span class="string">$1-$2-$4</span></span><br><span class="line"><span class="attr">      - source_labels:</span> <span class="string">["env"]</span>  <span class="comment"># 仅保留 env=prod 的target</span></span><br><span class="line"><span class="attr">        regex:</span> <span class="string">prod</span></span><br><span class="line"><span class="attr">        action:</span> <span class="string">keep</span></span><br></pre></td></tr></table></figure><p><img src="/Users/stark/Documents/mdPicture/v2-76caeb3f849f51aeb201d2ca4314c72e_1440w.jpg" alt="img"></p><h4 id="action-drop"><a href="#action-drop" class="headerlink" title="action: drop"></a>action: drop</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line"><span class="attr">  scrape_interval:</span>     <span class="number">60</span><span class="string">s</span></span><br><span class="line"><span class="attr">  external_labels:</span></span><br><span class="line"><span class="attr">    monitor:</span> <span class="string">'codelab-monitor'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line"><span class="attr">  - job_name:</span> <span class="string">'node'</span></span><br><span class="line"><span class="attr">    static_configs:</span></span><br><span class="line"><span class="attr">      - targets:</span> <span class="string">["10.4.7.72:8081"]</span></span><br><span class="line"><span class="attr">        labels:</span></span><br><span class="line"><span class="attr">          app:</span> <span class="string">app-01</span></span><br><span class="line"><span class="attr">          env:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">          role:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">      - targets:</span> <span class="string">["10.4.7.72:8082"]</span></span><br><span class="line"><span class="attr">        labels:</span></span><br><span class="line"><span class="attr">          app:</span> <span class="string">app-02</span></span><br><span class="line"><span class="attr">          env:</span> <span class="string">prod</span></span><br><span class="line"><span class="attr">          role:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">      - targets:</span> <span class="string">["10.4.7.72:8083"]</span></span><br><span class="line"><span class="attr">        labels:</span></span><br><span class="line"><span class="attr">          app:</span> <span class="string">app-02</span></span><br><span class="line"><span class="attr">          env:</span> <span class="string">prod</span></span><br><span class="line"><span class="attr">          role:</span> <span class="string">slave</span></span><br><span class="line"><span class="attr">    relabel_configs:</span></span><br><span class="line"><span class="attr">      - source_labels:</span> <span class="string">["role",</span> <span class="string">"env"</span><span class="string">,</span> <span class="string">"__address__"</span><span class="string">]</span></span><br><span class="line"><span class="attr">        target_label:</span> <span class="string">host</span></span><br><span class="line"><span class="attr">        regex:</span> <span class="string">(.+);(.+);([0-9]&#123;1,3&#125;\.)&#123;3&#125;([0-9]+):[0-9]+</span> <span class="comment"># source_labels默认 ; 拼接</span></span><br><span class="line"><span class="attr">        replacement:</span> <span class="string">$1-$2-$4</span></span><br><span class="line"><span class="attr">      - source_labels:</span> <span class="string">["env"]</span>  <span class="comment"># 删除 lable_name 为env，切value为prod的target</span></span><br><span class="line"><span class="attr">        regex:</span> <span class="string">prod</span></span><br><span class="line"><span class="attr">        action:</span> <span class="string">drop</span></span><br></pre></td></tr></table></figure><p><img src="/Users/stark/Documents/mdPicture/v2-fbb4a88fbc5b39703537a70c716d6eca_1440w.jpg" alt="img"></p><h4 id="action-labelkeep"><a href="#action-labelkeep" class="headerlink" title="action: labelkeep"></a>action: labelkeep</h4><p>尽量不要删除 <code>__</code> 的标签，比如删了 <code>__address__</code> 标签会导致 <code>instance</code> 生成异常，进而导致无法获取target信息</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[root@prometheus-72</span> <span class="string">prometheus]#</span> <span class="string">cat</span> <span class="string">prometheus.yml</span> </span><br><span class="line"><span class="attr">global:</span></span><br><span class="line"><span class="attr">  scrape_interval:</span>     <span class="number">60</span><span class="string">s</span></span><br><span class="line"><span class="attr">  external_labels:</span></span><br><span class="line"><span class="attr">    monitor:</span> <span class="string">'codelab-monitor'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line"><span class="attr">  - job_name:</span> <span class="string">'node'</span></span><br><span class="line"><span class="attr">    static_configs:</span></span><br><span class="line"><span class="attr">      - targets:</span> <span class="string">["10.4.7.72:8081"]</span></span><br><span class="line"><span class="attr">        labels:</span></span><br><span class="line"><span class="attr">          app:</span> <span class="string">app-01</span></span><br><span class="line"><span class="attr">          role:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">      - targets:</span> <span class="string">["10.4.7.72:8082"]</span></span><br><span class="line"><span class="attr">        labels:</span></span><br><span class="line"><span class="attr">          app:</span> <span class="string">app-02</span></span><br><span class="line"><span class="attr">          env:</span> <span class="string">prod</span></span><br><span class="line"><span class="attr">          role:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">      - targets:</span> <span class="string">["10.4.7.72:8083"]</span></span><br><span class="line"><span class="attr">        labels:</span></span><br><span class="line"><span class="attr">          app:</span> <span class="string">app-02</span></span><br><span class="line"><span class="attr">          env:</span> <span class="string">prod</span></span><br><span class="line"><span class="attr">          role:</span> <span class="string">slave</span></span><br><span class="line"><span class="attr">    relabel_configs:</span></span><br><span class="line"><span class="attr">      - regex:</span> <span class="string">(__|role).*</span> <span class="comment"># 非临时标签仅保留 role</span></span><br><span class="line"><span class="attr">        action:</span> <span class="string">labelkeep</span></span><br></pre></td></tr></table></figure><p><img src="/Users/stark/Documents/mdPicture/v2-bb66413af170d5fefb95de1b3a3b9e57_1440w.jpg" alt="img"></p><h4 id="action-labeldrop"><a href="#action-labeldrop" class="headerlink" title="action: labeldrop"></a>action: labeldrop</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line"><span class="attr">  scrape_interval:</span>     <span class="number">60</span><span class="string">s</span></span><br><span class="line"><span class="attr">  external_labels:</span></span><br><span class="line"><span class="attr">    monitor:</span> <span class="string">'codelab-monitor'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line"><span class="attr">  - job_name:</span> <span class="string">'node'</span></span><br><span class="line"><span class="attr">    static_configs:</span></span><br><span class="line"><span class="attr">      - targets:</span> <span class="string">["10.4.7.72:8081"]</span></span><br><span class="line"><span class="attr">        labels:</span></span><br><span class="line"><span class="attr">          app:</span> <span class="string">app-01</span></span><br><span class="line"><span class="attr">          role:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">      - targets:</span> <span class="string">["10.4.7.72:8082"]</span></span><br><span class="line"><span class="attr">        labels:</span></span><br><span class="line"><span class="attr">          app:</span> <span class="string">app-02</span></span><br><span class="line"><span class="attr">          env:</span> <span class="string">prod</span></span><br><span class="line"><span class="attr">          role:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">      - targets:</span> <span class="string">["10.4.7.72:8083"]</span></span><br><span class="line"><span class="attr">        labels:</span></span><br><span class="line"><span class="attr">          app:</span> <span class="string">app-02</span></span><br><span class="line"><span class="attr">          env:</span> <span class="string">prod</span></span><br><span class="line"><span class="attr">          role:</span> <span class="string">slave</span></span><br><span class="line"><span class="attr">    relabel_configs:</span></span><br><span class="line"><span class="attr">      - regex:</span> <span class="string">env</span>  <span class="comment"># 将env标签删除，并是上次target</span></span><br><span class="line"><span class="attr">        action:</span> <span class="string">labeldrop</span></span><br></pre></td></tr></table></figure><p><img src="/Users/stark/Documents/mdPicture/v2-2acf180c991f0125c96ef6cf1c0ea5f0_1440w.png" alt="img"></p><h4 id="action-labelmap"><a href="#action-labelmap" class="headerlink" title="action: labelmap"></a>action: labelmap</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line"><span class="attr">  scrape_interval:</span>     <span class="number">60</span><span class="string">s</span></span><br><span class="line"><span class="attr">  external_labels:</span></span><br><span class="line"><span class="attr">    monitor:</span> <span class="string">'codelab-monitor'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line"><span class="attr">  - job_name:</span> <span class="string">'node'</span></span><br><span class="line"><span class="attr">    static_configs:</span></span><br><span class="line"><span class="attr">      - targets:</span> <span class="string">["10.4.7.72:8081"]</span></span><br><span class="line"><span class="attr">        labels:</span></span><br><span class="line"><span class="attr">          app:</span> <span class="string">app-01</span></span><br><span class="line"><span class="attr">          role:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">      - targets:</span> <span class="string">["10.4.7.72:8082"]</span></span><br><span class="line"><span class="attr">        labels:</span></span><br><span class="line"><span class="attr">          app:</span> <span class="string">app-02</span></span><br><span class="line"><span class="attr">          env:</span> <span class="string">prod</span></span><br><span class="line"><span class="attr">          role:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">      - targets:</span> <span class="string">["10.4.7.72:8083"]</span></span><br><span class="line"><span class="attr">        labels:</span></span><br><span class="line"><span class="attr">          app:</span> <span class="string">app-02</span></span><br><span class="line"><span class="attr">          env:</span> <span class="string">prod</span></span><br><span class="line"><span class="attr">          role:</span> <span class="string">slave</span></span><br><span class="line"><span class="attr">    relabel_configs:</span></span><br><span class="line"><span class="attr">      - regex:</span> <span class="string">__(.+)__</span> <span class="comment"># 将所有双下划线的标签名改为非双下划线的标签名称</span></span><br><span class="line"><span class="attr">        action:</span> <span class="string">labelmap</span></span><br></pre></td></tr></table></figure><p><img src="/Users/stark/Documents/mdPicture/v2-ca15037ee5e370b049e832ed77c68564_1440w.jpg" alt="img"></p><h4 id="action-hashmod"><a href="#action-hashmod" class="headerlink" title="action: hashmod"></a>action: hashmod</h4><p>当一个job中监控目标数量太多时(自动发现中容易出现)，将任务分散到不同的机器上。hashmod会将 source_labels值哈希后采用 modulus 取余数，并赋值到一个标签，然后在接下来的relabel中进行保留或者剔除，这样能实现每个prometheus采集一部分target数据。下面案例中，其余后 __tmp_hash_value 值有 0、1、2，因此将target分为三组，可以由三个不同的prometheus去获取监控指标。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line"><span class="attr">  scrape_interval:</span>     <span class="number">60</span><span class="string">s</span></span><br><span class="line"><span class="attr">  external_labels:</span></span><br><span class="line"><span class="attr">    monitor:</span> <span class="string">'codelab-monitor'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line"><span class="attr">  - job_name:</span> <span class="string">'node'</span></span><br><span class="line"><span class="attr">    static_configs:</span></span><br><span class="line"><span class="attr">      - targets:</span> <span class="string">["10.4.7.72:8081"]</span></span><br><span class="line"><span class="attr">        labels:</span></span><br><span class="line"><span class="attr">          app:</span> <span class="string">app-01</span></span><br><span class="line"><span class="attr">          role:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">      - targets:</span> <span class="string">["10.4.7.72:8082"]</span></span><br><span class="line"><span class="attr">        labels:</span></span><br><span class="line"><span class="attr">          app:</span> <span class="string">app-02</span></span><br><span class="line"><span class="attr">          env:</span> <span class="string">prod</span></span><br><span class="line"><span class="attr">          role:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">      - targets:</span> <span class="string">["10.4.7.72:8083"]</span></span><br><span class="line"><span class="attr">        labels:</span></span><br><span class="line"><span class="attr">          app:</span> <span class="string">app-02</span></span><br><span class="line"><span class="attr">          env:</span> <span class="string">prod</span></span><br><span class="line"><span class="attr">          role:</span> <span class="string">slave</span></span><br><span class="line"><span class="attr">    relabel_configs:</span></span><br><span class="line"><span class="attr">      - source_labels:</span> <span class="string">["__address__"]</span></span><br><span class="line"><span class="attr">        action:</span> <span class="string">hashmod</span></span><br><span class="line"><span class="attr">        modulus:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">        target_label:</span> <span class="string">__tmp_hash_value</span></span><br><span class="line"><span class="attr">      - source_labels:</span> <span class="string">[__tmp_hash_value]</span></span><br><span class="line"><span class="attr">        regex:</span> <span class="string">"0"</span></span><br><span class="line"><span class="attr">        action:</span> <span class="string">drop</span></span><br></pre></td></tr></table></figure><p><img src="/Users/stark/Documents/mdPicture/v2-c7ac5f9c6fce85d158cce27d886d1f55_1440w.jpg" alt="img"></p><h3 id="metric-relabel-configs"><a href="#metric-relabel-configs" class="headerlink" title="metric_relabel_configs"></a>metric_relabel_configs</h3><p>Prometheus 从数据源拉取数据后，会对原始数据进行编辑</p><p>其中 <code>metric_relabel_configs</code>是 Prometheus 在保存数据前的最后一步标签重新编辑（relabel_configs）。所以，哪怕你将 <code>metric_relabel_configs</code>模块放在 <code>job_name</code>模块的最前端，Prometheus 解析编辑文件后，也会将 <code>metric_relabel_configs</code>放在最后。</p><p><code>metric_relabel_configs</code> 模块和 <code>relabel_config</code> 模块很相似。<code>metric_relabel_configs</code>一个很常用的用途：将监控不需要的数据，直接丢掉，不在Prometheus 中保存。</p><p>一般用于：</p><ol><li>删除不必要的指标。</li><li>从指标中删除敏感或不需要的标签。</li><li>添加、编辑或者修改指标的标签值或者标签格式。</li></ol><h4 id="删除不需要的指标-metric"><a href="#删除不需要的指标-metric" class="headerlink" title="删除不需要的指标(metric)"></a>删除不需要的指标(metric)</h4><p>prometheus 默认会将所有拉取到的 metrics 都写入自己的存储中。如果某些 metrics 对我们并没有太多意义，可以设置直接丢掉，减少磁盘空间的浪费。<code>‘node_netstat_Icmp_OutMsgs’</code> 指标数据。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">metric_relabel_configs:</span></span><br><span class="line"><span class="attr"> - source_labels:</span> <span class="string">[</span> <span class="string">__name__</span> <span class="string">]</span></span><br><span class="line"><span class="attr">   regex:</span> <span class="string">'node_netstat_Icmp_OutMsgs'</span></span><br><span class="line"><span class="attr">   action:</span> <span class="string">drop</span></span><br></pre></td></tr></table></figure><p>使用 <code>source_labels</code> 参数选择要要操作的指标，并且还需要一组标签名称。<br>示例中使用 <code>__name__</code> 标签，此标签是标识指标名称的预留标签。</p><p>如上，我们丢掉指定<code>job_name</code>中的</p><p>参考上面的配置，我们可以对指标(metric) 进行添加，删除，重命名等操作。</p><h4 id="修改指标-metric-中的标签-label"><a href="#修改指标-metric-中的标签-label" class="headerlink" title="修改指标(metric) 中的标签(label)"></a>修改指标(metric) 中的标签(label)</h4><p>如果我们使用 prometheus 监控 Kubernetes 运行状态；应该会遇到，在一个 <code>query</code> 中结合一个以上的<code>job_name(metric_source)</code>的情况。<br>不同的<code>job_name</code>中<code>metric</code>的<code>label</code>命名可能不相同。比如：pod的名称可以使用“pod”或者“pod_name” 这两个 <code>label</code>记录。如果相同含义的label，名称却不相同；对query的编写就很困难了。至少我没有在<code>PromQL</code>中找到类似<code>SQL 语句中的 as 的功能的关键词和方法</code>。<br>这样的话，正确的解决思路应该是在 Prometheus 拉取数据后，保存数据前；将 label 的名称进行重写；保证相同含义的label 有相同的名称。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">metric_relabel_configs:</span></span><br><span class="line"><span class="attr">  - source_labels:</span> <span class="string">[pod]</span></span><br><span class="line"><span class="attr">    separator:</span> <span class="string">;</span></span><br><span class="line"><span class="attr">    regex:</span> <span class="string">(.+)</span></span><br><span class="line"><span class="attr">    target_label:</span> <span class="string">pod_name</span></span><br><span class="line"><span class="attr">    replacement:</span> <span class="string">$1</span></span><br><span class="line"><span class="attr">    action:</span> <span class="string">replace</span></span><br><span class="line"><span class="attr">  - source_labels:</span> <span class="string">[container]</span></span><br><span class="line"><span class="attr">    separator:</span> <span class="string">;</span></span><br><span class="line"><span class="attr">    regex:</span> <span class="string">(.+)</span></span><br><span class="line"><span class="attr">    target_label:</span> <span class="string">container_name</span></span><br><span class="line"><span class="attr">    replacement:</span> <span class="string">$1</span></span><br><span class="line"><span class="attr">    action:</span> <span class="string">replace</span></span><br></pre></td></tr></table></figure><p>如上，将指定<code>job_name</code>中，所有的<code>metrics</code>中含有名为“pod”和“container”名称的<code>label</code>分别拷贝到名为“pod_name”，“container_name”的label中。<br>注意：如果metric 的 label的名称包含了“pod”和“container”关键词，但是不等于；则不会处理此label。</p><h4 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h4><p>删除标签通常用于隐藏敏感信息或者简化时间序列。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">metric_relabel_configs:</span></span><br><span class="line"><span class="attr">- regex:</span> <span class="string">'kernelVersion'</span></span><br><span class="line"><span class="attr">  action:</span> <span class="string">labeldrop</span></span><br></pre></td></tr></table></figure><p>为了删除标签，我们指定了一个正则表达式，然后指定删除标签的操作labeldrop。<br>这将删除与正在表达式匹配的所有标签。</p><h3 id="remote-write"><a href="#remote-write" class="headerlink" title="remote_write"></a>remote_write</h3><p><code>write_relabel_configs</code>是在将样本发送到远程端点之前应用于样本的重新标记。 在外部标签之后应用写入重新标记。 这可用于限制发送的样本。</p><p>有一个如何使用此功能的小型<a href="https://github.com/prometheus/prometheus/tree/release-2.8/documentation/examples/remote_storage" target="_blank" rel="external">演示</a>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 要发送样本的端点的URL.</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对远程写端点的请求超时。</span></span><br><span class="line"><span class="string">[</span> <span class="attr">remote_timeout:</span> <span class="string">&lt;duration&gt;</span> <span class="string">| default = 30s ]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 远程写入重新标记配置列表。</span></span><br><span class="line"><span class="string"></span><span class="attr">write_relabel_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;relabel_config&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用配置的用户名和密码在每个远程写请求上设置`Authorization`标头.password和password_file是互斥的。</span></span><br><span class="line"><span class="attr">basic_auth:</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">username:</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">password:</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">password_file:</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用配置的承载令牌在每个远程写请求上设置`Authorization`头。 它与`bearer_token_file`互斥。</span></span><br><span class="line"><span class="string">[</span> <span class="attr">bearer_token:</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用配置的承载令牌在每个远程写请求上设置`Authorization`头。 它与`bearer_token`互斥。</span></span><br><span class="line"><span class="string">[</span> <span class="attr">bearer_token_file:</span> <span class="string">/path/to/bearer/token/file</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置远程写入请求的TLS设置。</span></span><br><span class="line"><span class="attr">tls_config:</span></span><br><span class="line">  <span class="string">[</span> <span class="string">&lt;tls_config&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选的代理URL。</span></span><br><span class="line"><span class="string">[</span> <span class="attr">proxy_url:</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置用于写入远程存储的队列。</span></span><br><span class="line"><span class="attr">queue_config:</span></span><br><span class="line">  <span class="comment"># 在我们开始删除之前每个分片缓冲的样本数。</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">capacity:</span> <span class="string">&lt;int&gt;</span> <span class="string">| default = 10000 ]</span></span><br><span class="line"><span class="string">  # 最大分片数，即并发数。</span></span><br><span class="line"><span class="string">  [ max_shards: &lt;int&gt; | default = 1000 ]</span></span><br><span class="line"><span class="string">  # 最小分片数，即并发数。</span></span><br><span class="line"><span class="string">  [ min_shards: &lt;int&gt; | default = 1 ]</span></span><br><span class="line"><span class="string">  # 每次发送的最大样本数。</span></span><br><span class="line"><span class="string">  [ max_samples_per_send: &lt;int&gt; | default = 100]</span></span><br><span class="line"><span class="string">  # 样本在缓冲区中等待的最长时间。</span></span><br><span class="line"><span class="string">  [ batch_send_deadline: &lt;duration&gt; | default = 5s ]</span></span><br><span class="line"><span class="string">  # 在可恢复错误上重试批处理的最大次数。</span></span><br><span class="line"><span class="string">  [ max_retries: &lt;int&gt; | default = 3 ]</span></span><br><span class="line"><span class="string">  # 初始重试延迟。 每次重试都会加倍。</span></span><br><span class="line"><span class="string">  [ min_backoff: &lt;duration&gt; | default = 30ms ]</span></span><br><span class="line"><span class="string">  # 最大重试延迟。</span></span><br><span class="line"><span class="string">  [ max_backoff: &lt;duration&gt; | default = 100ms ]</span></span><br></pre></td></tr></table></figure><p>有一个与此功能<a href="https://prometheus.io/docs/operating/integrations/#remote-endpoints-and-storage" target="_blank" rel="external">集成</a>的列表。</p><h3 id="remote-read"><a href="#remote-read" class="headerlink" title="remote_read"></a>remote_read</h3><p>prometheus 可以从远程存储读取时间序列数据</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 要发送样本的端点的URL.</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选的匹配器列表，必须存在于选择器中以查询远程读取端点。</span></span><br><span class="line"><span class="attr">required_matchers:</span></span><br><span class="line">  <span class="string">[</span> <span class="string">&lt;labelname&gt;:</span> <span class="string">&lt;labelvalue&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对远程读取端点的请求超时。</span></span><br><span class="line"><span class="string">[</span> <span class="attr">remote_timeout:</span> <span class="string">&lt;duration&gt;</span> <span class="string">| default = 1m ]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 本地存储应该有完整的数据。</span></span><br><span class="line"><span class="string">[ read_recent: &lt;boolean&gt; | default = false ]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 使用配置的用户名和密码在每个远程写请求上设置`Authorization`标头.password和password_file是互斥的。</span></span><br><span class="line"><span class="string"></span><span class="attr">basic_auth:</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">username:</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">password:</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span></span><br><span class="line">  <span class="string">[</span> <span class="attr">password_file:</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用配置的承载令牌在每个远程写请求上设置`Authorization`头。 它与`bearer_toke_filen`互斥。</span></span><br><span class="line"><span class="string">[</span> <span class="attr">bearer_token:</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用配置的承载令牌在每个远程写请求上设置`Authorization`头。 它与`bearer_token`互斥。</span></span><br><span class="line"><span class="string">[</span> <span class="attr">bearer_token_file:</span> <span class="string">/path/to/bearer/token/file</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置远程写入请求的TLS设置。</span></span><br><span class="line"><span class="attr">tls_config:</span></span><br><span class="line">  <span class="string">[</span> <span class="string">&lt;tls_config&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选的代理URL。</span></span><br><span class="line"><span class="string">[</span> <span class="attr">proxy_url:</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span></span><br></pre></td></tr></table></figure><p>有一个与此功能<a href="https://prometheus.io/docs/operating/integrations/#remote-endpoints-and-storage" target="_blank" rel="external">集成</a>的列表。</p><h1 id="其他监控工具"><a href="#其他监控工具" class="headerlink" title="其他监控工具"></a>其他监控工具</h1><p>在前言中，简单介绍了我们选择 Prometheus 的理由，以及使用后给我们带来的好处。</p><p>在这里主要和其他监控方案对比，方便大家更好的了解 Prometheus。</p><h2 id="Prometheus-vs-Zabbix"><a href="#Prometheus-vs-Zabbix" class="headerlink" title="Prometheus vs Zabbix"></a>Prometheus vs Zabbix</h2><ul><li>Zabbix 使用的是 C 和 PHP, Prometheus 使用 Golang, 整体而言 Prometheus 运行速度更快一点。</li><li>Zabbix 属于传统主机监控，主要用于物理主机，交换机，网络等监控，Prometheus 不仅适用主机监控，还适用于 Cloud, SaaS, Openstack，Container 监控。</li><li>Zabbix 在传统主机监控方面，有更丰富的插件。</li><li>Zabbix 可以在 WebGui 中配置很多事情，但是 Prometheus 需要手动修改文件配置。</li></ul><h2 id="Prometheus-vs-Graphite"><a href="#Prometheus-vs-Graphite" class="headerlink" title="Prometheus vs Graphite"></a>Prometheus vs Graphite</h2><ul><li><a href="http://graphite.readthedocs.io/en/latest/overview.html" target="_blank" rel="external">Graphite</a> 功能较少，它专注于两件事，存储时序数据， 可视化数据，其他功能需要安装相关插件，而 Prometheus 属于一站式，提供告警和趋势分析的常见功能，它提供更强的数据存储和查询能力。</li><li>在水平扩展方案以及数据存储周期上，Graphite 做的更好。</li></ul><h2 id="Prometheus-vs-InfluxDB"><a href="#Prometheus-vs-InfluxDB" class="headerlink" title="Prometheus vs InfluxDB"></a>Prometheus vs InfluxDB</h2><ul><li><a href="https://www.influxdata.com/" target="_blank" rel="external">InfluxDB</a> 是一个开源的时序数据库，主要用于存储数据，如果想搭建监控告警系统， 需要依赖其他系统。</li><li>InfluxDB 在存储水平扩展以及高可用方面做的更好, 毕竟核心是数据库。</li></ul><h2 id="Prometheus-vs-OpenTSDB"><a href="#Prometheus-vs-OpenTSDB" class="headerlink" title="Prometheus vs OpenTSDB"></a>Prometheus vs OpenTSDB</h2><ul><li><a href="http://opentsdb.net/" target="_blank" rel="external">OpenTSDB</a> 是一个分布式时序数据库，它依赖 Hadoop 和 HBase，能存储更长久数据， 如果你系统已经运行了 Hadoop 和 HBase, 它是个不错的选择。</li><li>如果想搭建监控告警系统，OpenTSDB 需要依赖其他系统。</li></ul><h2 id="Prometheus-vs-Nagios"><a href="#Prometheus-vs-Nagios" class="headerlink" title="Prometheus vs Nagios"></a>Prometheus vs Nagios</h2><ul><li><a href="https://www.nagios.org/" target="_blank" rel="external">Nagios</a> 数据不支持自定义 Labels, 不支持查询，告警也不支持去噪，分组, 没有数据存储，如果想查询历史状态，需要安装插件。</li><li>Nagios 是上世纪 90 年代的监控系统，比较适合小集群或静态系统的监控，显然 Nagios 太古老了，很多特性都没有，相比之下Prometheus 要优秀很多。</li></ul><h2 id="Prometheus-vs-Sensu"><a href="#Prometheus-vs-Sensu" class="headerlink" title="Prometheus vs Sensu"></a>Prometheus vs Sensu</h2><ul><li><a href="https://sensuapp.org/" target="_blank" rel="external">Sensu</a> 广义上讲是 Nagios 的升级版本，它解决了很多 Nagios 的问题，如果你对 Nagios 很熟悉，使用 Sensu 是个不错的选择。</li><li>Sensu 依赖 RabbitMQ 和 Redis，数据存储上扩展性更好。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Prometheus 属于一站式监控告警平台，依赖少，功能齐全。</li><li>Prometheus 支持对云或容器的监控，其他系统主要对主机监控。</li><li>Prometheus 数据查询语句表现力更强大，内置更强大的统计函数。</li><li>Prometheus 在数据存储扩展性以及持久性上没有 InfluxDB，OpenTSDB，Sensu 好。</li></ul><p>参考：</p><p><a href="https://blog.51cto.com/wzlinux/2487300" target="_blank" rel="external">prometheus 监控概述(一)</a></p><p><a href="https://zhuanlan.zhihu.com/p/269882810" target="_blank" rel="external">prometheus 配置文件</a></p><p><a href="https://blog.csdn.net/qq_21816375/article/details/80193426?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.baidujs&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.baidujs" target="_blank" rel="external">prometheus之配置详解</a></p><p><a href="https://blog.csdn.net/Coffin_monkey/article/details/90572867?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-8&amp;spm=1001.2101.3001.4242" target="_blank" rel="external">Prometheus学习系列（十三）之配置解析</a></p><p><a href="https://blog.51cto.com/wzlinux/2498087" target="_blank" rel="external">prometheus relabel 配置</a></p><p><a href="https://blog.csdn.net/qq_34556414/article/details/113544575" target="_blank" rel="external">Prometheus 配置文件中 metric_relabel_configs 配置</a></p><p><a href="https://blog.csdn.net/u013616005/article/details/107326169?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.baidujs&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.baidujs" target="_blank" rel="external">prometheus配置看着一篇就够了</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p id=&quot;div-border-top-green&quot;&gt;与其每天担心未来，不如努力现在。别对自己丧失信心，成长的路上，只有奋斗才能给你最大的安全感。&lt;br&gt;&lt;/p&gt;

&lt;h1 id=&quot;Prometheus-简介&quot;&gt;&lt;a href=&quot;#Prometheus-简介&quot; class=&quot;headerlink&quot; title=&quot;Prometheus 简介&quot;&gt;&lt;/a&gt;Prometheus 简介&lt;/h1&gt;&lt;h2 id=&quot;Prometheus-是啥&quot;&gt;&lt;a href=&quot;#Prometheus-是啥&quot; class=&quot;headerlink&quot; title=&quot;Prometheus 是啥&quot;&gt;&lt;/a&gt;Prometheus 是啥&lt;/h2&gt;&lt;p&gt;Prometheus 是一套开源的系统监控报警框架。它启发于 Google 的 borgmon 监控系统，由工作在 SoundCloud 的 google 前员工在 2012 年创建，作为社区开源项目进行开发，并于 2015 年正式发布。2016 年，Prometheus 正式加入 Cloud Native Computing Foundation，成为受欢迎度仅次于 Kubernetes 的项目。&lt;/p&gt;
    
    </summary>
    
      <category term="Prometheus" scheme="https://magiceses.github.io/categories/Prometheus/"/>
    
    
      <category term="Prometheus" scheme="https://magiceses.github.io/tags/Prometheus/"/>
    
  </entry>
  
  <entry>
    <title>Pecan 框架使用及源码分析</title>
    <link href="https://magiceses.github.io/2020/06/10/python-web-pecan%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://magiceses.github.io/2020/06/10/python-web-pecan框架使用及源码分析/</id>
    <published>2020-06-09T21:25:24.000Z</published>
    <updated>2021-10-01T01:23:08.194Z</updated>
    
    <content type="html"><![CDATA[<p id="div-border-top-green">别人怎样去看待你的价值并不重要，重要是你自己怎样看待自身的价值。即便你是一块货真价实的金子，多说己长也便是短，自知己短便是长。一个人的真正伟大之处，就在于能认识到自己的渺小。<br></p><p><code>Pecan</code>框架的目标是实现一个采用对象分发方式进行<code>URL</code>路由的轻量级<code>Web</code>框架。它非常专注于自己的目标，它的大部分功能都和<code>URL</code>路</p><p>由以及请求和响应的处理相关，而不去实现模板、安全以及数据库层，这些东西都可以通过其他的库来实现。关于<code>Pecan</code>的更多信息，可</p><p>以 <a href="https://pecan.readthedocs.org/en/latest/index.html" target="_blank" rel="external">查看文档</a></p><a id="more"></a><h1 id="pecan-工程创建"><a href="#pecan-工程创建" class="headerlink" title="pecan 工程创建"></a>pecan 工程创建</h1><h2 id="pecan源码目录"><a href="#pecan源码目录" class="headerlink" title="pecan源码目录"></a>pecan源码目录</h2><p><img src="/images/python-web-pecan-1.png" alt="在这里插入图片描述"></p><h2 id="创建-pecan-工程"><a href="#创建-pecan-工程" class="headerlink" title="创建 pecan 工程"></a>创建 pecan 工程</h2><h3 id="一般工程"><a href="#一般工程" class="headerlink" title="一般工程"></a>一般工程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pecan create <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>创建pecan工程用到了bin下的pecan脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// bin/pecan</span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">from</span> pecan.commands <span class="keyword">import</span> CommandRunner</span><br><span class="line">    CommandRunner.handle_command_line()</span><br></pre></td></tr></table></figure><p>调用了pecan/commands/base.py下的CommandRunner类中的handle_command_line()方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 具体处理命令</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, args)</span>:</span></span><br><span class="line">    ns = self.parser.parse_args(args) <span class="comment"># 解析参数</span></span><br><span class="line">    self.commands[ns.command_name]().run(ns) <span class="comment"># 执行命令，相当于执行commands下相应模块中的run方法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_command_line</span><span class="params">(cls)</span>:</span></span><br><span class="line">    runner = CommandRunner() <span class="comment"># 实例化该对象时，加载commands文件夹下定义的名命令</span></span><br><span class="line">    runner.run(sys.argv[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pecan/commands/base.py</span></span><br><span class="line"><span class="comment"># 加载command的方法，entry point在setup.py里面注册了</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_commands</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> ep <span class="keyword">in</span> pkg_resources.iter_entry_points(<span class="string">'pecan.command'</span>):</span><br><span class="line">        log.debug(<span class="string">'%s loading plugin %s'</span>, self.__class__.__name__, ep)</span><br><span class="line">        <span class="keyword">if</span> ep.name <span class="keyword">in</span> self.commands:</span><br><span class="line">            warn(</span><br><span class="line">                <span class="string">"Duplicate entry points found on `%s` - ignoring %s"</span> % (</span><br><span class="line">                    ep.name,</span><br><span class="line">                    ep</span><br><span class="line">                ),</span><br><span class="line">                RuntimeWarning</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">          <span class="comment"># 该方法是去加载模块中含有run方法的类</span></span><br><span class="line">            cmd = ep.load()</span><br><span class="line">            cmd.run  <span class="comment"># 确保加载的类有run方法</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:  <span class="comment"># pragma: nocover</span></span><br><span class="line">            warn(<span class="string">"Unable to load plugin %s: %s"</span> % (ep, e), RuntimeWarning)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        self.add(&#123;ep.name: cmd&#125;) <span class="comment"># 添加到self.commands字典里面，上面的run运行时，从字典中取出类，实例化，然后调用run方法</span></span><br></pre></td></tr></table></figure><p>可以看到，pecan创建工程的过程和django类似（其实基本所有的python web框架都是一样的）</p><p>下面来看看创建工程具体做了什么工作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  pecan/commands/create.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScaffoldManager</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.scaffolds = &#123;&#125;</span><br><span class="line">        self.load_scaffolds()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">load_scaffolds</span><span class="params">(self)</span>:</span></span><br><span class="line">      <span class="comment"># 加载在setup.py文件中注册了的类</span></span><br><span class="line">        <span class="keyword">for</span> ep <span class="keyword">in</span> pkg_resources.iter_entry_points(<span class="string">'pecan.scaffold'</span>):</span><br><span class="line">            log.debug(<span class="string">'%s loading scaffold %s'</span>, self.__class__.__name__, ep)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                cmd = ep.load()</span><br><span class="line">                cmd.copy_to<span class="comment"># 确保有copy_to方法</span></span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:  <span class="comment"># pragma: nocover</span></span><br><span class="line">                warn(</span><br><span class="line">                    <span class="string">"Unable to load scaffold %s: %s"</span> % (ep, e), RuntimeWarning</span><br><span class="line">                )</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            self.add(&#123;ep.name: cmd&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, cmd)</span>:</span></span><br><span class="line">        self.scaffolds.update(cmd)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateCommand</span><span class="params">(BaseCommand)</span>:</span></span><br><span class="line">  <span class="comment"># 通过实例化该对象，加载pecan/scaffolds下的BaseScaffold和RestAPIScaffold类，加载方法和加载command方法一样</span></span><br><span class="line">    manager = ScaffoldManager()</span><br><span class="line">    arguments = (&#123;</span><br><span class="line">        <span class="string">'name'</span>: <span class="string">'project_name'</span>,</span><br><span class="line">        <span class="string">'help'</span>: <span class="string">'the (package) name of the new project'</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="string">'name'</span>: <span class="string">'template_name'</span>,</span><br><span class="line">        <span class="string">'metavar'</span>: <span class="string">'template_name'</span>,</span><br><span class="line">        <span class="string">'help'</span>: <span class="string">'a registered Pecan template'</span>,</span><br><span class="line">        <span class="string">'nargs'</span>: <span class="string">'?'</span>,</span><br><span class="line">        <span class="string">'default'</span>: DEFAULT_SCAFFOLD, <span class="comment"># 值为base，会调用BaseScaffold的实例</span></span><br><span class="line">        <span class="string">'choices'</span>: manager.scaffolds.keys()</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment"># 该方法会首先执行</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, args)</span>:</span></span><br><span class="line">        super(CreateCommand, self).run(args)</span><br><span class="line">        <span class="comment">#  self.manager.scaffolds为&#123;'rest-api': &lt;class 'pecan.scaffolds.RestAPIScaffold'&gt;, 'base': &lt;class 'pecan.scaffolds.BaseScaffold'&gt;&#125;</span></span><br><span class="line">        <span class="comment"># 具体由RestAPIScaffold和BaseScaffold去创建工程</span></span><br><span class="line">        self.manager.scaffolds[args.template_name]().copy_to(</span><br><span class="line">            args.project_name<span class="comment"># 项目名：test</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure><blockquote><p>注：通过上面的代码可以知道，默认创建工程时使用的是BaseScaffold类，创建的是一般的pecan工程，而要创建restful的pecan工程，则需要使用下面的方式创建</p></blockquote><h3 id="Restful工程"><a href="#Restful工程" class="headerlink" title="Restful工程"></a>Restful工程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pecan create <span class="built_in">test</span> rest-api</span><br></pre></td></tr></table></figure><p>BaseScaffold和RestAPIScaffold调用copy_to(project_name)方法去创建工程，主要工作就是根据传入的项目名创建目录，拷贝文件等，pecan/scaffolds模块中放置了相关的模板文件</p><p><img src="/images/python-web-pecan-2.png" alt="在这里插入图片描述"></p><p>至此，一个pecan工程就创建完毕。</p><h2 id="运行-pecan-工程"><a href="#运行-pecan-工程" class="headerlink" title="运行 pecan 工程"></a>运行 pecan 工程</h2><p>运行方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pecan serve config.py</span><br></pre></td></tr></table></figure><p>和创建工程一样，运行时调用了pecan/commands/create.py模块的方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, args)</span>:</span></span><br><span class="line">    super(ServeCommand, self).run(args)</span><br><span class="line">    app = self.load_app() <span class="comment"># 创建一个app</span></span><br><span class="line">    self.serve(app, app.config) <span class="comment"># 部署app</span></span><br></pre></td></tr></table></figure><p>众所周知，要运行一个python的web服务，需要两个条件：</p><ul><li>application</li><li>wsgi server</li></ul><p>上面的load_app()方法创建了一个application（会调用到core.py里面的load_app()方法）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pecan/core.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_app</span><span class="params">(config, **kwargs)</span>:</span></span><br><span class="line">    <span class="keyword">from</span> .configuration <span class="keyword">import</span> _runtime_conf, set_config</span><br><span class="line">    <span class="comment"># 根据配置文件初始化配置</span></span><br><span class="line">    set_config(config, overwrite=<span class="keyword">True</span>)</span><br><span class="line">    <span class="keyword">for</span> package_name <span class="keyword">in</span> getattr(_runtime_conf.app, <span class="string">'modules'</span>, []):</span><br><span class="line">        module = __import__(package_name, fromlist=[<span class="string">'app'</span>])</span><br><span class="line">        <span class="comment"># 项目工程创建好后，有个test/test/app.py文件，里面的setup_app(config)具体来创建app</span></span><br><span class="line">        <span class="keyword">if</span> hasattr(module, <span class="string">'app'</span>) <span class="keyword">and</span> hasattr(module.app, <span class="string">'setup_app'</span>):</span><br><span class="line">          <span class="comment"># 这里开始创建一个app</span></span><br><span class="line">            app = module.app.setup_app(_runtime_conf, **kwargs)</span><br><span class="line">            app.config = _runtime_conf</span><br><span class="line">            <span class="keyword">return</span> app</span><br><span class="line">    <span class="keyword">raise</span> RuntimeError(</span><br><span class="line">        <span class="string">'No app.setup_app found in any of the configured app.modules'</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="comment"># test/test/app.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setup_app</span><span class="params">(config)</span>:</span></span><br><span class="line">    model.init_model()<span class="comment"># 创建app时，初始化model，一般在这实现orm映射</span></span><br><span class="line">    app_conf = dict(config.app)</span><br><span class="line">    <span class="comment"># test/conifg.py文件中有app配置项，定义了app的重要内容</span></span><br><span class="line">    <span class="keyword">return</span> make_app(</span><br><span class="line">        app_conf.pop(<span class="string">'root'</span>),</span><br><span class="line">        logging=getattr(config, <span class="string">'logging'</span>, &#123;&#125;),</span><br><span class="line">        **app_conf</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="comment"># pecan/__init__.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_app</span><span class="params">(root, **kw)</span>:</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment"># root是test/config.py中app项里面配置的，作为路由的入口</span></span><br><span class="line">    app = Pecan(root, **kw)</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">return</span> app</span><br></pre></td></tr></table></figure><p>app其实就是一个Pecan实例。</p><p>对于wsgi server，下面的代码可以看出，pecan使用了python内置的simple_server</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pecan/commands/serve.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">serve</span><span class="params">(self, app, conf)</span>:</span></span><br><span class="line">      <span class="keyword">if</span> self.args.reload:</span><br><span class="line">          <span class="keyword">try</span>:</span><br><span class="line">          <span class="comment"># 使用了watchdog，用于修改文件后自动部署（暂不做讲解）</span></span><br><span class="line">              self.watch_and_spawn(conf)</span><br><span class="line">          <span class="keyword">except</span> ImportError:</span><br><span class="line">              print(<span class="string">'The `--reload` option requires `watchdog` to be '</span></span><br><span class="line">                    <span class="string">'installed.'</span>)</span><br><span class="line">              print(<span class="string">'   $ pip install watchdog'</span>)</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">      <span class="comment"># 这里就是具体部署app的方法</span></span><br><span class="line">          self._serve(app, conf)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_serve</span><span class="params">(self, app, conf)</span>:</span></span><br><span class="line"><span class="comment"># 引入python内置simple_server </span></span><br><span class="line">   <span class="keyword">from</span> wsgiref.simple_server <span class="keyword">import</span> make_server</span><br><span class="line">   host, port = conf.server.host, int(conf.server.port)</span><br><span class="line">   srv = make_server(</span><br><span class="line">       host,</span><br><span class="line">       port,</span><br><span class="line">       app, <span class="comment"># 创建的app</span></span><br><span class="line">       handler_class=PecanWSGIRequestHandler, <span class="comment"># 处理器</span></span><br><span class="line">   )</span><br><span class="line">   print(<span class="string">'Starting server in PID %s'</span> % os.getpid())</span><br><span class="line">   <span class="keyword">if</span> host == <span class="string">'0.0.0.0'</span>:</span><br><span class="line">       print(</span><br><span class="line">           <span class="string">'serving on 0.0.0.0:%s, view at http://127.0.0.1:%s'</span> %</span><br><span class="line">           (port, port)</span><br><span class="line">       )</span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">       print(<span class="string">"serving on http://%s:%s"</span> % (host, port))</span><br><span class="line">   <span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 运行web服务</span></span><br><span class="line">       srv.serve_forever()</span><br><span class="line">   <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">       <span class="comment"># allow CTRL+C to shutdown</span></span><br><span class="line">       <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>至此，一个python web服务就运行起来了。</p><h1 id="pecan-源码解析"><a href="#pecan-源码解析" class="headerlink" title="pecan 源码解析"></a>pecan 源码解析</h1><p>新建pecan工程的默认config.py文件（上面讲过，该文件是从scaffolds中的模板copy的）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Server Specific Configurations</span></span><br><span class="line"><span class="comment"># 启动的默认的host和port</span></span><br><span class="line">server = &#123;</span><br><span class="line">    <span class="string">'port'</span>: <span class="string">'8080'</span>,</span><br><span class="line">    <span class="string">'host'</span>: <span class="string">'0.0.0.0'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pecan Application Configurations</span></span><br><span class="line"><span class="comment"># app的配置</span></span><br><span class="line">app = &#123;</span><br><span class="line">    <span class="string">'root'</span>: <span class="string">'$&#123;package&#125;.controllers.root.RootController'</span>, <span class="comment"># root项很重要，指定开始路由的处理器</span></span><br><span class="line">    <span class="string">'modules'</span>: [<span class="string">'$&#123;package&#125;'</span>],</span><br><span class="line">    <span class="string">'debug'</span>: <span class="keyword">True</span></span><br><span class="line">  <span class="comment"># 还可以配置 static_root、template_path、errors 等。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># python格式的日志配置</span></span><br><span class="line">logging = &#123;</span><br><span class="line">    <span class="string">'root'</span>: &#123;<span class="string">'level'</span>: <span class="string">'INFO'</span>, <span class="string">'handlers'</span>: [<span class="string">'console'</span>]&#125;,</span><br><span class="line">    <span class="string">'loggers'</span>: &#123;</span><br><span class="line">        <span class="string">'$&#123;package&#125;'</span>: &#123;<span class="string">'level'</span>: <span class="string">'DEBUG'</span>, <span class="string">'handlers'</span>: [<span class="string">'console'</span>], <span class="string">'propagate'</span>: <span class="keyword">False</span>&#125;,</span><br><span class="line">        <span class="string">'pecan'</span>: &#123;<span class="string">'level'</span>: <span class="string">'DEBUG'</span>, <span class="string">'handlers'</span>: [<span class="string">'console'</span>], <span class="string">'propagate'</span>: <span class="keyword">False</span>&#125;,</span><br><span class="line">        <span class="string">'py.warnings'</span>: &#123;<span class="string">'handlers'</span>: [<span class="string">'console'</span>]&#125;,</span><br><span class="line">        <span class="string">'__force_dict__'</span>: <span class="keyword">True</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'handlers'</span>: &#123;</span><br><span class="line">        <span class="string">'console'</span>: &#123;</span><br><span class="line">            <span class="string">'level'</span>: <span class="string">'DEBUG'</span>,</span><br><span class="line">            <span class="string">'class'</span>: <span class="string">'logging.StreamHandler'</span>,</span><br><span class="line">            <span class="string">'formatter'</span>: <span class="string">'color'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'formatters'</span>: &#123;</span><br><span class="line">        <span class="string">'simple'</span>: &#123;</span><br><span class="line">            <span class="string">'format'</span>: (<span class="string">'%(asctime)s %(levelname)-5.5s [%(name)s]'</span></span><br><span class="line">                       <span class="string">'[%(threadName)s] %(message)s'</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'color'</span>: &#123;</span><br><span class="line">            <span class="string">'()'</span>: <span class="string">'pecan.log.ColorFormatter'</span>,</span><br><span class="line">            <span class="string">'format'</span>: (<span class="string">'%(asctime)s [%(padded_color_levelname)s] [%(name)s]'</span></span><br><span class="line">                       <span class="string">'[%(threadName)s] %(message)s'</span>),</span><br><span class="line">        <span class="string">'__force_dict__'</span>: <span class="keyword">True</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Custom Configurations must be in Python dictionary format::</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># foo = &#123;'bar':'baz'&#125;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># All configurations are accessible at::</span></span><br><span class="line"><span class="comment"># pecan.conf</span></span><br></pre></td></tr></table></figure><h2 id="路由分析"><a href="#路由分析" class="headerlink" title="路由分析"></a>路由分析</h2><p>app是一个Pecan实例，先来看看初始化Pecan实例时做了哪些工作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># core.py文件</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pecan</span><span class="params">(PecanBase)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">     <span class="keyword">if</span> kw.get(<span class="string">'use_context_locals'</span>) <span class="keyword">is</span> <span class="keyword">False</span>:</span><br><span class="line">         self = super(Pecan, cls).__new__(ExplicitPecan, *args, **kw)</span><br><span class="line">         self.__init__(*args, **kw)</span><br><span class="line">         <span class="keyword">return</span> self</span><br><span class="line">     <span class="keyword">return</span> super(Pecan, cls).__new__(cls)</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kw)</span>:</span></span><br><span class="line">     self.init_context_local(kw.get(<span class="string">'context_local_factory'</span>))</span><br><span class="line">     <span class="comment"># 调用了PecanBase的初始化方法</span></span><br><span class="line">     super(Pecan, self).__init__(*args, **kw)</span><br><span class="line"> </span><br><span class="line"> ......</span><br><span class="line"> ......</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PecanBase</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, root, default_renderer=<span class="string">'mako'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 template_path=<span class="string">'templates'</span>, hooks=lambda: [],</span></span></span><br><span class="line"><span class="function"><span class="params">                 custom_renderers=&#123;&#125;, extra_template_vars=&#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">                 force_canonical=True, guess_content_type_from_ext=True,</span></span></span><br><span class="line"><span class="function"><span class="params">                 context_local_factory=None, request_cls=Request,</span></span></span><br><span class="line"><span class="function"><span class="params">                 response_cls=Response, **kw)</span>:</span></span><br><span class="line">        <span class="comment"># 这里将配置文件中的root配置项导入为一个python对象</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(root, six.string_types):</span><br><span class="line">            root = self.__translate_root__(root)</span><br><span class="line">        self.root = root <span class="comment"># url中的路径，比如：/v1/books</span></span><br><span class="line">        self.request_cls = request_cls <span class="comment"># webob的Request类，所以pecan以来WebOb</span></span><br><span class="line">        self.response_cls = response_cls <span class="comment"># webob的Response类</span></span><br><span class="line">        self.renderers = RendererFactory(custom_renderers, extra_template_vars) <span class="comment"># 渲染器</span></span><br><span class="line">        self.default_renderer = default_renderer</span><br><span class="line">        <span class="comment"># 初始化钩子程序</span></span><br><span class="line">        <span class="keyword">if</span> six.callable(hooks):</span><br><span class="line">            hooks = hooks()</span><br><span class="line">        self.hooks = list(sorted(</span><br><span class="line">            hooks,</span><br><span class="line">            key=operator.attrgetter(<span class="string">'priority'</span>)</span><br><span class="line">        ))</span><br><span class="line">        self.template_path = template_path</span><br><span class="line">        self.force_canonical = force_canonical</span><br><span class="line">        self.guess_content_type_from_ext = guess_content_type_from_ext</span><br></pre></td></tr></table></figure><p>在core.py中定义了一个全局变量state，它的生命周期和整个请求的生命周期一致，保存了请求过程中各种参数状态值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state = <span class="keyword">None</span></span><br></pre></td></tr></table></figure><p>当一个请求从wsgiserver转发过来，首先处理的是Pecan中的<strong>call</strong>方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># core.py文件</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pecan</span><span class="params">(PecanBase)</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, environ, start_response)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            state.hooks = []</span><br><span class="line">            state.app = self</span><br><span class="line">            state.controller = <span class="keyword">None</span></span><br><span class="line">            state.arguments = <span class="keyword">None</span></span><br><span class="line">            <span class="comment"># 调用了PecanBase的__call__方法</span></span><br><span class="line">            <span class="keyword">return</span> super(Pecan, self).__call__(environ, start_response)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="keyword">del</span> state.hooks <span class="comment"># 存储钩子程序的list</span></span><br><span class="line">            <span class="keyword">del</span> state.request <span class="comment"># 请求对象</span></span><br><span class="line">            <span class="keyword">del</span> state.response <span class="comment"># 响应对象</span></span><br><span class="line">            <span class="keyword">del</span> state.controller <span class="comment"># 处理器（程序中被expose装饰的方法）</span></span><br><span class="line">            <span class="keyword">del</span> state.arguments <span class="comment"># 参数</span></span><br><span class="line">            <span class="keyword">del</span> state.app <span class="comment"># Peacn对象</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PecanBase</span><span class="params">(object)</span>:</span></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, environ, start_response)</span>:</span></span><br><span class="line"> <span class="comment"># WebOb的Request和Response</span></span><br><span class="line">        req = self.request_cls(environ)</span><br><span class="line">        resp = self.response_cls()</span><br><span class="line">        </span><br><span class="line">        state = RoutingState(req, resp, self)</span><br><span class="line">        environ[<span class="string">'pecan.locals'</span>] = &#123;</span><br><span class="line">            <span class="string">'request'</span>: req,</span><br><span class="line">            <span class="string">'response'</span>: resp</span><br><span class="line">        &#125;</span><br><span class="line">        controller = <span class="keyword">None</span></span><br><span class="line">        internal_redirect = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            req.context = environ.get(<span class="string">'pecan.recursive.context'</span>, &#123;&#125;)</span><br><span class="line">            req.pecan = dict(content_type=<span class="keyword">None</span>)</span><br><span class="line"><span class="comment"># 路由方法，对象分发路由机制，传入state，记录整个过程中的状态</span></span><br><span class="line">            controller, args, kwargs = self.find_controller(state)</span><br><span class="line">            <span class="comment"># 调用处理方法</span></span><br><span class="line">            self.invoke_controller(controller, args, kwargs, state)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            ......</span><br><span class="line">            ......</span><br><span class="line"></span><br><span class="line">        self._handle_empty_response_body(state)</span><br><span class="line"><span class="comment"># 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> state.response(environ, start_response)</span><br></pre></td></tr></table></figure><p><strong>主要调用了find_controller和invoke_controller方法。find_controller根据对象分发机制找到url的处理方法，如果没找到，则抛出异常，由后面的except代码块处理，找到了就调用invoke_controller执行该处理方法，将处理结果保存到state中。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PecanBase</span><span class="params">(object)</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">find_controller</span><span class="params">(self, state)</span>:</span></span><br><span class="line">        req = state.request</span><br><span class="line">        pecan_state = req.pecan</span><br><span class="line">        pecan_state[<span class="string">'routing_path'</span>] = path = req.path_info</span><br><span class="line">        <span class="comment"># 处理钩子程序</span></span><br><span class="line">        self.handle_hooks(self.hooks, <span class="string">'on_route'</span>, state)</span><br><span class="line">        ......</span><br><span class="line">        ......</span><br><span class="line">    <span class="comment"># 具体路由方法</span></span><br><span class="line">        controller, remainder = self.route(req, self.root, path)</span><br><span class="line">        ......</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment"># 根据路由结果处理参数，如果没有路由到，则该方法会抛出异常</span></span><br><span class="line">        args, varargs, kwargs = self.get_args(</span><br><span class="line">            state,</span><br><span class="line">            params.mixed(),</span><br><span class="line">            remainder,</span><br><span class="line">            cfg[<span class="string">'argspec'</span>],</span><br><span class="line">            im_self</span><br><span class="line">        )</span><br><span class="line">        state.arguments = Arguments(args, varargs, kwargs)</span><br><span class="line">        <span class="comment"># 处理钩子程序</span></span><br><span class="line">        self.handle_hooks(self.determine_hooks(controller), <span class="string">'before'</span>, state)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> controller, args + varargs, kwargs</span><br></pre></td></tr></table></figure><p><strong>钩子程序分为4种，路由前（on_route），路由后处理前（before），处理后（after），发生错误（on_error）,钩子程序可在app.py中自定义，需要继承PecanHook类（在hooks.py中定义）</strong></p><p>route(req, self.root, path)：</p><blockquote><p>req：WebOb的Request对象，存储了请求的信息<br>self.root：是第一个处理对象（config.py中定义的root<strong>对象</strong>）<br>path：路径信息，如：/v1/books</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">route</span><span class="params">(self, req, node, path)</span>:</span></span><br><span class="line">    path = path.split(<span class="string">'/'</span>)[<span class="number">1</span>:]</span><br><span class="line">    <span class="comment"># 转化后的路径 path:['v1','boos']</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      <span class="comment"># 调用了routing.py文件中的lookup_controller方法</span></span><br><span class="line">        node, remainder = lookup_controller(node, path, req)</span><br><span class="line">        <span class="keyword">return</span> node, remainder</span><br><span class="line">    <span class="keyword">except</span> NonCanonicalPath <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">if</span> self.force_canonical <span class="keyword">and</span> \</span><br><span class="line">                <span class="keyword">not</span> _cfg(e.controller).get(<span class="string">'accept_noncanonical'</span>, <span class="keyword">False</span>):</span><br><span class="line">            <span class="keyword">if</span> req.method == <span class="string">'POST'</span>:</span><br><span class="line">                <span class="keyword">raise</span> RuntimeError(</span><br><span class="line">                    <span class="string">"You have POSTed to a URL '%s' which "</span></span><br><span class="line">                    <span class="string">"requires a slash. Most browsers will not maintain "</span></span><br><span class="line">                    <span class="string">"POST data when redirected. Please update your code "</span></span><br><span class="line">                    <span class="string">"to POST to '%s/' or set force_canonical to False"</span> %</span><br><span class="line">                    (req.pecan[<span class="string">'routing_path'</span>],</span><br><span class="line">                        req.pecan[<span class="string">'routing_path'</span>])</span><br><span class="line">                )</span><br><span class="line">            redirect(code=<span class="number">302</span>, add_slash=<span class="keyword">True</span>, request=req)</span><br><span class="line">        <span class="keyword">return</span> e.controller, e.remainder</span><br><span class="line"></span><br><span class="line"><span class="comment"># routing.py文件</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lookup_controller</span><span class="params">(obj, remainder, request=None)</span>:</span></span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">  <span class="comment"># 存储在obj中未找到处理方法时的_default，_lookup</span></span><br><span class="line">    notfound_handlers = []</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            obj, remainder = find_object(obj, remainder, notfound_handlers,</span><br><span class="line">                                         request)</span><br><span class="line">            handle_security(obj)</span><br><span class="line">            <span class="keyword">return</span> obj, remainder</span><br><span class="line">        <span class="keyword">except</span> (exc.HTTPNotFound, exc.HTTPMethodNotAllowed,</span><br><span class="line">                PecanNotFound) <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">if</span> isinstance(e, PecanNotFound):</span><br><span class="line">                e = exc.HTTPNotFound()</span><br><span class="line">            <span class="keyword">while</span> notfound_handlers:</span><br><span class="line">                name, obj, remainder = notfound_handlers.pop()</span><br><span class="line">                <span class="keyword">if</span> name == <span class="string">'_default'</span>:</span><br><span class="line">                    <span class="keyword">return</span> obj, remainder</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    result = handle_lookup_traversal(obj, remainder)</span><br><span class="line">                    <span class="keyword">if</span> result:</span><br><span class="line">                        <span class="keyword">if</span> (</span><br><span class="line">                            remainder == [<span class="string">''</span>] <span class="keyword">and</span></span><br><span class="line">                            len(obj._pecan[<span class="string">'argspec'</span>].args) &gt; <span class="number">1</span></span><br><span class="line">                        ):</span><br><span class="line">                            <span class="keyword">raise</span> e</span><br><span class="line">                        obj_, remainder_ = result</span><br><span class="line">                        <span class="keyword">return</span> lookup_controller(obj_, remainder_, request)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span> e</span><br></pre></td></tr></table></figure><p><strong>lookup_controller针对每一个controller对象，在其中查找对应的处理方法，如果没找到，则会继续找_default，如果没定义_default，则找_lookup，然后继续循环调用lookup_controller，直到找到对应的方法，或notfound_handlers 为空抛出异常</strong></p><p>obj, remainder = find_object(obj, remainder, notfound_handlers, request)</p><blockquote><p>obj：当前的controller对象<br>remainder：路由信息，如[‘v1’, ‘books’]<br>notfound_handlers：该controller中没找到时，存储<code>_default</code>或者<code>_lookup</code><br>request：请求信息</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_object</span><span class="params">(obj, remainder, notfound_handlers, request)</span>:</span></span><br><span class="line">    prev_obj = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">if</span> obj <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> PecanNotFound</span><br><span class="line">        <span class="comment"># 如果传入的obj直接是一个处理方法（被expsoe装饰），直接返回</span></span><br><span class="line">        <span class="keyword">if</span> iscontroller(obj):</span><br><span class="line">            <span class="keyword">if</span> getattr(obj, <span class="string">'custom_route'</span>, <span class="keyword">None</span>) <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">return</span> obj, remainder</span><br><span class="line">    <span class="comment"># 处理自定义路由信息</span></span><br><span class="line">        _detect_custom_path_segments(obj)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据自定义路由名找到处理方法</span></span><br><span class="line">        <span class="keyword">if</span> remainder:</span><br><span class="line">            custom_route = __custom_routes__.get((obj.__class__, remainder[<span class="number">0</span>]))</span><br><span class="line">            <span class="keyword">if</span> custom_route:</span><br><span class="line">                <span class="keyword">return</span> getattr(obj, custom_route), remainder[<span class="number">1</span>:]</span><br><span class="line">        cross_boundary(prev_obj, obj)</span><br><span class="line">        <span class="comment"># 如果根据默认和自定义路由都没找到，则找该controller中的index方法</span></span><br><span class="line">        <span class="comment"># 如果有路由：/v1/books//best（不标准的路径）,那么就只能路由到/v1/books,后面的就没法路由</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            next_obj, rest = remainder[<span class="number">0</span>], remainder[<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">if</span> next_obj == <span class="string">''</span>:</span><br><span class="line">                index = getattr(obj, <span class="string">'index'</span>, <span class="keyword">None</span>)</span><br><span class="line">                <span class="keyword">if</span> iscontroller(index):</span><br><span class="line">                    <span class="keyword">return</span> index, rest</span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            index = getattr(obj, <span class="string">'index'</span>, <span class="keyword">None</span>)</span><br><span class="line">            <span class="keyword">if</span> iscontroller(index):</span><br><span class="line">                <span class="keyword">raise</span> NonCanonicalPath(index, [])</span><br><span class="line"><span class="comment"># 存储_default方法到notfound_handlers</span></span><br><span class="line">        default = getattr(obj, <span class="string">'_default'</span>, <span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">if</span> iscontroller(default):</span><br><span class="line">            notfound_handlers.append((<span class="string">'_default'</span>, default, remainder))</span><br><span class="line"><span class="comment"># 则存储_lookup方法到notfound_handlers</span></span><br><span class="line">        lookup = getattr(obj, <span class="string">'_lookup'</span>, <span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">if</span> iscontroller(lookup):</span><br><span class="line">            notfound_handlers.append((<span class="string">'_lookup'</span>, lookup, remainder))</span><br><span class="line"><span class="comment"># 根据自定义的_route方法来处理路由（pecan允许开发者在controller中自定义_route方法，让开发者完全掌控路由方式）</span></span><br><span class="line">        route = getattr(obj, <span class="string">'_route'</span>, <span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">if</span> iscontroller(route):</span><br><span class="line">            <span class="keyword">if</span> len(getargspec(route).args) == <span class="number">2</span>:</span><br><span class="line">                warnings.warn(</span><br><span class="line">                    (</span><br><span class="line">                        <span class="string">"The function signature for %s.%s._route is changing "</span></span><br><span class="line">                        <span class="string">"in the next version of pecan.\nPlease update to: "</span></span><br><span class="line">                        <span class="string">"`def _route(self, args, request)`."</span> % (</span><br><span class="line">                            obj.__class__.__module__,</span><br><span class="line">                            obj.__class__.__name__</span><br><span class="line">                        )</span><br><span class="line">                    ),</span><br><span class="line">                    DeprecationWarning</span><br><span class="line">                )</span><br><span class="line">                next_obj, next_remainder = route(remainder)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                next_obj, next_remainder = route(remainder, request)</span><br><span class="line">            cross_boundary(route, next_obj)</span><br><span class="line">            <span class="keyword">return</span> next_obj, next_remainder</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> remainder:</span><br><span class="line">            <span class="keyword">raise</span> PecanNotFound</span><br><span class="line"></span><br><span class="line">        prev_remainder = remainder</span><br><span class="line">        prev_obj = obj</span><br><span class="line">        remainder = rest</span><br><span class="line">        <span class="comment"># 根据方法名（或者属性名）（默认的路由方式）找到处理方法</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            obj = getattr(obj, next_obj, <span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">except</span> UnicodeEncodeError:</span><br><span class="line">            obj = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> obj <span class="keyword">and</span> <span class="keyword">not</span> notfound_handlers <span class="keyword">and</span> hasattr(prev_obj, <span class="string">'index'</span>):</span><br><span class="line">            <span class="keyword">if</span> request.method <span class="keyword">in</span> _cfg(prev_obj.index).get(<span class="string">'generic_handlers'</span>,</span><br><span class="line">                                                          &#123;&#125;):</span><br><span class="line">                <span class="keyword">return</span> prev_obj.index, prev_remainder</span><br></pre></td></tr></table></figure><p>find_object 首先会处理自定义的路由信息，然后存储<code>_default</code>和<code>_lookup</code>，最后处理默认路由（个人觉得可以先处理默认路由信息，然后根据是否配置route装饰进行取舍，这样可能处理更高效）</p><p>routing.py中的lookup_controller 和 find_object是核心路由方式的实现，从代码中可以看出，最终找到处理方法的方式是根据路径（/v1/books）中每一个segment来查找对应的对象，然后根据当前对象再查找下一个对象，所以pecan的路由机制叫做<strong>对象分发</strong></p><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>装饰器定义在decorators.py中，其中最重要的就是expose，它标识了这个被装饰的方法可以被路由找到</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">when_for</span><span class="params">(controller)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">when</span><span class="params">(method, **kw)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(f)</span>:</span></span><br><span class="line">            _cfg(f)[<span class="string">'generic_handler'</span>] = <span class="keyword">True</span></span><br><span class="line">            controller._pecan[<span class="string">'generic_handlers'</span>][method.upper()] = f</span><br><span class="line">            controller._pecan[<span class="string">'allowed_methods'</span>].append(method.upper())</span><br><span class="line">            expose(**kw)(f)</span><br><span class="line">            <span class="keyword">return</span> f</span><br><span class="line">        <span class="keyword">return</span> decorate</span><br><span class="line">    <span class="keyword">return</span> when</span><br><span class="line"></span><br><span class="line"><span class="comment"># template：标识了渲染模板，默认moko，</span></span><br><span class="line"><span class="comment"># generic：默认的方法处理所有类型的请求（GET,POST,PUT,DELETE）,如果为true,则各种类型的请求分开处理</span></span><br><span class="line"><span class="comment"># route：自定义路由</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">expose</span><span class="params">(template=None,</span></span></span><br><span class="line"><span class="function"><span class="params">           generic=False,</span></span></span><br><span class="line"><span class="function"><span class="params">           route=None,</span></span></span><br><span class="line"><span class="function"><span class="params">           **kw)</span>:</span></span><br><span class="line">    content_type = kw.get(<span class="string">'content_type'</span>, <span class="string">'text/html'</span>)</span><br><span class="line">    <span class="keyword">if</span> template == <span class="string">'json'</span>:</span><br><span class="line">        content_type = <span class="string">'application/json'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(f)</span>:</span></span><br><span class="line">        <span class="comment"># flag the method as exposed</span></span><br><span class="line">        f.exposed = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        cfg = _cfg(f)</span><br><span class="line">        cfg[<span class="string">'explicit_content_type'</span>] = <span class="string">'content_type'</span> <span class="keyword">in</span> kw</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> route:</span><br><span class="line">            <span class="comment"># This import is here to avoid a circular import issue</span></span><br><span class="line">            <span class="keyword">from</span> pecan <span class="keyword">import</span> routing</span><br><span class="line">            <span class="keyword">if</span> cfg.get(<span class="string">'generic_handler'</span>):</span><br><span class="line">                <span class="keyword">raise</span> ValueError(</span><br><span class="line">                    <span class="string">'Path segments cannot be overridden for generic '</span></span><br><span class="line">                    <span class="string">'controllers.'</span></span><br><span class="line">                )</span><br><span class="line">            routing.route(route, f)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># set a "pecan" attribute, where we will store details</span></span><br><span class="line">        cfg[<span class="string">'content_type'</span>] = content_type</span><br><span class="line">        cfg.setdefault(<span class="string">'template'</span>, []).append(template)</span><br><span class="line">        cfg.setdefault(<span class="string">'content_types'</span>, &#123;&#125;)[content_type] = template</span><br><span class="line"></span><br><span class="line">        <span class="comment"># handle generic controllers</span></span><br><span class="line">        <span class="keyword">if</span> generic:</span><br><span class="line">            <span class="keyword">if</span> f.__name__ <span class="keyword">in</span> (<span class="string">'_default'</span>, <span class="string">'_lookup'</span>, <span class="string">'_route'</span>):</span><br><span class="line">                <span class="keyword">raise</span> ValueError(</span><br><span class="line">                    <span class="string">'The special method %s cannot be used as a generic '</span></span><br><span class="line">                    <span class="string">'controller'</span> % f.__name__</span><br><span class="line">                )</span><br><span class="line">            cfg[<span class="string">'generic'</span>] = <span class="keyword">True</span></span><br><span class="line">            cfg[<span class="string">'generic_handlers'</span>] = dict(DEFAULT=f)</span><br><span class="line">            cfg[<span class="string">'allowed_methods'</span>] = []</span><br><span class="line">            <span class="comment"># 方法可以被类似@index.when()装饰</span></span><br><span class="line">            f.when = when_for(f)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># store the arguments for this controller method</span></span><br><span class="line">        <span class="comment"># 参数</span></span><br><span class="line">        cfg[<span class="string">'argspec'</span>] = getargspec(f)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f</span><br><span class="line">    <span class="keyword">return</span> decorate</span><br></pre></td></tr></table></figure><ol><li><p><code>cfg = _cfg(f)</code>代码为方法指定了参数<code>_pecan，dict</code>对象，其中存储了该方法很多重要信息</p></li><li><p><code>cfg[‘generic_handlers’] = dict(DEFAULT=f)</code>当<code>generic</code>为<code>true</code>时，其中存储了具体的处理方法，<code>{‘generic_handlers’：{‘DEFAULT’:function,‘POST’:function,‘PUT’:function}}</code>，当请求时<code>POST,PUT,DELETE</code>等方式时，就是从其中获取处理方法</p></li><li><p>f.when = when_for(f)</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 看似是对index_post方法进行装饰，但是主要还是对index方法进行处理</span></span><br><span class="line"><span class="comment"># 这里把index_post方法添加到index方法的_pecan['generic_handlers']中</span></span><br><span class="line"><span class="comment"># 这个写法很有意思，大家可以借鉴</span></span><br><span class="line"><span class="meta">@index.when(method='POST')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index_post</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h2 id="根据POST-PUT-DELETE路由"><a href="#根据POST-PUT-DELETE路由" class="headerlink" title="根据POST,PUT,DELETE路由"></a>根据POST,PUT,DELETE路由</h2><p>在<code>routing.py</code>中<code>find_object</code>方法会返回找到的<code>subcontroller</code>,它是有@expose装饰的一个方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_object</span><span class="params">(obj, remainder, notfound_handlers, request)</span>:</span></span><br><span class="line">   ...</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Last-ditch effort: if there's not a matching subcontroller, no</span></span><br><span class="line">        <span class="comment"># `_default`, no `_lookup`, and no `_route`, look to see if there's</span></span><br><span class="line">        <span class="comment"># an `index` that has a generic method defined for the current request</span></span><br><span class="line">        <span class="comment"># method.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> obj <span class="keyword">and</span> <span class="keyword">not</span> notfound_handlers <span class="keyword">and</span> hasattr(prev_obj, <span class="string">'index'</span>):</span><br><span class="line">            <span class="keyword">if</span> request.method <span class="keyword">in</span> _cfg(prev_obj.index).get(<span class="string">'generic_handlers'</span>,</span><br><span class="line">                                                          &#123;&#125;):</span><br><span class="line">                <span class="keyword">return</span> prev_obj.index, prev_remainder</span><br></pre></td></tr></table></figure><p>在core.py中根据POST具体找到相应的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_controller</span><span class="params">(self, state)</span>:</span></span><br><span class="line">   ...</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> cfg.get(<span class="string">'generic'</span>):</span><br><span class="line">            im_self = six.get_method_self(controller)</span><br><span class="line">            handlers = cfg[<span class="string">'generic_handlers'</span>]</span><br><span class="line">            <span class="comment"># 根据POST找到处理方法</span></span><br><span class="line">            controller = handlers.get(req.method, handlers[<span class="string">'DEFAULT'</span>])</span><br><span class="line">            handle_security(controller, im_self)</span><br><span class="line">            cfg = _cfg(controller)</span><br></pre></td></tr></table></figure><p>所以最终找到处理方法是在core.py中，其实这里我认为处理的不好，还是应该在routing.py中处理</p><p>这里有几个写的不好的地方：</p><ol><li>当请求为/v1//books这种不标准的形式的时候，pecan的路由机制是没法处理的</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    next_obj, rest = remainder[<span class="number">0</span>], remainder[<span class="number">1</span>:]</span><br><span class="line">    <span class="comment"># 可以将这里改成 if next_obj == '' and not rest  解决该问题</span></span><br><span class="line">    <span class="keyword">if</span> next_obj == <span class="string">''</span>:</span><br><span class="line">        index = getattr(obj, <span class="string">'index'</span>, <span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">if</span> iscontroller(index):</span><br><span class="line">            <span class="keyword">return</span> index, rest</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">route</span><span class="params">(self, req, node, path)</span>:</span></span><br><span class="line">  <span class="comment"># 可以将list中最后的空字符串删除，这个需和第一点配合</span></span><br><span class="line">    path = path.split(<span class="string">'/'</span>)[<span class="number">1</span>:]</span><br></pre></td></tr></table></figure><ol><li>对于 POST /v1/books/safgrgfwsfrsg （最后的一个segment没有定义，并且没有定义_lookup和_default），这是依然能够找到路由方法，但是会在参数处理的时候报错，这个地方不合理</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_object</span><span class="params">(obj, remainder, notfound_handlers, request)</span>:</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            obj = getattr(obj, next_obj, <span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">except</span> UnicodeEncodeError:</span><br><span class="line">            obj = <span class="keyword">None</span></span><br><span class="line">            </span><br><span class="line"><span class="comment"># 添加这段代码规避该问题</span></span><br><span class="line"><span class="comment">###########</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> obj <span class="keyword">and</span> <span class="keyword">not</span> notfound_handlers <span class="keyword">and</span> remainder:</span><br><span class="line">abort(<span class="number">404</span>)</span><br><span class="line"><span class="comment">##########</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Last-ditch effort: if there's not a matching subcontroller, no</span></span><br><span class="line">        <span class="comment"># `_default`, no `_lookup`, and no `_route`, look to see if there's</span></span><br><span class="line">        <span class="comment"># an `index` that has a generic method defined for the current request</span></span><br><span class="line">        <span class="comment"># method.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> obj <span class="keyword">and</span> <span class="keyword">not</span> notfound_handlers <span class="keyword">and</span> hasattr(prev_obj, <span class="string">'index'</span>):</span><br><span class="line">            <span class="keyword">if</span> request.method <span class="keyword">in</span> _cfg(prev_obj.index).get(<span class="string">'generic_handlers'</span>,</span><br><span class="line">                                                          &#123;&#125;):</span><br><span class="line">                <span class="keyword">return</span> prev_obj.index, prev_remainder</span><br></pre></td></tr></table></figure><p>上面3点对源码的改动可以完成我们自定义的一些需求，并且是pecan的代码结构更加合理。</p><h1 id="pecan-控制器和路由系统"><a href="#pecan-控制器和路由系统" class="headerlink" title="pecan 控制器和路由系统"></a>pecan 控制器和路由系统</h1><p>对于 pecan 的路由分发机制还是有必要再分析一下</p><p>Pecan路由采用的是对象分发机制，将HTTP请求分发到控制器，然后到控制器里定义的方法。</p><p>对象分发机制将请求路径进行切割，根据请求路径从root控制器开始，按次序寻找路径对应的控制器及方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pecan <span class="keyword">import</span> expose</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BooksController</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">    @expose()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Welcome to book section."</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @expose()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bestsellers</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"We have 5 books in the top 10."</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CatalogController</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">    @expose()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Welcome to the catalog."</span></span><br><span class="line"></span><br><span class="line">    books = BooksController()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RootController</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">    @expose()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Welcome to store.example.com!"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @expose()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hours</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Open 24/7 on the web."</span></span><br><span class="line"></span><br><span class="line">    catalog = CatalogController()</span><br></pre></td></tr></table></figure><p>对于上述代码，如果此时有这样一个请求：/catalog/books/bestsellers，则pecan首先将这个请求分割成：catalog, books, bestsellers。接下来，pecan将会从root控制器中寻找catalog，找到catalog对象后，pecan会继续在catalog控制器中寻找books，以此类推一直找到bestsellers。如果URL以’/‘结束，那么pecan将会查找最后一个控制器的index方法。</p><p>进一步讲，下面的这些请求路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">└── /</span><br><span class="line">    ├── /hours</span><br><span class="line">    └── /catalog</span><br><span class="line">         └── /catalog/books</span><br><span class="line">            └── /catalog/books/bestsellers</span><br></pre></td></tr></table></figure><p>将会路由给这些控制器方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">└── RootController.index</span><br><span class="line">    ├── RootController.hours</span><br><span class="line">    └── CatalogController.index</span><br><span class="line">         └── BooksController.index</span><br><span class="line">            └── BooksController.bestsellers</span><br></pre></td></tr></table></figure><h2 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h2><p>有时，标准的对象分发路由方式不足以将某个URL路由到一个控制器上。pecan提供了几种方法去使对象分发方式的路由发生短路，以便用更多的控制来处理URL，以下这些特殊的方法用来实现这个目标：<code>_lookup()，_default()，_route()</code>。在你的控制器上定义这些方法可以让你更加灵活的处理一个URL的全部内容或部分内容。</p><h3 id="Controller-增加方法处理路由"><a href="#Controller-增加方法处理路由" class="headerlink" title="Controller 增加方法处理路由"></a>Controller 增加方法处理路由</h3><p>我们需要不同的路由返回不同的内容。这里我们介绍一种Pecan注册路由的方法。RootController加一个方法叫做diff。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> happy_expose</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RootController</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @happy_expose</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @happy_expose</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_default</span><span class="params">(self, *remainder)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Hello World from root default'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @happy_expose</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diff</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'You find different worlds'</span></span><br></pre></td></tr></table></figure><p>增加了diff方法，装饰器不要忘了，怎么访问这个不同的路径呢，很简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:5000/diff</span><br><span class="line"></span><br><span class="line">页面显示 You find different worlds</span><br></pre></td></tr></table></figure><p>我们可以通过添加不同的方法名，来处理不同的路由，返回不同的结果。Pecan会根据路由查看，你这个控制器有没有对应的属性，有的话就交给这个属性方法处理。</p><h3 id="Controller-增加属性处理路由"><a href="#Controller-增加属性处理路由" class="headerlink" title="Controller 增加属性处理路由"></a>Controller 增加属性处理路由</h3><p>我们已经知道了一种注册路由的方法了，现在介绍第二种。</p><p>更改代码，这次我们原有的文件结构不变，给root.py增加点东西，增加后变成下面这样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> happy_expose</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookController</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @happy_expose</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Welcome to the Sea of Books"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RootController</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    book = BookController()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @happy_expose</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @happy_expose</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_default</span><span class="params">(self, *remainder)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Hello World from root default'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @happy_expose</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">diff</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'You find different worlds'</span></span><br></pre></td></tr></table></figure><p>两点改变：</p><ul><li>增加BookController这个类的定义</li><li>RootController增加一个属性 book = BookController()</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">浏览器输入http://127.0.0.1:5000/book/</span><br><span class="line"></span><br><span class="line">页面显示 Welcome to the Sea of Books</span><br><span class="line"></span><br><span class="line">我们如愿看到，“Welcome to the Sea of Books”</span><br></pre></td></tr></table></figure><p>这次的原理，其实是个上一个添加路由的方法是一样的，Pecan会根据路由查看，你这个控制器有没有对应的属性，有的话就交给这个属性方法处理。上一个是添加了一个成员方法，这次是一个成员属性而已。</p><p>如果我们访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:5000/book/sea 会是什么样呢？</span><br><span class="line"></span><br><span class="line">页面显示 Hello World from root default</span><br><span class="line"></span><br><span class="line">咦，怎么进了RootController的_default了呢？！</span><br></pre></td></tr></table></figure><p>其实原理是这么回事的：</p><p>Pecan会把路由分成[“book”, “sea”]</p><ol><li><p>从RootController去发现有没有能处理book的Controller。发现RooController有一个book属性值为BookController的对象。</p></li><li><p>Pecan从BookController的对象去发现有没有能处理sea的Controller。找了一圈发现没有，这就尴尬了处理不了！但是为啥没有报404呢？</p></li></ol><p>因为在第一步的时候，Pecan不仅会去发现有没有能处理book的Controller，同时还会去检查RootController有没有一些应对没找到Controller时处理的方法。这些方法可以是<code>_defalut</code>（这个我们已经用过了），<code>_lookup</code>（这个后面在讲）。发现有<code>_default</code>，会将<code>_default</code>放入一个列表，待用。第二步以后发现，没有能处理的Controller，所以调用了RootController对象的<code>_default</code>的方法，我们就看到了“Hello World from root default”</p><p>如果在 BookController 放个 _default 呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookController</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @happy_expose</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Welcome to the Sea of Books"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @happy_expose</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_default</span><span class="params">(self, *remainder)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"This is Book default"</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">再访问http://127.0.0.1:5000/book/sea 会是什么样呢？</span><br><span class="line"></span><br><span class="line">页面显示 This is Book default</span><br></pre></td></tr></table></figure><p>为啥是这个结果呢？</p><ol><li><p>第一步的时候，会把<code>RooController()._default</code>，放入一个待用队列，源码里叫做<code>notfound_handlers=[RooController()._default]</code></p></li><li><p>第二步的时候，虽然没有发现能处理sea的控制器，也会去查找一个有没有<code>_default，_look_up</code>。发现有<code>_default</code>，也会放入队列。变成<code>notfound_handlers=[RooController()._default, BookController()._default]</code>。</p></li></ol><p>当最终没有能处理[‘book’, ‘sea’]时，开始<code>notfound_handlers</code>上场。他会倒着拿里面的值，就是<code>notfound_handlers.pop()</code>。所以会<code>BookController()._default</code>处理。</p><h3 id="lookup"><a href="#lookup" class="headerlink" title="_lookup()"></a>_lookup()</h3><p><code>_lookup()</code>提供一种方式处理一个URL的部分内容，并返回一个新的控制器用于处理URL的剩余部分。一个<code>_lookup()</code>方法可以提供一个或多个参数，以及URL的分片。同时_lookup()方法应该用可变的位置表示URL的剩余部分，并且在它的返回值里包含未处理的剩余URL部分。在下面的例子中，对象分发路由算法将会把remainder列表传递给该方法返回的控制器。</p><p><code>_lookup()</code>除了被用来动态创建控制器以外，当没有其他任何控制器方法能够匹配一个URL且没有定义<code>_default()</code>方法时，<code>_lookup()</code>方法作为最后一个方法被调用。</p><p>此方法返回一个新的控制器用于控制url的剩余部分，如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_student_by_primary_key</span><span class="params">(num)</span>:</span></span><br><span class="line">    a = [<span class="string">"xiao_ming"</span>, <span class="string">"xiao_li"</span>]</span><br><span class="line">    num = int(num) <span class="keyword">if</span> type(num) == int <span class="keyword">and</span> len(a) &gt; int(num) <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> a[num]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Addr</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">    @expose()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"addr"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentController</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, student)</span>:</span></span><br><span class="line">        self.student = student</span><br><span class="line"></span><br><span class="line"><span class="meta">    @expose()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.student</span><br><span class="line"></span><br><span class="line">    addr = Addr()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RootController</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @expose()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_lookup</span><span class="params">(self, primary_key, *remainder)</span>:</span></span><br><span class="line">        student = get_student_by_primary_key(primary_key)</span><br><span class="line">        <span class="keyword">if</span> student:</span><br><span class="line">            <span class="keyword">return</span> StudentController(student), remainder</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"404"</span></span><br></pre></td></tr></table></figure><p>例如”/1/name”路径，将走_lookup()方法，返回 StudentController(student), remainder；</p><p>此时，StudentController(student) 是一个新的控制器，而remainder是url的剩余部分，即 name；</p><p>StudentController() 控制器将找到def name(self) 进而响应请求。</p><p>同理，对于”/100/addr”，也走_lookup()方法，返回 StudentController(student), remainder；</p><p>此时，StudentController(student) 是一个新的控制器，而remainder是url的剩余部分，即 addr；</p><p>找到addr = Addr()，进而得到响应。</p><h3 id="default"><a href="#default" class="headerlink" title="_default()"></a>_default()</h3><p>对于标准的对象路由分发机制，当没有任何控制器可以处理url是，_default将要作为最后一个方法被调度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">happy_expose</span><span class="params">(f=None, **kw)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> f <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner_expose</span><span class="params">(func)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> happy_expose(func, **kw)</span><br><span class="line">        <span class="keyword">return</span> inner_expose</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line"><span class="meta">        @wraps(f)</span></span><br><span class="line"><span class="meta">        @expose(**kw)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_expose</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> f(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> _expose</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RootController</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @expose()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hours</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Open 24/7 on the web."</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @happy_expose</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_default</span><span class="params">(self, *remainder)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Hello World from root default'</span></span><br></pre></td></tr></table></figure><p>_default方法是最后被调用的。</p><h3 id="route-方法"><a href="#route-方法" class="headerlink" title="_route()方法"></a>_route()方法</h3><p><code>_route()</code>方法允许一个控制器完全覆盖pecan的路由机制。pecan它本身也使用<code>_route()</code>方法去实现它的RestController。如果你想在pecan之上定义一套替代的路由机制，那么定义一个包含<code>_route()</code>方法的基控制器将会使你完全掌控请求的路由。</p><h2 id="expose-暴露控制器方法"><a href="#expose-暴露控制器方法" class="headerlink" title="expose 暴露控制器方法"></a>expose 暴露控制器方法</h2><p>expose告诉Pecan类中的哪些方法是公开可见的 。如果一个方法没有用修饰expose()，Pecan永远不会将请求路由到它。</p><p>pecan默认采用expose进行路由绑定，需要路由控制器类的方法都要经过expose装饰器的装饰，pecan就可以使HTTP请求找到对应的方法。</p><p>不同的使用方法会有不同的效果，如下：</p><h3 id="expose"><a href="#expose" class="headerlink" title="@expose()"></a>@expose()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pecan <span class="keyword">import</span> expose</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RootController</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">    @expose()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Hello World’</span></span><br></pre></td></tr></table></figure><p>被装饰的方法需要返回一个字符串，表示HTML响应的body。</p><h3 id="expose-html-template-name"><a href="#expose-html-template-name" class="headerlink" title="@expose(html_template_name)"></a>@expose(html_template_name)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pecan <span class="keyword">import</span> expose</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RootController</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">    @expose('html_template.mako')</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">'msg'</span>: <span class="string">'Hello!’&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- html_template.mako --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span>$&#123;msg&#125;<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>被装饰的方法返回一个字典，字典的key可以在html模板中使用<code>${key}</code>的方式引用。</p><h3 id="expose-route-’some-path’"><a href="#expose-route-’some-path’" class="headerlink" title="@expose(route=’some-path’)"></a>@expose(route=’some-path’)</h3><p>例如有这样一个请求：/some-path，由于python语法限制，pecan并不能将该请求的处理方法声明为some-path。使用@expose(route=’some-path’)，被装饰方法将响应<code>/some-path</code>请求。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RootController</span><span class="params">(object)</span>:</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">    @expose(route='some-path')</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">some_path</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> dict()</span><br></pre></td></tr></table></figure><p>注意：尽量不使用dict()，使用不当，HTTP状态码将是204，及服务器没有返回任何内容错误。</p><p>另一种方式：pecan.route()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RootController</span><span class="params">(object)</span>:</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">    @expose()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">some_path</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> dict()</span><br><span class="line"> </span><br><span class="line">pecan.route(<span class="string">'some-path'</span>, RootController.some_path)</span><br></pre></td></tr></table></figure><p>延伸：利用route()方法来将请求路由给下一级控制器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildController</span><span class="params">(object)</span>:</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">    @expose()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">child</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> dict()</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RootController</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line">pecan.route(RootController, <span class="string">'child-path'</span>, ChildController())</span><br></pre></td></tr></table></figure><p>在这个例子中，pecan应用将会给请求/child-path/child/返回HTTP 200响应。</p><h3 id="expose-generic-True"><a href="#expose-generic-True" class="headerlink" title="@expose(generic=True)"></a>@expose(generic=True)</h3><p>expose()方法中的generic参数可以根据请求方法对URL进行重载，即一个url路径可以被两个不同的方法处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RootController</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># HTTP GET /</span></span><br><span class="line"><span class="meta">    @expose(generic=True, template='json')</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> dict()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># HTTP POST /</span></span><br><span class="line"><span class="meta">    @index.when(method='POST', template='json')</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">index_POST</span><span class="params">(self, **kw)</span>:</span></span><br><span class="line">        uuid = create_something()</span><br><span class="line">        <span class="keyword">return</span> dict(uuid=uuid)</span><br></pre></td></tr></table></figure><p>对于”/“的GET请求，由index()方法处理；对于”/“的POST请求，由index_POST方法处理。</p><p><strong>根据请求方法来路由，其实还有一种方式，继承<code>pecan.rest.RestController</code>来实现</strong></p><p>但是这里有个坑，就是不能实现<code>index</code>方法，不然会被覆盖，具体用法看下：</p><p><img src="/images/python-web-pecan-3.png" alt="With RestController"></p><p><img src="/images/python-web-pecan-4.png" alt="default method with RestController"></p><p><a href="https://xinzhe.blog.csdn.net/article/details/114086638" target="_blank" rel="external">Pecan学习：官方文档解读</a></p><p><a href="https://pecan.readthedocs.io/en/latest/rest.html#rest" target="_blank" rel="external">Writing RESTful Web Services with Generic Controllers</a></p><h3 id="expose-叠加用法"><a href="#expose-叠加用法" class="headerlink" title="@expose()叠加用法"></a>@expose()叠加用法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RootController</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">    @expose('json')</span></span><br><span class="line"><span class="meta">    @expose('text_template.mako', content_type='text/plain')</span></span><br><span class="line"><span class="meta">    @expose('html_template.mako')</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">'msg'</span>: <span class="string">'Hello!'</span>&#125;</span><br></pre></td></tr></table></figure><p>叠加使用后一个<code>hello</code>方法可以响应三种格式的请求(application/json, text/plain, text/html)。</p><ul><li>当客户端请求/hello.json或者http header中包含“Accept: application/json”时，将hello()方法响应的名字空间渲染进json文本，及@expose(‘json’)用法；</li><li>当客户端请求/hello.txt或者http header中包含“Accept: text/plain”时，使用text_template.mako模板文件响应，即@expose(‘text_template.mako’, content_type=’text/plain’)用法；</li><li>当客户端请求/hello.html时，使用html_template.mako模板文件。如果客户端请求/hello，并且没有显式指明内容格式，则pecan默认使用text/html的内容格式进行响应，假设客户端想要HTML。</li></ul><h1 id="pecan-使用示例"><a href="#pecan-使用示例" class="headerlink" title="pecan 使用示例"></a>pecan 使用示例</h1><p>配置文件test.ini</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[composite:hello]</span></span><br><span class="line"><span class="attr">use</span> = egg:Paste#urlmap</span><br><span class="line">/ = hello</span><br><span class="line"></span><br><span class="line"><span class="section">[pipeline:hello]</span></span><br><span class="line"><span class="attr">pipeline</span> = main</span><br><span class="line"></span><br><span class="line"><span class="section">[app:main]</span></span><br><span class="line">paste.app_factory = main:app_factory</span><br><span class="line"><span class="attr">root</span> = main.Controller</span><br></pre></td></tr></table></figure><p>main.py简单文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> wsgiref.simple_server <span class="keyword">as</span> wss</span><br><span class="line"><span class="keyword">from</span> paste <span class="keyword">import</span> deploy</span><br><span class="line"><span class="keyword">from</span> pecan <span class="keyword">import</span> expose, Response</span><br><span class="line"><span class="keyword">import</span> pecan</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Controller</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">    @expose()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Response(<span class="string">'Hello, World!'</span>, <span class="number">202</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_wsgi_app</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> os</span><br><span class="line">    abspath = os.path.dirname(os.path.abspath(__file__))</span><br><span class="line">    conf_path = os.path.join(abspath, <span class="string">"hello.ini"</span>)</span><br><span class="line">    app = deploy.loadapp(<span class="string">"config:&#123;0&#125;"</span>.format(conf_path), name=<span class="string">"main"</span>)</span><br><span class="line">    <span class="keyword">return</span> app</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">app_factory</span><span class="params">(global_config, **local_conf)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> pecan.make_app(root=local_conf.get(<span class="string">'root'</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    server = wss.make_server(<span class="string">''</span>, <span class="number">8000</span>, build_wsgi_app())</span><br><span class="line">    server.serve_forever()</span><br></pre></td></tr></table></figure><p>配置文件中，构建一个叫hello的composite，使用一个叫hello的pipeline。pipeline使用Controller作为控制器。</p><p>build_wsgi_app 加载配置文件。</p><p>运行server</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python main.py</span><br></pre></td></tr></table></figure><p><img src="/images/python-web-pecan-5.png" alt="img"></p><p><br><br>参考：</p><p><a href="https://blog.csdn.net/choumin/article/details/89405135?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-14.baidujs&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-14.baidujs" target="_blank" rel="external">pecan的路由机制</a></p><p><a href="https://blog.csdn.net/qq527631128/article/details/90245555" target="_blank" rel="external">pecan源码阅读</a></p><p><a href="https://www.cnblogs.com/aaronthon/p/14832494.html" target="_blank" rel="external">Pecan控制器和路由系统</a></p><p><a href="https://blog.csdn.net/weixin_43700106/article/details/107734216" target="_blank" rel="external">python 学习记录：pecan 框架原理分析和示例</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p id=&quot;div-border-top-green&quot;&gt;别人怎样去看待你的价值并不重要，重要是你自己怎样看待自身的价值。即便你是一块货真价实的金子，多说己长也便是短，自知己短便是长。一个人的真正伟大之处，就在于能认识到自己的渺小。&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Pecan&lt;/code&gt;框架的目标是实现一个采用对象分发方式进行&lt;code&gt;URL&lt;/code&gt;路由的轻量级&lt;code&gt;Web&lt;/code&gt;框架。它非常专注于自己的目标，它的大部分功能都和&lt;code&gt;URL&lt;/code&gt;路&lt;/p&gt;
&lt;p&gt;由以及请求和响应的处理相关，而不去实现模板、安全以及数据库层，这些东西都可以通过其他的库来实现。关于&lt;code&gt;Pecan&lt;/code&gt;的更多信息，可&lt;/p&gt;
&lt;p&gt;以 &lt;a href=&quot;https://pecan.readthedocs.org/en/latest/index.html&quot;&gt;查看文档&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://magiceses.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://magiceses.github.io/tags/Python/"/>
    
      <category term="PythonWeb" scheme="https://magiceses.github.io/tags/PythonWeb/"/>
    
  </entry>
  
  <entry>
    <title>Alertmanager 使用原理和源码分析</title>
    <link href="https://magiceses.github.io/2020/03/31/prometheus-alertmanager-%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%90%86%E5%92%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://magiceses.github.io/2020/03/31/prometheus-alertmanager-使用原理和源码分析/</id>
    <published>2020-03-30T23:25:24.000Z</published>
    <updated>2021-10-02T07:58:41.115Z</updated>
    
    <content type="html"><![CDATA[<p id="div-border-top-green">真正的坚强，是属于那些夜晚在被窝里哭泣，而白天却若无其事的人。未曾深夜痛哭过的人，不足以谈论人生。<br></p><h2 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h2><p>我们先从应用的角度来看详细的介绍一下alertmanager以下简称am，以下是官方文档介绍。</p><blockquote><p>The Alertmanager handles alerts sent by client applications such as the Prometheus server. It takes care of deduplicating, grouping, and routing them to the correct receiver integrations such as email, PagerDuty, or OpsGenie. It also takes care of silencing and inhibition of alerts.</p></blockquote><p>翻译一下就是，负责处理接受client（例如prometheus）发送的告警消息，包括重复告警的发送、聚合、发给相关人员，并且支持多种方式例如email或者pagerduty这种第三方通知告警平台，同时他还提供了静音以及告警抑制的功能。</p><p>这些功能基本涵盖了目前各大公司的告警痛点，<strong>重复告警</strong>（告警发生了但是一直也没人处理）、<strong>告警风暴</strong>（某次版本上线导致的大量服务机器指标异常）、<strong>告警信息重复</strong>（例如机器宕机之后又收到了网络不通的告警）。</p><p>这里注意下，prometheus族包括am他们的实现思路都是基于label来做的，后面会从代码层面详细介绍下</p><p>实现一个完整的监控体系需要以下几个功能：</p><a id="more"></a><ul><li>数据采集（xxx_export）</li><li>数据抓取（prometheus）</li><li>数据存储（prometheus/cortex）</li><li>规则检测并生成告警（prometheus/cotex.ruler）</li><li>告警处理（alertmanager）</li><li>告警通知（一般根据自身业务和管理体系实现）</li></ul><p><strong>Alertmanager实现了告警处理（聚合、抑制、屏蔽、路由）</strong></p><p>基本流程如下：</p><p><strong>1.</strong> Prometheus Server监控目标主机上暴露的http接口（这里假设接口A），通过上述Promethes配置的’scrape_interval’定义的时间间隔，定期采集目标主机上监控数据。</p><p><strong>2.</strong> 当接口A不可用的时候，Server端会持续的尝试从接口中取数据，直到”scrape_timeout”时间后停止尝试。这时候把接口的状态变为“DOWN”。</p><p><strong>3</strong>. Prometheus同时根据配置的”evaluation_interval”的时间间隔，定期（默认1min）的对Alert Rule进行评估；当到达评估周期的时候，发现接口A为DOWN，即UP=0为真，激活Alert，进入“PENDING”状态，并记录当前active的时间；</p><p><strong>4.</strong> 当下一个alert rule的评估周期到来的时候，发现UP=0继续为真，然后判断警报Active的时间是否已经超出rule里的‘for’ 持续时间，如果未超出，则进入下一个评估周期；如果时间超出，则alert的状态变为“FIRING”；同时调用Alertmanager接口，发送相关报警数据。</p><p><strong>5.</strong> AlertManager收到报警数据后，会将警报信息进行分组，然后根据alertmanager配置的“group_wait”时间先进行等待。等wait时间过后再发送报警信息。</p><p><strong>6.</strong> 属于同一个Alert Group的警报，在等待的过程中可能进入新的alert，如果之前的报警已经成功发出，那么间隔“group_interval”的时间间隔后再重新发送报警信息。比如配置的是邮件报警，那么同属一个group的报警信息会汇总在一个邮件里进行发送。</p><p><strong>7.</strong> 如果Alert Group里的警报一直没发生变化并且已经成功发送，等待‘repeat_interval’时间间隔之后再重复发送相同的报警邮件；如果之前的警报没有成功发送，则相当于触发第6条条件，则需要等待group_interval时间间隔后重复发送。同时最后至于警报信息具体发给谁，满足什么样的条件下指定警报接收人，设置不同报警发送频率，这里有alertmanager的route路由规则进行配置。</p><p>告警发送通知流程-1：</p><p><img src="/images/prometheus-alertmanager-8.png" alt="https://note.youdao.com/yws/public/resource/08ef03888558443a04d7f3e39c2d975d/xmlnote/WEBRESOURCEe71833b5f301818c2524048ed5ed436d/24641"></p><p>告警发送通知流程-2：</p><p><img src="/images/prometheus-alertmanager-9.png" alt="https://note.youdao.com/yws/public/resource/08ef03888558443a04d7f3e39c2d975d/xmlnote/WEBRESOURCE643c3bb348a7477a11e20d8740e182dd/24645"></p><h2 id="实现架构"><a href="#实现架构" class="headerlink" title="实现架构"></a>实现架构</h2><p><img src="/images/prometheus-alertmanager-10.jpg" alt="img"></p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h3 id="alertmanager"><a href="#alertmanager" class="headerlink" title="alertmanager"></a>alertmanager</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="comment"># The smarthost and SMTP sender used for mail notifications.</span></span><br><span class="line"><span class="attr">  smtp_smarthost:</span> <span class="string">'smtp.qq.com:465'</span></span><br><span class="line"><span class="attr">  smtp_from:</span> <span class="string">'447040949@qq.com'</span></span><br><span class="line"><span class="attr">  smtp_auth_username:</span> <span class="string">'447040949@qq.com'</span></span><br><span class="line"><span class="attr">  smtp_auth_password:</span> <span class="string">'nihao206206#'</span></span><br><span class="line">  <span class="comment"># The auth token for Hipchat.</span></span><br><span class="line"><span class="attr">  hipchat_auth_token:</span> <span class="string">'1234556789'</span></span><br><span class="line">  <span class="comment"># Alternative host for Hipchat.</span></span><br><span class="line"><span class="attr">  hipchat_url:</span> <span class="string">'https://hipchat.foobar.org/'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The directory from which notification templates are read.</span></span><br><span class="line"><span class="attr">templates:</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">'/etc/alertmanager/template/*.tmpl'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The root route on which each incoming alert enters.</span></span><br><span class="line"><span class="attr">route:</span></span><br><span class="line">  <span class="comment"># The labels by which incoming alerts are grouped together. For example,</span></span><br><span class="line">  <span class="comment"># multiple alerts coming in for cluster=A and alertname=LatencyHigh would</span></span><br><span class="line">  <span class="comment"># be batched into a single group.</span></span><br><span class="line"><span class="attr">  group_by:</span> <span class="string">['alertname',</span> <span class="string">'cluster'</span><span class="string">,</span> <span class="string">'service'</span><span class="string">]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># When a new group of alerts is created by an incoming alert, wait at</span></span><br><span class="line">  <span class="comment"># least 'group_wait' to send the initial notification.</span></span><br><span class="line">  <span class="comment"># This way ensures that you get multiple alerts for the same group that start</span></span><br><span class="line">  <span class="comment"># firing shortly after another are batched together on the first </span></span><br><span class="line">  <span class="comment"># notification.</span></span><br><span class="line"><span class="attr">  group_wait:</span> <span class="number">30</span><span class="string">s</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># When the first notification was sent, wait 'group_interval' to send a batch</span></span><br><span class="line">  <span class="comment"># of new alerts that started firing for that group.</span></span><br><span class="line"><span class="attr">  group_interval:</span> <span class="number">5</span><span class="string">m</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># If an alert has successfully been sent, wait 'repeat_interval' to</span></span><br><span class="line">  <span class="comment"># resend them.</span></span><br><span class="line"><span class="attr">  repeat_interval:</span> <span class="number">3</span><span class="string">h</span> </span><br><span class="line"></span><br><span class="line">  <span class="comment"># A default receiver</span></span><br><span class="line"><span class="attr">  receiver:</span> <span class="string">team-X-mails</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># All the above attributes are inherited by all child routes and can </span></span><br><span class="line">  <span class="comment"># overwritten on each.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># The child route trees.</span></span><br><span class="line"><span class="attr">  routes:</span></span><br><span class="line">  <span class="comment"># This routes performs a regular expression match on alert labels to</span></span><br><span class="line">  <span class="comment"># catch alerts that are related to a list of services.</span></span><br><span class="line"><span class="attr">  - match_re:</span></span><br><span class="line"><span class="attr">      service:</span> <span class="string">^(foo1|foo2|baz)$</span></span><br><span class="line"><span class="attr">    receiver:</span> <span class="string">team-X-mails</span></span><br><span class="line">    <span class="comment"># The service has a sub-route for critical alerts, any alerts</span></span><br><span class="line">    <span class="comment"># that do not match, i.e. severity != critical, fall-back to the</span></span><br><span class="line">    <span class="comment"># parent node and are sent to 'team-X-mails'</span></span><br><span class="line"><span class="attr">    routes:</span></span><br><span class="line"><span class="attr">    - match:</span></span><br><span class="line"><span class="attr">        severity:</span> <span class="string">critical</span></span><br><span class="line"><span class="attr">      receiver:</span> <span class="string">team-X-pager</span></span><br><span class="line"><span class="attr">  - match:</span></span><br><span class="line"><span class="attr">      service:</span> <span class="string">files</span></span><br><span class="line"><span class="attr">    receiver:</span> <span class="string">team-Y-mails</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    routes:</span></span><br><span class="line"><span class="attr">    - match:</span></span><br><span class="line"><span class="attr">        severity:</span> <span class="string">critical</span></span><br><span class="line"><span class="attr">      receiver:</span> <span class="string">team-Y-pager</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># This route handles all alerts coming from a database service. If there's</span></span><br><span class="line">  <span class="comment"># no team to handle it, it defaults to the DB team.</span></span><br><span class="line"><span class="attr">  - match:</span></span><br><span class="line"><span class="attr">      service:</span> <span class="string">database</span></span><br><span class="line"><span class="attr">    receiver:</span> <span class="string">team-DB-pager</span></span><br><span class="line">    <span class="comment"># Also group alerts by affected database.</span></span><br><span class="line"><span class="attr">    group_by:</span> <span class="string">[alertname,</span> <span class="string">cluster,</span> <span class="string">database]</span></span><br><span class="line"><span class="attr">    routes:</span></span><br><span class="line"><span class="attr">    - match:</span></span><br><span class="line"><span class="attr">        owner:</span> <span class="string">team-X</span></span><br><span class="line"><span class="attr">      receiver:</span> <span class="string">team-X-pager</span></span><br><span class="line"><span class="attr">    - match:</span></span><br><span class="line"><span class="attr">        owner:</span> <span class="string">team-Y</span></span><br><span class="line"><span class="attr">      receiver:</span> <span class="string">team-Y-pager</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Inhibition rules allow to mute a set of alerts given that another alert is</span></span><br><span class="line"><span class="comment"># firing.</span></span><br><span class="line"><span class="comment"># We use this to mute any warning-level notifications if the same alert is </span></span><br><span class="line"><span class="comment"># already critical.</span></span><br><span class="line"><span class="attr">inhibit_rules:</span></span><br><span class="line"><span class="attr">- source_match:</span></span><br><span class="line"><span class="attr">    severity:</span> <span class="string">'critical'</span></span><br><span class="line"><span class="attr">  target_match:</span></span><br><span class="line"><span class="attr">    severity:</span> <span class="string">'warning'</span></span><br><span class="line">  <span class="comment"># Apply inhibition if the alertname is the same.</span></span><br><span class="line"><span class="attr">  equal:</span> <span class="string">['alertname',</span> <span class="string">'cluster'</span><span class="string">,</span> <span class="string">'service'</span><span class="string">]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">receivers:</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">'team-X-mails'</span></span><br><span class="line"><span class="attr">  webhook_configs:</span></span><br><span class="line"><span class="attr">  - url:</span> <span class="string">'http://u2.kugou.net:11770/sendRtxByPost'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">'team-X-pager'</span></span><br><span class="line"><span class="attr">  email_configs:</span></span><br><span class="line"><span class="attr">  - to:</span> <span class="string">'team-X+alerts-critical@example.org'</span></span><br><span class="line"><span class="attr">  pagerduty_configs:</span></span><br><span class="line"><span class="attr">  - service_key:</span> <span class="string">&lt;team-X-key&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">'team-Y-mails'</span></span><br><span class="line"><span class="attr">  email_configs:</span></span><br><span class="line"><span class="attr">  - to:</span> <span class="string">'team-Y+alerts@example.org'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">'team-Y-pager'</span></span><br><span class="line"><span class="attr">  pagerduty_configs:</span></span><br><span class="line"><span class="attr">  - service_key:</span> <span class="string">&lt;team-Y-key&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">'team-DB-pager'</span></span><br><span class="line"><span class="attr">  pagerduty_configs:</span></span><br><span class="line"><span class="attr">  - service_key:</span> <span class="string">&lt;team-DB-key&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">- name:</span> <span class="string">'team-X-hipchat'</span></span><br><span class="line"><span class="attr">  hipchat_configs:</span></span><br><span class="line"><span class="attr">  - auth_token:</span> <span class="string">&lt;auth_token&gt;</span></span><br><span class="line"><span class="attr">    room_id:</span> <span class="number">85</span></span><br><span class="line"><span class="attr">    message_format:</span> <span class="string">html</span></span><br><span class="line"><span class="attr">    notify:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>参数说明</p><ul><li><p>global<br>smtp_smarthost、smtp_from、smtp_auth_username、smtp_auth_password用于设置smtp邮件的地址及用户信息<br>hipchat_auth_token与安全性认证有关</p></li><li><p>templates<br>指定告警信息展示的模版</p></li><li><p>route<br>group_by：指定所指定的维度对告警进行分组<br>group_wait:指定每组告警发送等待的时间<br>group_interval:指定告警调度的时间间隔<br>repeat_interval:在连续告警触发的情况下，重复发送告警的时间间隔</p></li><li>receiver<br>指定告警默认的接受者</li><li>routes<br>match_re:定义告警接收者的匹配方式<br>service:定义匹配的方式，纬度service值以foo1或foo2或baz开始/结束时表示匹配成功<br>receiver：定义了匹配成功的的情况下的接受者</li><li>inhibit_rules<br>定义告警的抑制条件，过滤不必要的告警</li><li>receivers<br>定义了具体的接收者，也就是告警具体的方式方式</li></ul><h3 id="prometheus"><a href="#prometheus" class="headerlink" title="prometheus"></a>prometheus</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># my global config</span></span><br><span class="line"><span class="attr">global:</span></span><br><span class="line"><span class="attr">  scrape_interval:</span>     <span class="number">15</span><span class="string">s</span> <span class="comment"># By default, scrape targets every 15 seconds.</span></span><br><span class="line"><span class="attr">  evaluation_interval:</span> <span class="number">15</span><span class="string">s</span> <span class="comment"># By default, scrape targets every 15 seconds.</span></span><br><span class="line">  <span class="comment"># scrape_timeout is set to the global default (10s).</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Attach these labels to any time series or alerts when communicating with</span></span><br><span class="line">  <span class="comment"># external systems (federation, remote storage, Alertmanager).</span></span><br><span class="line"><span class="attr">  external_labels:</span></span><br><span class="line"><span class="attr">      monitor:</span> <span class="string">'codelab-monitor'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Load and evaluate rules in this file every 'evaluation_interval' seconds.</span></span><br><span class="line"><span class="attr">rule_files:</span></span><br><span class="line">  <span class="comment"># - "first.rules"</span></span><br><span class="line">  <span class="comment"># - "second.rules"</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">"alert.rules"</span></span><br><span class="line">  <span class="comment"># - "record.rules"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A scrape configuration containing exactly one endpoint to scrape:</span></span><br><span class="line"><span class="comment"># Here it's Prometheus itself.</span></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="comment"># The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.</span></span><br><span class="line"><span class="attr">  - job_name:</span> <span class="string">'windows-test'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Override the global default and scrape targets from this job every 5 seconds.</span></span><br><span class="line"><span class="attr">    scrape_interval:</span> <span class="number">1</span><span class="string">s</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># metrics_path defaults to '/metrics'</span></span><br><span class="line">    <span class="comment"># scheme defaults to 'http'.</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    static_configs:</span></span><br><span class="line"><span class="attr">      - targets:</span> <span class="string">['192.168.3.1:9090','192.168.3.120:9090']</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  - job_name:</span> <span class="string">'windows-chenx'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Override the global default and scrape targets from this job every 5 seconds.</span></span><br><span class="line"><span class="attr">    scrape_interval:</span> <span class="number">3</span><span class="string">s</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># metrics_path defaults to '/metrics'</span></span><br><span class="line">    <span class="comment"># scheme defaults to 'http'.</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    static_configs:</span></span><br><span class="line"><span class="attr">      - targets:</span> <span class="string">['192.168.3.1:9091']</span></span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>global下的scrape_interval<br>用于向pushgateway采集数据的频率，上图所示：每隔15秒向pushgateway采集一次指标数据</li><li>global下的evaluation_interval<br>表示规则计算的频率，上图所示：每隔15秒根据所配置的规则集，进行规则计算</li><li>global下的external_labels<br>为指标增加额外的维度，可用于区分不同的prometheus,在应用中多个prometheus可以对应一个alertmanager</li><li>rule_files<br>指定所配置规则文件，文件中每行可表示一个规则</li><li>scrape_configs下的job_name<br>指定任务名称，在指标中会增加该维度，表示该指标所属的job</li><li>scrape_configs下的scrape_interval<br>覆盖global下的scrape_interval配置</li><li>static_configs下的targets<br>指定指标数据源的地址，多个地址之间用逗号隔开</li></ul><h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><h3 id="告警路由"><a href="#告警路由" class="headerlink" title="告警路由"></a>告警路由</h3><p>路由字段即route的配置他控制了告警的聚合以及发送频率，route字段本身是一个树状的，每一个节点是一个配置，配置包括了接收人、match字段以及相应的告警发送配置例如：首次聚合时间、告警后续发送频率。对于到达的告警会收心进行match，如果有一个节点match并且该节点的continue字段为true，那么会继续递归遍历它的子节点，直到到达最后一个，这样就把匹配到同一个节点的告警经过group_by字段的分类，放置在不同的<strong>簇</strong>里面，这样就完成了告警的聚合功能。</p><p>这里有一点需要着重指出的一点是，对于每个簇，有三个字段影响了告警发送的频率，<strong>group_wait、group_interval、repeat_interval</strong>。</p><p>group_wait:当告警A第一次到达之后由于之前并没有告警簇，此时会进行创建，创建完之后会等待group_wait时间之后才会进行发送，这是为什么呢？这其实是为了解决告警风暴的问题，例如当服务集群a发生了告警，例如有10条，如果他们在group_wait这段时间内相继到达，那么最终他们就会被合并成一条告警进行发送。而不是收到10次告警信息。</p><p>group_interval:控制的是遍历告警簇的时间间隔，am当中当有新的告警到达时（之前没有进行过发生的告警）会进行告警簇的发送或者当检测到上次告警发送时间距离当前时间已经大于<strong>repeat_interval</strong>那么此时会进行发送。</p><p>路由配置格式</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#报警接收器</span></span><br><span class="line"><span class="string">[</span> <span class="attr">receiver:</span> <span class="string">&lt;string&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#分组</span></span><br><span class="line"><span class="string">[</span> <span class="attr">group_by:</span> <span class="string">'['</span> <span class="string">&lt;labelname&gt;,</span> <span class="string">...</span> <span class="string">']'</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Whether an alert should continue matching subsequent sibling nodes.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">continue:</span> <span class="string">&lt;boolean&gt;</span> <span class="string">| default = false ]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># A set of equality matchers an alert has to fulfill to match the node.</span></span><br><span class="line"><span class="string">#根据匹配的警报，指定接收器</span></span><br><span class="line"><span class="string"></span><span class="attr">match:</span></span><br><span class="line">  <span class="string">[</span> <span class="string">&lt;labelname&gt;:</span> <span class="string">&lt;labelvalue&gt;,</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A set of regex-matchers an alert has to fulfill to match the node.</span></span><br><span class="line"><span class="attr">match_re:</span></span><br><span class="line"><span class="comment">#根据匹配正则符合的警告，指定接收器</span></span><br><span class="line">  <span class="string">[</span> <span class="string">&lt;labelname&gt;:</span> <span class="string">&lt;regex&gt;,</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># How long to initially wait to send a notification for a group</span></span><br><span class="line"><span class="comment"># of alerts. Allows to wait for an inhibiting alert to arrive or collect</span></span><br><span class="line"><span class="comment"># more initial alerts for the same group. (Usually ~0s to few minutes.)</span></span><br><span class="line"><span class="string">[</span> <span class="attr">group_wait:</span> <span class="string">&lt;duration&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># How long to wait before sending notification about new alerts that are</span></span><br><span class="line"><span class="comment"># in are added to a group of alerts for which an initial notification</span></span><br><span class="line"><span class="comment"># has already been sent. (Usually ~5min or more.)</span></span><br><span class="line"><span class="string">[</span> <span class="attr">group_interval:</span> <span class="string">&lt;duration&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># How long to wait before sending a notification again if it has already</span></span><br><span class="line"><span class="comment"># been sent successfully for an alert. (Usually ~3h or more).</span></span><br><span class="line"><span class="string">[</span> <span class="attr">repeat_interval:</span> <span class="string">&lt;duration&gt;</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Zero or more child routes.</span></span><br><span class="line"><span class="attr">routes:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;route&gt;</span> <span class="string">...</span> <span class="string">]</span></span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The root route with all parameters, which are inherited by the child</span></span><br><span class="line"><span class="comment"># routes if they are not overwritten.</span></span><br><span class="line"><span class="attr">route:</span></span><br><span class="line"><span class="attr">  receiver:</span> <span class="string">'default-receiver'</span></span><br><span class="line"><span class="attr">  group_wait:</span> <span class="number">30</span><span class="string">s</span></span><br><span class="line"><span class="attr">  group_interval:</span> <span class="number">5</span><span class="string">m</span></span><br><span class="line"><span class="attr">  repeat_interval:</span> <span class="number">4</span><span class="string">h</span></span><br><span class="line"><span class="attr">  group_by:</span> <span class="string">[cluster,</span> <span class="string">alertname]</span></span><br><span class="line">  <span class="comment"># All alerts that do not match the following child routes</span></span><br><span class="line">  <span class="comment"># will remain at the root node and be dispatched to 'default-receiver'.</span></span><br><span class="line"><span class="attr">  routes:</span></span><br><span class="line">  <span class="comment"># All alerts with service=mysql or service=cassandra</span></span><br><span class="line">  <span class="comment"># are dispatched to the database pager.</span></span><br><span class="line"><span class="attr">  - receiver:</span> <span class="string">'database-pager'</span></span><br><span class="line"><span class="attr">    group_wait:</span> <span class="number">10</span><span class="string">s</span></span><br><span class="line"><span class="attr">    match_re:</span></span><br><span class="line"><span class="attr">      service:</span> <span class="string">mysql|cassandra</span></span><br><span class="line">  <span class="comment"># All alerts with the team=frontend label match this sub-route.</span></span><br><span class="line">  <span class="comment"># They are grouped by product and environment rather than cluster</span></span><br><span class="line">  <span class="comment"># and alertname.</span></span><br><span class="line"><span class="attr">  - receiver:</span> <span class="string">'frontend-pager'</span></span><br><span class="line"><span class="attr">    group_by:</span> <span class="string">[product,</span> <span class="string">environment]</span></span><br><span class="line"><span class="attr">    match:</span></span><br><span class="line"><span class="attr">      team:</span> <span class="string">frontend</span></span><br></pre></td></tr></table></figure><h3 id="告警聚合"><a href="#告警聚合" class="headerlink" title="告警聚合"></a>告警聚合</h3><p>告警聚合是非常重要的一个功能，好的聚合可以极大的减少告警风暴。</p><p>告警聚合在路由之后，每个路由节点可以配置自己的独特的聚合labels，比如按产品、集群、team等聚合。</p><p>例如上述示例，只按产品聚合，那么所有属于产品tcs的告警将与该告警一起聚合，所有属于产品tcs的告警都会放到一起，这种比较杂乱；如果按产品和类型聚合，那么属于不同机器的告警将分别聚合。</p><h3 id="告警抑制"><a href="#告警抑制" class="headerlink" title="告警抑制"></a>告警抑制</h3><p>告警抑制是指高等级告警发生时，自动抑制低等级的告警发送，同时当高等级告警恢复是，放开对低等级的抑制，常见场景是磁盘满80%警告告警通知，90%发送严重告警通知。</p><p>告警抑制的实现也是基于labels，但是是基于全局的，不是特定路由，而且只支持静态label，这个地方的设计其实不太好，有两个问题：</p><ol><li>全局容易出现不同用户的规则互相影响，为了减少此种行为的发生，我们应该为每个路由设定一个抑制规则，同时必须包含路由的labels</li><li>静态label对label规范化增加了不必要的限制，所有数据都必须拥有指定的抑制labels才能使用</li></ol><h3 id="告警屏蔽"><a href="#告警屏蔽" class="headerlink" title="告警屏蔽"></a>告警屏蔽</h3><p>告警屏蔽和告警抑制有点类似，但不一样，告警屏蔽是直接屏蔽报警，不再发送，不同报警之间无关联（告警抑制是高等级告警抑制低等级告警）。告警屏蔽也是基于labels，当告警中包含的labels满足(match)配置的屏蔽labels，就会发生屏蔽，不再发送告警。</p><p>原生的alertmanger屏蔽会直接在内存中屏蔽告警，无法记录到底哪些告警被屏蔽了，而且一旦屏蔽，及时报警恢复也不会发送通知，一旦设定，只能等屏蔽过期或者手工删除。</p><p>370对记录告警是个强需求，我们改造了alertmanager，让被屏蔽的告警也能继续发出来，但会加一个特殊的标记，这样我们就可以记录被屏蔽告警的信息，也可以捕获恢复。</p><p>抑制配置格式</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Matchers that have to be fulfilled in the alerts to be muted.</span></span><br><span class="line"><span class="comment">##必须在要需要静音的警报中履行的匹配者</span></span><br><span class="line"><span class="attr">target_match:</span></span><br><span class="line">  <span class="string">[</span> <span class="string">&lt;labelname&gt;:</span> <span class="string">&lt;labelvalue&gt;,</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"><span class="attr">target_match_re:</span></span><br><span class="line">  <span class="string">[</span> <span class="string">&lt;labelname&gt;:</span> <span class="string">&lt;regex&gt;,</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Matchers for which one or more alerts have to exist for the</span></span><br><span class="line"><span class="comment"># inhibition to take effect.</span></span><br><span class="line"><span class="comment">#必须存在一个或多个警报以使抑制生效的匹配者。</span></span><br><span class="line"><span class="attr">source_match:</span></span><br><span class="line">  <span class="string">[</span> <span class="string">&lt;labelname&gt;:</span> <span class="string">&lt;labelvalue&gt;,</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"><span class="attr">source_match_re:</span></span><br><span class="line">  <span class="string">[</span> <span class="string">&lt;labelname&gt;:</span> <span class="string">&lt;regex&gt;,</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Labels that must have an equal value in the source and target</span></span><br><span class="line"><span class="comment"># alert for the inhibition to take effect.</span></span><br><span class="line"><span class="comment">#在源和目标警报中必须具有相等值的标签才能使抑制生效</span></span><br><span class="line"><span class="string">[</span> <span class="attr">equal:</span> <span class="string">'['</span> <span class="string">&lt;labelname&gt;,</span> <span class="string">...</span> <span class="string">']'</span> <span class="string">]</span></span><br></pre></td></tr></table></figure><h3 id="告警发送"><a href="#告警发送" class="headerlink" title="告警发送"></a>告警发送</h3><p>告警发送是告警系统的最后一个处理点，也是众口难调的一个点，目前支持常见的第三方组件，但都不好用，且无法定制，一般都会基于webhook设计适合公司的发送能力。</p><p>通用配置格式</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The unique name of the receiver.</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">&lt;string&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Configurations for several notification integrations.</span></span><br><span class="line"><span class="attr">email_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;email_config&gt;,</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"><span class="attr">pagerduty_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;pagerduty_config&gt;,</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"><span class="attr">slack_config:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;slack_config&gt;,</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"><span class="attr">opsgenie_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;opsgenie_config&gt;,</span> <span class="string">...</span> <span class="string">]</span></span><br><span class="line"><span class="attr">webhook_configs:</span></span><br><span class="line">  <span class="string">[</span> <span class="bullet">-</span> <span class="string">&lt;webhook_config&gt;,</span> <span class="string">...</span> <span class="string">]</span></span><br></pre></td></tr></table></figure><p>邮件接收器email_config</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Whether or not to notify about resolved alerts.</span></span><br><span class="line"><span class="comment">#警报被解决之后是否通知</span></span><br><span class="line"><span class="string">[</span> <span class="attr">send_resolved:</span> <span class="string">&lt;boolean&gt;</span> <span class="string">| default = false ]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># The email address to send notifications to.</span></span><br><span class="line"><span class="string"></span><span class="attr">to:</span> <span class="string">&lt;tmpl_string&gt;</span></span><br><span class="line"><span class="comment"># The sender address.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">from:</span> <span class="string">&lt;tmpl_string&gt;</span> <span class="string">| default = global.smtp_from ]</span></span><br><span class="line"><span class="string"># The SMTP host through which emails are sent.</span></span><br><span class="line"><span class="string">[ smarthost: &lt;string&gt; | default = global.smtp_smarthost ]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># The HTML body of the email notification.</span></span><br><span class="line"><span class="string">[ html: &lt;tmpl_string&gt; | default = '<span class="template-variable">&#123;&#123; template "email.default.html" . &#125;&#125;</span>' ] </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># Further headers email header key/value pairs. Overrides any headers</span></span><br><span class="line"><span class="string"># previously set by the notification implementation.</span></span><br><span class="line"><span class="string">[ headers: &#123; &lt;string&gt;: &lt;tmpl_string&gt;, ... &#125; ]</span></span><br></pre></td></tr></table></figure><p>Slcack接收器slack_config</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Whether or not to notify about resolved alerts.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">send_resolved:</span> <span class="string">&lt;boolean&gt;</span> <span class="string">| default = true ]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># The Slack webhook URL.</span></span><br><span class="line"><span class="string">[ api_url: &lt;string&gt; | default = global.slack_api_url ]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># The channel or user to send notifications to.</span></span><br><span class="line"><span class="string"></span><span class="attr">channel:</span> <span class="string">&lt;tmpl_string&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># API request data as defined by the Slack webhook API.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">color:</span> <span class="string">&lt;tmpl_string&gt;</span> <span class="string">| default = '<span class="template-variable">&#123;&#123; if eq .Status "firing" &#125;&#125;</span>danger<span class="template-variable">&#123;&#123; else &#125;&#125;</span>good<span class="template-variable">&#123;&#123; end &#125;&#125;</span>' ]</span></span><br><span class="line"><span class="string">[ username: &lt;tmpl_string&gt; | default = '<span class="template-variable">&#123;&#123; template "slack.default.username" . &#125;&#125;</span>'</span></span><br><span class="line"><span class="string">[ title: &lt;tmpl_string&gt; | default = '<span class="template-variable">&#123;&#123; template "slack.default.title" . &#125;&#125;</span>' ]</span></span><br><span class="line"><span class="string">[ title_link: &lt;tmpl_string&gt; | default = '<span class="template-variable">&#123;&#123; template "slack.default.titlelink" . &#125;&#125;</span>' ]</span></span><br><span class="line"><span class="string">[ pretext: &lt;tmpl_string&gt; | default = '<span class="template-variable">&#123;&#123; template "slack.default.pretext" . &#125;&#125;</span>' ]</span></span><br><span class="line"><span class="string">[ text: &lt;tmpl_string&gt; | default = '<span class="template-variable">&#123;&#123; template "slack.default.text" . &#125;&#125;</span>' ]</span></span><br><span class="line"><span class="string">[ fallback: &lt;tmpl_string&gt; | default = '<span class="template-variable">&#123;&#123; template "slack.default.fallback" . &#125;&#125;</span>' ]</span></span><br></pre></td></tr></table></figure><p>Webhook接收器webhook_config</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># Whether or not to notify about resolved alerts.</span></span><br><span class="line"><span class="string">[</span> <span class="attr">send_resolved:</span> <span class="string">&lt;boolean&gt;</span> <span class="string">| default = true ]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> # The endpoint to send HTTP POST requests to.</span></span><br><span class="line"><span class="string"></span><span class="attr">url:</span> <span class="string">&lt;string&gt;</span></span><br></pre></td></tr></table></figure><p>Alertmanager会使用以下的格式向配置端点发送HTTP POST请求：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"3"</span>,</span><br><span class="line">  <span class="attr">"groupKey"</span>: &lt;number&gt;     // key identifying the group of alerts (e.g. to deduplicate)</span><br><span class="line">  <span class="string">"status"</span>: <span class="string">"&lt;resolved|firing&gt;"</span>,</span><br><span class="line">  <span class="attr">"receiver"</span>: &lt;string&gt;,</span><br><span class="line">  <span class="attr">"groupLabels"</span>: &lt;object&gt;,</span><br><span class="line">  <span class="attr">"commonLabels"</span>: &lt;object&gt;,</span><br><span class="line">  <span class="attr">"commonAnnotations"</span>: &lt;object&gt;,</span><br><span class="line">  "externalURL": &lt;string&gt;,  // backling to the Alertmanager.</span><br><span class="line">  "alerts": [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"labels"</span>: &lt;object&gt;,</span><br><span class="line">      <span class="attr">"annotations"</span>: &lt;object&gt;,</span><br><span class="line">      <span class="attr">"startsAt"</span>: <span class="string">"&lt;rfc3339&gt;"</span>,</span><br><span class="line">      <span class="attr">"endsAt"</span>: <span class="string">"&lt;rfc3339&gt;"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以添加一个钉钉webhook，通过<a href="https://link.jianshu.com/?t=!https://open-doc.dingtalk.com/docs/doc.htm?spm=a219a.7629140.0.0.karFPe&amp;treeId=257&amp;articleId=105735&amp;docType=1" target="_blank" rel="external">钉钉报警</a>,由于POST数据需要有要求，简单实现一个数据转发脚本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/',methods=['POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        post_data = request.get_data()</span><br><span class="line">        alert_data(post_data)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alert_data</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">from</span> urllib2 <span class="keyword">import</span> Request,urlopen</span><br><span class="line">    url = <span class="string">'https://oapi.dingtalk.com/robot/send?access_token=xxxx'</span></span><br><span class="line">    send_data = <span class="string">'&#123;"msgtype": "text","text": &#123;"content": %s&#125;&#125;'</span> %(data)</span><br><span class="line">    request = Request(url, send_data)</span><br><span class="line">    request.add_header(<span class="string">'Content-Type'</span>,<span class="string">'application/json'</span>)</span><br><span class="line">    <span class="keyword">return</span> urlopen(request).read()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(host=<span class="string">'0.0.0.0'</span>)</span><br></pre></td></tr></table></figure><h3 id="报警规则"><a href="#报警规则" class="headerlink" title="报警规则"></a>报警规则</h3><p>报警规则允许你定义基于Prometheus<a href="https://link.jianshu.com/?t=!https://prometheus.io/docs/querying/basics/" target="_blank" rel="external">表达式语言</a>的报警条件，并发送报警通知到外部服务</p><p>报警规则通过以下格式定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ALERT &lt;alert name&gt;</span><br><span class="line">  IF &lt;expression&gt;</span><br><span class="line">  [ FOR &lt;duration&gt; ]</span><br><span class="line">  [ LABELS &lt;label set&gt; ]</span><br><span class="line">  [ ANNOTATIONS &lt;label set&gt; ]</span><br></pre></td></tr></table></figure><p>可选的FOR语句，使得Prometheus在表达式输出的向量元素（例如高HTTP错误率的实例）之间等待一段时间，将警报计数作为触发此元素。如果元素是active，但是没有firing的，就处于pending状态。</p><p>LABELS（标签）语句允许指定一组标签附加警报上。将覆盖现有冲突的任何标签，标签值也可以被模板化。</p><p>ANNOTATIONS（注释）它们被用于存储更长的其他信息，例如警报描述或者链接，注释值也可以被模板化。</p><p>Templating(模板) 标签和注释值可以使用<a href="https://link.jianshu.com?t=!https://prometheus.io/docs/visualization/consoles/" target="_blank" rel="external">控制台模板</a>进行模板化。$labels变量保存警报实例的标签键/值对，$value保存警报实例的评估值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># To insert a firing element&apos;s label values:</span><br><span class="line">&#123;&#123; $labels.&lt;labelname&gt; &#125;&#125;</span><br><span class="line"># To insert the numeric expression value of the firing element:</span><br><span class="line">&#123;&#123; $value &#125;&#125;</span><br></pre></td></tr></table></figure><p>报警规则示例:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Alert for any instance that is unreachable for &gt;5 minutes.</span></span><br><span class="line"><span class="string">ALERT</span> <span class="string">InstanceDown</span></span><br><span class="line">  <span class="string">IF</span> <span class="string">up</span> <span class="string">==</span> <span class="number">0</span></span><br><span class="line">  <span class="string">FOR</span> <span class="number">5</span><span class="string">m</span></span><br><span class="line">  <span class="string">LABELS</span> <span class="string">&#123;</span> <span class="string">severity</span> <span class="string">=</span> <span class="string">"page"</span> <span class="string">&#125;</span></span><br><span class="line">  <span class="string">ANNOTATIONS</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">summary</span> <span class="string">=</span> <span class="string">"Instance <span class="template-variable">&#123;&#123; $labels.instance &#125;&#125;</span> down"</span><span class="string">,</span></span><br><span class="line">    <span class="string">description</span> <span class="string">=</span> <span class="string">"<span class="template-variable">&#123;&#123; $labels.instance &#125;&#125;</span> of job <span class="template-variable">&#123;&#123; $labels.job &#125;&#125;</span> has been down for more than 5 minutes."</span><span class="string">,</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Alert for any instance that have a median request latency &gt;1s.</span></span><br><span class="line"><span class="string">ALERT</span> <span class="string">APIHighRequestLatency</span></span><br><span class="line">  <span class="string">IF</span> <span class="string">api_http_request_latencies_second&#123;quantile="0.5"&#125;</span> <span class="string">&gt; 1</span></span><br><span class="line"><span class="string">  FOR 1m</span></span><br><span class="line"><span class="string">  ANNOTATIONS &#123;</span></span><br><span class="line"><span class="string">    summary = "High request latency on <span class="template-variable">&#123;&#123; $labels.instance &#125;&#125;</span>",</span></span><br><span class="line"><span class="string">    description = "<span class="template-variable">&#123;&#123; $labels.instance &#125;&#125;</span> has a median request latency above 1s (current value: <span class="template-variable">&#123;&#123; $value &#125;&#125;</span>s)",</span></span><br><span class="line"><span class="string">  &#125;</span></span><br></pre></td></tr></table></figure><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>alertmanager/cmd/alertmanager/main.go</p><h3 id="服务启动"><a href="#服务启动" class="headerlink" title="服务启动"></a>服务启动</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 程序入口main函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">os.Exit(run())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// run函数，真实的程序主函数。初始化，并开启相应的服务。阻塞监听reload和关闭信号，会进行平滑退出。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化集群，可高可用</span></span><br><span class="line"><span class="keyword">var</span> peer *cluster.Peer</span><br><span class="line"><span class="keyword">if</span> *clusterBindAddr != <span class="string">""</span> &#123;</span><br><span class="line">peer, err = cluster.Create(</span><br><span class="line">log.With(logger, <span class="string">"component"</span>, <span class="string">"cluster"</span>),</span><br><span class="line">prometheus.DefaultRegisterer,</span><br><span class="line">*clusterBindAddr,</span><br><span class="line">*clusterAdvertiseAddr,</span><br><span class="line">*peers,</span><br><span class="line"><span class="literal">true</span>,</span><br><span class="line">*pushPullInterval,</span><br><span class="line">*gossipInterval,</span><br><span class="line">*tcpTimeout,</span><br><span class="line">*probeTimeout,</span><br><span class="line">*probeInterval,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">level.Error(logger).Log(<span class="string">"msg"</span>, <span class="string">"unable to initialize gossip mesh"</span>, <span class="string">"err"</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置普罗米修斯集群指标，为已启用</span></span><br><span class="line">clusterEnabled.Set(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置 stop channel 和 等待组，确保优雅退出</span></span><br><span class="line">stopc := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 配置集群广播日志信息配置，并配置广播？？？</span></span><br><span class="line">notificationLogOpts := []nflog.Option&#123;</span><br><span class="line">nflog.WithRetention(*retention),</span><br><span class="line">nflog.WithSnapshot(filepath.Join(*dataDir, <span class="string">"nflog"</span>)),</span><br><span class="line">nflog.WithMaintenance(<span class="number">15</span>*time.Minute, stopc, wg.Done),</span><br><span class="line">nflog.WithMetrics(prometheus.DefaultRegisterer),</span><br><span class="line">nflog.WithLogger(log.With(logger, <span class="string">"component"</span>, <span class="string">"nflog"</span>)),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">notificationLog, err := nflog.New(notificationLogOpts...)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">level.Error(logger).Log(<span class="string">"err"</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> peer != <span class="literal">nil</span> &#123;</span><br><span class="line">c := peer.AddState(<span class="string">"nfl"</span>, notificationLog, prometheus.DefaultRegisterer)</span><br><span class="line">notificationLog.SetBroadcast(c.Broadcast)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">marker := types.NewMarker(prometheus.DefaultRegisterer)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静默配置，并生成静默对象，如果有配置集群，则设置集群广播。</span></span><br><span class="line">silenceOpts := silence.Options&#123;</span><br><span class="line">SnapshotFile: filepath.Join(*dataDir, <span class="string">"silences"</span>),</span><br><span class="line">Retention:    *retention,</span><br><span class="line">Logger:       log.With(logger, <span class="string">"component"</span>, <span class="string">"silences"</span>),</span><br><span class="line">Metrics:      prometheus.DefaultRegisterer,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">silences, err := silence.New(silenceOpts)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">level.Error(logger).Log(<span class="string">"err"</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> peer != <span class="literal">nil</span> &#123;</span><br><span class="line">c := peer.AddState(<span class="string">"sil"</span>, silences, prometheus.DefaultRegisterer)</span><br><span class="line">silences.SetBroadcast(c.Broadcast)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start providers before router potentially sends updates.</span></span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 维护静默产生的data数据，每十五分钟进行下数据删除。</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">silences.Maintenance(<span class="number">15</span>*time.Minute, filepath.Join(*dataDir, <span class="string">"silences"</span>), stopc)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// defer wg.Wait 确保最后所有的任务都优雅退出之后，才会程序退出。</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">close</span>(stopc)</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 集群peer的状态监听器已经进行注册成功，现在可以进行加入集群和初始化状态。</span></span><br><span class="line"><span class="comment">// Peer state listeners have been registered, now we can join and get the initial state.</span></span><br><span class="line"><span class="keyword">if</span> peer != <span class="literal">nil</span> &#123;</span><br><span class="line">err = peer.Join(</span><br><span class="line">*reconnectInterval,</span><br><span class="line">*peerReconnectTimeout,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">level.Warn(logger).Log(<span class="string">"msg"</span>, <span class="string">"unable to join gossip mesh"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), *settleTimeout)</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">cancel()</span><br><span class="line"><span class="keyword">if</span> err := peer.Leave(<span class="number">10</span> * time.Second); err != <span class="literal">nil</span> &#123;</span><br><span class="line">level.Warn(logger).Log(<span class="string">"msg"</span>, <span class="string">"unable to leave gossip mesh"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">go</span> peer.Settle(ctx, *gossipInterval*<span class="number">10</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建监控对象</span></span><br><span class="line">alerts, err := mem.NewAlerts(context.Background(), marker, *alertGCInterval, logger)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">level.Error(logger).Log(<span class="string">"err"</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> alerts.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> disp *dispatch.Dispatcher</span><br><span class="line"><span class="keyword">defer</span> disp.Stop()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建分组方法</span></span><br><span class="line">groupFn := <span class="function"><span class="keyword">func</span><span class="params">(routeFilter <span class="keyword">func</span>(*dispatch.Route)</span> <span class="title">bool</span>, <span class="title">alertFilter</span> <span class="title">func</span><span class="params">(*types.Alert, time.Time)</span> <span class="title">bool</span>) <span class="params">(dispatch.AlertGroups, <span class="keyword">map</span>[model.Fingerprint][]<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> disp.Groups(routeFilter, alertFilter)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// alertmanager api结构体，包含所有版本V1,V2的http接口。</span></span><br><span class="line">api, err := api.New(api.Options&#123;</span><br><span class="line">Alerts:      alerts,</span><br><span class="line">Silences:    silences,</span><br><span class="line">StatusFunc:  marker.Status,</span><br><span class="line">Peer:        peer,</span><br><span class="line">Timeout:     *httpTimeout,</span><br><span class="line">Concurrency: *getConcurrency,</span><br><span class="line">Logger:      log.With(logger, <span class="string">"component"</span>, <span class="string">"api"</span>),</span><br><span class="line">Registry:    prometheus.DefaultRegisterer,</span><br><span class="line">GroupFunc:   groupFn,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">level.Error(logger).Log(<span class="string">"err"</span>, errors.Wrap(err, <span class="string">"failed to create API"</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">amURL, err := extURL(logger, os.Hostname, *listenAddress, *externalURL)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">level.Error(logger).Log(<span class="string">"msg"</span>, <span class="string">"failed to determine external URL"</span>, <span class="string">"err"</span>, err)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">level.Debug(logger).Log(<span class="string">"externalURL"</span>, amURL.String())</span><br><span class="line"></span><br><span class="line">waitFunc := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line"><span class="keyword">if</span> peer != <span class="literal">nil</span> &#123;</span><br><span class="line">waitFunc = clusterWait(peer, *peerTimeout)</span><br><span class="line">&#125;</span><br><span class="line">timeoutFunc := <span class="function"><span class="keyword">func</span><span class="params">(d time.Duration)</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> d &lt; notify.MinTimeout &#123;</span><br><span class="line">d = notify.MinTimeout</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d + waitFunc()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">inhibitor *inhibit.Inhibitor</span><br><span class="line">tmpl      *template.Template</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建普罗米修斯相关统计指标，创建配置协调者。</span></span><br><span class="line">dispMetrics := dispatch.NewDispatcherMetrics(prometheus.DefaultRegisterer)</span><br><span class="line">pipelineBuilder := notify.NewPipelineBuilder(prometheus.DefaultRegisterer)</span><br><span class="line">configLogger := log.With(logger, <span class="string">"component"</span>, <span class="string">"configuration"</span>)</span><br><span class="line">configCoordinator := config.NewCoordinator(</span><br><span class="line">*configFile,</span><br><span class="line">prometheus.DefaultRegisterer,</span><br><span class="line">configLogger,</span><br><span class="line">)</span><br><span class="line">configCoordinator.Subscribe(<span class="function"><span class="keyword">func</span><span class="params">(conf *config.Config)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">tmpl, err = template.FromGlobs(conf.Templates...)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.Wrap(err, <span class="string">"failed to parse templates"</span>)</span><br><span class="line">&#125;</span><br><span class="line">tmpl.ExternalURL = amURL</span><br><span class="line"></span><br><span class="line"><span class="comment">// Build the routing tree and record which receivers are used.</span></span><br><span class="line"><span class="comment">// ------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 建立路由树和记录下被使用的接收人</span></span><br><span class="line">routes := dispatch.NewRoute(conf.Route, <span class="literal">nil</span>)</span><br><span class="line">activeReceivers := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">routes.Walk(<span class="function"><span class="keyword">func</span><span class="params">(r *dispatch.Route)</span></span> &#123;</span><br><span class="line">activeReceivers[r.RouteOpts.Receiver] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Build the map of receiver to integrations.</span></span><br><span class="line">receivers := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]notify.Integration, <span class="built_in">len</span>(activeReceivers))</span><br><span class="line"><span class="keyword">var</span> integrationsNum <span class="keyword">int</span></span><br><span class="line"><span class="comment">// 循环加载所有配置中的接受消息人</span></span><br><span class="line"><span class="keyword">for</span> _, rcv := <span class="keyword">range</span> conf.Receivers &#123;</span><br><span class="line"><span class="comment">// 查看此接受消息人，没有任何route在使用，则进行记录和丢弃，然后开始下一轮。</span></span><br><span class="line"><span class="keyword">if</span> _, found := activeReceivers[rcv.Name]; !found &#123;</span><br><span class="line"><span class="comment">// No need to build a receiver if no route is using it.</span></span><br><span class="line">level.Info(configLogger).Log(<span class="string">"msg"</span>, <span class="string">"skipping creation of receiver not referenced by any route"</span>, <span class="string">"receiver"</span>, rcv.Name)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建接收人的integration，并插入到receiver map中。</span></span><br><span class="line">integrations, err := buildReceiverIntegrations(rcv, tmpl, logger)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// rcv.Name is guaranteed to be unique across all receivers.</span></span><br><span class="line">receivers[rcv.Name] = integrations</span><br><span class="line">integrationsNum += <span class="built_in">len</span>(integrations)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止抑制器和调度器</span></span><br><span class="line">inhibitor.Stop()</span><br><span class="line">disp.Stop()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建静默，抑制器并放到pipeline里面，pipeline包含告警处理的每一个stage。</span></span><br><span class="line">inhibitor = inhibit.NewInhibitor(alerts, conf.InhibitRules, marker, logger)</span><br><span class="line">silencer := silence.NewSilencer(silences, marker, logger)</span><br><span class="line">pipeline := pipelineBuilder.New(</span><br><span class="line">receivers,</span><br><span class="line">waitFunc,</span><br><span class="line">inhibitor,</span><br><span class="line">silencer,</span><br><span class="line">notificationLog,</span><br><span class="line">peer,</span><br><span class="line">)</span><br><span class="line">configuredReceivers.Set(<span class="keyword">float64</span>(<span class="built_in">len</span>(activeReceivers)))</span><br><span class="line">configuredIntegrations.Set(<span class="keyword">float64</span>(integrationsNum))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新api的抑制和静默数据</span></span><br><span class="line">api.Update(conf, <span class="function"><span class="keyword">func</span><span class="params">(labels model.LabelSet)</span></span> &#123;</span><br><span class="line">inhibitor.Mutes(labels)</span><br><span class="line">silencer.Mutes(labels)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建alertmanager调度器</span></span><br><span class="line">disp = dispatch.NewDispatcher(alerts, routes, pipeline, marker, timeoutFunc, logger, dispMetrics)</span><br><span class="line">routes.Walk(<span class="function"><span class="keyword">func</span><span class="params">(r *dispatch.Route)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r.RouteOpts.RepeatInterval &gt; *retention &#123;</span><br><span class="line">level.Warn(configLogger).Log(</span><br><span class="line"><span class="string">"msg"</span>,</span><br><span class="line"><span class="string">"repeat_interval is greater than the data retention period. It can lead to notifications being repeated more often than expected."</span>,</span><br><span class="line"><span class="string">"repeat_interval"</span>,</span><br><span class="line">r.RouteOpts.RepeatInterval,</span><br><span class="line"><span class="string">"retention"</span>,</span><br><span class="line">*retention,</span><br><span class="line"><span class="string">"route"</span>,</span><br><span class="line">r.Key(),</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 独立协成去运行调度器和抑制器</span></span><br><span class="line"><span class="keyword">go</span> disp.Run()</span><br><span class="line"><span class="keyword">go</span> inhibitor.Run()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := configCoordinator.Reload(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make routePrefix default to externalURL path if empty string.</span></span><br><span class="line"><span class="keyword">if</span> *routePrefix == <span class="string">""</span> &#123;</span><br><span class="line">*routePrefix = amURL.Path</span><br><span class="line">&#125;</span><br><span class="line">*routePrefix = <span class="string">"/"</span> + strings.Trim(*routePrefix, <span class="string">"/"</span>)</span><br><span class="line">level.Debug(logger).Log(<span class="string">"routePrefix"</span>, *routePrefix)</span><br><span class="line"></span><br><span class="line">router := route.New().WithInstrumentation(instrumentHandler)</span><br><span class="line"><span class="keyword">if</span> *routePrefix != <span class="string">"/"</span> &#123;</span><br><span class="line">router.Get(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">http.Redirect(w, r, *routePrefix, http.StatusFound)</span><br><span class="line">&#125;)</span><br><span class="line">router = router.WithPrefix(*routePrefix)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">webReload := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">chan</span> error)</span><br><span class="line"></span><br><span class="line">ui.Register(router, webReload, logger)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从api中获取Handler mux</span></span><br><span class="line">mux := api.Register(router, *routePrefix)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中大部分都有注释，基本都是一些初始化的操作，看下几个重要的点</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> disp.Run() <span class="comment">// 告警聚合</span></span><br><span class="line"><span class="keyword">go</span> inhibitor.Run() <span class="comment">// 告警抑制</span></span><br><span class="line">mux := api.Register(router, *routePrefix) <span class="comment">// 告警api，包含接收告警和实现告警屏蔽</span></span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alertmanager/api/v1/api.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(api *API)</span> <span class="title">Register</span><span class="params">(r *route.Router)</span></span> &#123;</span><br><span class="line">wrap := <span class="function"><span class="keyword">func</span><span class="params">(f http.HandlerFunc)</span> <span class="title">http</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">setCORS(w)</span><br><span class="line">f(w, r)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r.Options(<span class="string">"/*path"</span>, wrap(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;&#125;))</span><br><span class="line"></span><br><span class="line">r.Get(<span class="string">"/status"</span>, wrap(api.status))</span><br><span class="line">r.Get(<span class="string">"/receivers"</span>, wrap(api.receivers))</span><br><span class="line"></span><br><span class="line">r.Get(<span class="string">"/alerts"</span>, wrap(api.listAlerts))</span><br><span class="line">r.Post(<span class="string">"/alerts"</span>, wrap(api.addAlerts)) <span class="comment">// 接收来自其余服务的告警（prometheus）</span></span><br><span class="line"></span><br><span class="line">r.Get(<span class="string">"/silences"</span>, wrap(api.listSilences)) </span><br><span class="line">r.Post(<span class="string">"/silences"</span>, wrap(api.setSilence)) <span class="comment">// 告警屏蔽</span></span><br><span class="line">r.Get(<span class="string">"/silence/:sid"</span>, wrap(api.getSilence))</span><br><span class="line">r.Del(<span class="string">"/silence/:sid"</span>, wrap(api.delSilence))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们每个模块单独分析，首先这里的api肯定是有服务调用才会运行，所以我们先不管这边，先看下初始化的时候，alertmanager都做了什么事情。</p><h3 id="告警聚合初始化"><a href="#告警聚合初始化" class="headerlink" title="告警聚合初始化"></a>告警聚合初始化</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go disp.Run()</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dispatcher)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 初始化结束通道</span></span><br><span class="line">d.done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">d.mtx.Lock()</span><br><span class="line">d.aggrGroups = <span class="keyword">map</span>[*Route]<span class="keyword">map</span>[model.Fingerprint]*aggrGroup&#123;&#125;</span><br><span class="line">d.metrics.aggrGroups.Set(<span class="number">0</span>)</span><br><span class="line">d.ctx, d.cancel = context.WithCancel(context.Background())</span><br><span class="line">d.mtx.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行调度器子运行函数</span></span><br><span class="line">d.run(d.alerts.Subscribe())</span><br><span class="line"><span class="built_in">close</span>(d.done)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dispatcher)</span> <span class="title">run</span><span class="params">(it provider.AlertIterator)</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建清理ticker，其负责每30秒，检查所有的告警分组。</span></span><br><span class="line">cleanup := time.NewTicker(<span class="number">30</span> * time.Second)</span><br><span class="line"><span class="keyword">defer</span> cleanup.Stop()</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> it.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="comment">// 收到告警事件</span></span><br><span class="line"><span class="keyword">case</span> alert, ok := &lt;-it.Next():</span><br><span class="line"><span class="comment">// 如果告警的通道被关闭，而且数据已经读取完毕，则返回。</span></span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="comment">// Iterator exhausted for some reason.</span></span><br><span class="line"><span class="comment">// ------------------------------------</span></span><br><span class="line"><span class="comment">// 记录下alert遍历器的错误</span></span><br><span class="line"><span class="keyword">if</span> err := it.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">level.Error(d.logger).Log(<span class="string">"msg"</span>, <span class="string">"Error on alert update"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">level.Debug(d.logger).Log(<span class="string">"msg"</span>, <span class="string">"Received alert"</span>, <span class="string">"alert"</span>, alert)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Log errors but keep trying.</span></span><br><span class="line"><span class="comment">// ----------------------------------</span></span><br><span class="line"><span class="comment">// 检查遍历器的错误，如果有错误则直接跳到下个循环</span></span><br><span class="line"><span class="keyword">if</span> err := it.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">level.Error(d.logger).Log(<span class="string">"msg"</span>, <span class="string">"Error on alert update"</span>, <span class="string">"err"</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据这个告警的所有label来匹配分组，对匹配上的路由和告警进行处理</span></span><br><span class="line">now := time.Now()</span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> d.route.Match(alert.Labels) &#123;</span><br><span class="line">d.processAlert(alert, r)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 记录处理这个告警的时间到普罗米修斯指标中</span></span><br><span class="line">d.metrics.processingDuration.Observe(time.Since(now).Seconds())</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> &lt;-cleanup.C: <span class="comment">// 清理周期</span></span><br><span class="line"><span class="comment">// 锁住调度器锁</span></span><br><span class="line">d.mtx.Lock()</span><br><span class="line"><span class="comment">// 循环分组列表，并查看每个分组下的唯一标识分组</span></span><br><span class="line"><span class="keyword">for</span> _, groups := <span class="keyword">range</span> d.aggrGroups &#123;</span><br><span class="line"><span class="keyword">for</span> _, ag := <span class="keyword">range</span> groups &#123;</span><br><span class="line"><span class="comment">// 如果这个唯一标识分组为空，终止并删除分组。</span></span><br><span class="line"><span class="comment">// 普罗米修斯计数-1</span></span><br><span class="line"><span class="keyword">if</span> ag.empty() &#123;</span><br><span class="line">ag.stop()</span><br><span class="line"><span class="built_in">delete</span>(groups, ag.fingerprint())</span><br><span class="line">d.metrics.aggrGroups.Dec()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d.mtx.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> &lt;-d.ctx.Done():</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到dispather起了一个run方法，调用Subscribe方法作为参数，在这里<code>case alert, ok := &lt;-it.Next()</code>等待告警事件，先不急分析Subscribe方法，我们再看下告警抑制</p><h3 id="告警抑制初始化"><a href="#告警抑制初始化" class="headerlink" title="告警抑制初始化"></a>告警抑制初始化</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go inhibitor.Run()</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ih *Inhibitor)</span> <span class="title">Run</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">g   run.Group</span><br><span class="line">ctx context.Context</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建context和cancel方法</span></span><br><span class="line">ih.mtx.Lock()</span><br><span class="line">ctx, ih.cancel = context.WithCancel(context.Background())</span><br><span class="line">ih.mtx.Unlock()</span><br><span class="line">runCtx, runCancel := context.WithCancel(ctx)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环每个抑制规则，然后启动独立go routine去运行垃圾回收</span></span><br><span class="line"><span class="keyword">for</span> _, rule := <span class="keyword">range</span> ih.rules &#123;</span><br><span class="line"><span class="keyword">go</span> rule.scache.Run(runCtx, <span class="number">15</span>*time.Minute)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加抑制方法到运行组，运行组并行运行。</span></span><br><span class="line"><span class="comment">// 在所有的方法退出时才会退出，</span></span><br><span class="line"><span class="comment">// 有错误时将返回第一个错误，一个return后，会中断其他方法。</span></span><br><span class="line">g.Add(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">ih.run(runCtx)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">func</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line">runCancel()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := g.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">level.Warn(ih.logger).Log(<span class="string">"msg"</span>, <span class="string">"error running inhibitor"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运行抑制器，会开始订阅告警。然后开始循环，如果订阅的告警遍历器里面有告警，</span></span><br><span class="line"><span class="comment">// 则获得告警，并循环每个抑制规则，如果匹配到</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ih *Inhibitor)</span> <span class="title">run</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 开始订阅告警</span></span><br><span class="line">it := ih.alerts.Subscribe()</span><br><span class="line"><span class="keyword">defer</span> it.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> a := &lt;-it.Next():</span><br><span class="line"><span class="comment">// 得到告警，</span></span><br><span class="line"><span class="keyword">if</span> err := it.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">level.Error(ih.logger).Log(<span class="string">"msg"</span>, <span class="string">"Error iterating alerts"</span>, <span class="string">"err"</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update the inhibition rules' cache.</span></span><br><span class="line"><span class="comment">// -----------------------------------------</span></span><br><span class="line"><span class="comment">// 循环每个抑制rule，假如当前告警匹配上某个source。</span></span><br><span class="line"><span class="comment">// 缓存这个告警到这个抑制rule的告警map里，map的key</span></span><br><span class="line"><span class="comment">// 为label的finger print，value为alert。</span></span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> ih.rules &#123;</span><br><span class="line"><span class="keyword">if</span> r.SourceMatchers.Match(a.Labels) &#123;</span><br><span class="line"><span class="keyword">if</span> err := r.scache.Set(a); err != <span class="literal">nil</span> &#123;</span><br><span class="line">level.Error(ih.logger).Log(<span class="string">"msg"</span>, <span class="string">"error on set alert"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里也是在<code>case a := &lt;-it.Next()</code>，与聚合逻辑是一致的，都是调用的Subscribe方法</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Alerts 接口负责装载告警对象，并且可以提供告警的遍历器，而且可以设置或可以通过告警</span></span><br><span class="line"><span class="comment">// 指纹获得告警。全部的方法，都是协成安全。</span></span><br><span class="line"><span class="keyword">type</span> Alerts <span class="keyword">interface</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subscribe returns an iterator over active alerts that have not been</span></span><br><span class="line"><span class="comment">// resolved and successfully notified about.</span></span><br><span class="line"><span class="comment">// They are not guaranteed to be in chronological order.</span></span><br><span class="line"><span class="comment">// --------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Subscribe 方法，返回一个告警遍历器接口。遍历器会返回还没有解决和还没有被成功</span></span><br><span class="line"><span class="comment">// 通知出来的告警。遍历器所返回的告警，并不能保证是按照时间顺序来进行排序的。</span></span><br><span class="line">Subscribe() AlertIterator</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetPending returns an iterator over all alerts that have</span></span><br><span class="line"><span class="comment">// pending notifications.</span></span><br><span class="line"><span class="comment">// --------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// GetPending 方法，返回一个告警遍历器接口。遍历器会返回在等待通知的告警。</span></span><br><span class="line">GetPending() AlertIterator</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get returns the alert for a given fingerprint.</span></span><br><span class="line"><span class="comment">// --------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Get 方法，通过告警的Label指纹，来获得Alert对象。Alert对象包含的信息，如</span></span><br><span class="line"><span class="comment">// 过期时间，更新时间，标签，告警开始时间等等。</span></span><br><span class="line">Get(model.Fingerprint) (*types.Alert, error)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Put adds the given alert to the set.</span></span><br><span class="line"><span class="comment">// --------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Put 方法，把零到多个告警，放入此告警集合里。</span></span><br><span class="line">Put(...*types.Alert) error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Subscribe 方法返回一个告警遍历器，里面包含全部活跃的告警（没有被解决或成功通知），</span></span><br><span class="line"><span class="comment">// 这个遍历器并不能保证告警是按照时间顺序排列的。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Alerts)</span> <span class="title">Subscribe</span><span class="params">()</span> <span class="title">provider</span>.<span class="title">AlertIterator</span></span> &#123;</span><br><span class="line">a.mtx.Lock()</span><br><span class="line"><span class="keyword">defer</span> a.mtx.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">done   = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">alerts = a.alerts.List()</span><br><span class="line">ch     = <span class="built_in">make</span>(<span class="keyword">chan</span> *types.Alert, max(<span class="built_in">len</span>(alerts), alertChannelLength))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, a := <span class="keyword">range</span> alerts &#123;</span><br><span class="line">ch &lt;- a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把新建告警channel，放入监听器存储到map里面。</span></span><br><span class="line">a.listeners[a.next] = listeningAlerts&#123;alerts: ch, done: done&#125;</span><br><span class="line">a.next++</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> provider.NewAlertIterator(ch, done, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里维护了一份map，<code>a.listeners[a.next] = listeningAlerts{alerts: ch, done: done}</code>，而上面的<code>it.Next()</code>是什么，其实就是<code>ch</code>。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewAlertIterator 返回一个 AlertIterator 接口对象，底层实现类型是通过 alertIterator 来实现。</span></span><br><span class="line"><span class="comment">// Golang典型的设计思维，实现类接口为私有类，通过实现接口的方式，暴露出公开方法。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAlertIterator</span><span class="params">(ch &lt;-<span class="keyword">chan</span> *types.Alert, done <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, err error)</span> <span class="title">AlertIterator</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;alertIterator&#123;</span><br><span class="line">ch:   ch,</span><br><span class="line">done: done,</span><br><span class="line">err:  err,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// alertIterator 实现了 AlertIterator 接口。以现在来说，这个实现满足现在所有providers的需求。</span></span><br><span class="line"><span class="comment">// 但是假如有新的需求，可以通过创建一个新的实现类，来实现 AlertIterator 接口，来让代码变得通用。</span></span><br><span class="line"><span class="keyword">type</span> alertIterator <span class="keyword">struct</span> &#123;</span><br><span class="line">ch   &lt;-<span class="keyword">chan</span> *types.Alert <span class="comment">// ch   元素用来遍历告警的队列。</span></span><br><span class="line">done <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;       <span class="comment">// done 是用来通知这个遍历器被关闭。</span></span><br><span class="line">err  error               <span class="comment">// err  用来存储是否有错误，当调用完 Next 方法后，需要拿到 err 判断是否有错误。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Next 方法，获取下一个告警。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ai alertIterator)</span> <span class="title">Next</span><span class="params">()</span> &lt;-<span class="title">chan</span> *<span class="title">types</span>.<span class="title">Alert</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> ai.ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Inhibitor和Dispatcher在初始化时会调用Subscribe()，然后一直监听并接收新的alerts</p><p>到这里就初始化完成了，因为刚开始没有告警产生，所以两个逻辑都在<code>case</code>中阻塞，下面分析一下api的逻辑</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(api *API)</span> <span class="title">addAlerts</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> alerts []*types.Alert</span><br><span class="line"><span class="keyword">if</span> err := api.receive(r, &amp;alerts); err != <span class="literal">nil</span> &#123;</span><br><span class="line">api.respondError(w, apiError&#123;</span><br><span class="line">typ: errorBadData,</span><br><span class="line">err: err,</span><br><span class="line">&#125;, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">api.insertAlerts(w, r, alerts...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(api *API)</span> <span class="title">insertAlerts</span><span class="params">(w http.ResponseWriter, r *http.Request, alerts ...*types.Alert)</span></span> &#123;</span><br><span class="line">now := time.Now()</span><br><span class="line"></span><br><span class="line">api.mtx.RLock()</span><br><span class="line">resolveTimeout := time.Duration(api.config.Global.ResolveTimeout)</span><br><span class="line">api.mtx.RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, alert := <span class="keyword">range</span> alerts &#123;</span><br><span class="line">alert.UpdatedAt = now</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ensure StartsAt is set.</span></span><br><span class="line"><span class="keyword">if</span> alert.StartsAt.IsZero() &#123;</span><br><span class="line"><span class="keyword">if</span> alert.EndsAt.IsZero() &#123;</span><br><span class="line">alert.StartsAt = now</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">alert.StartsAt = alert.EndsAt</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// If no end time is defined, set a timeout after which an alert</span></span><br><span class="line"><span class="comment">// is marked resolved if it is not updated.</span></span><br><span class="line"><span class="keyword">if</span> alert.EndsAt.IsZero() &#123;</span><br><span class="line">alert.Timeout = <span class="literal">true</span></span><br><span class="line">alert.EndsAt = now.Add(resolveTimeout)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> alert.EndsAt.After(time.Now()) &#123;</span><br><span class="line">api.m.Firing().Inc()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">api.m.Resolved().Inc()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make a best effort to insert all alerts that are valid.</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">validAlerts    = <span class="built_in">make</span>([]*types.Alert, <span class="number">0</span>, <span class="built_in">len</span>(alerts))</span><br><span class="line">validationErrs = &amp;types.MultiError&#123;&#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">for</span> _, a := <span class="keyword">range</span> alerts &#123;</span><br><span class="line">removeEmptyLabels(a.Labels)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := a.Validate(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">validationErrs.Add(err)</span><br><span class="line">api.m.Invalid().Inc()</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">validAlerts = <span class="built_in">append</span>(validAlerts, a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := api.alerts.Put(validAlerts...); err != <span class="literal">nil</span> &#123;</span><br><span class="line">api.respondError(w, apiError&#123;</span><br><span class="line">typ: errorInternal,</span><br><span class="line">err: err,</span><br><span class="line">&#125;, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> validationErrs.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">api.respondError(w, apiError&#123;</span><br><span class="line">typ: errorBadData,</span><br><span class="line">err: validationErrs,</span><br><span class="line">&#125;, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">api.respond(w, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到<code>60</code>行的<code>Put</code>方法</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Put 添加一到多个告警到告警集合里。并且通知到所有监听器里。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Alerts)</span> <span class="title">Put</span><span class="params">(alerts ...*types.Alert)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, alert := <span class="keyword">range</span> alerts &#123;</span><br><span class="line">fp := alert.Fingerprint()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check that there's an alert existing within the store before</span></span><br><span class="line"><span class="comment">// trying to merge.</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 检查是否已经有旧的告警了，如果有旧的告警，需要判断是否需要合并。</span></span><br><span class="line"><span class="keyword">if</span> old, err := a.alerts.Get(fp); err == <span class="literal">nil</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Merge alerts if there is an overlap in activity range.</span></span><br><span class="line"><span class="comment">// -----------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// 合并条件：判断是否新旧告警有重叠时间，如果有的话，就进行合并告警。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 条件1：新告警的结束时间大于旧的告警的开始时间，并且新告警结束时间在旧告警结束时间之前。</span></span><br><span class="line"><span class="comment">//        新告警   |----------|</span></span><br><span class="line"><span class="comment">//   旧告警     |-----------|       -&gt; 时间线</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 条件2：新告警的开始时间大于旧的告警的开始时间，并且新告警开始时间在旧告警结束时间之前。</span></span><br><span class="line"><span class="comment">//  新告警        |----------|</span></span><br><span class="line"><span class="comment">//  旧告警     |-----------|       -&gt; 时间线</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> (alert.EndsAt.After(old.StartsAt) &amp;&amp; alert.EndsAt.Before(old.EndsAt)) ||</span><br><span class="line">(alert.StartsAt.After(old.StartsAt) &amp;&amp; alert.StartsAt.Before(old.EndsAt)) &#123;</span><br><span class="line">alert = old.Merge(alert)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置告警到集合。</span></span><br><span class="line"><span class="keyword">if</span> err := a.alerts.Set(alert); err != <span class="literal">nil</span> &#123;</span><br><span class="line">level.Error(a.logger).Log(<span class="string">"msg"</span>, <span class="string">"error on set alert"</span>, <span class="string">"err"</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环塞到每个监听器，去通知到每一个监听者。</span></span><br><span class="line">a.mtx.Lock()</span><br><span class="line"><span class="keyword">for</span> _, l := <span class="keyword">range</span> a.listeners &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> l.alerts &lt;- alert:</span><br><span class="line"><span class="keyword">case</span> &lt;-l.done:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a.mtx.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里就是接收告警，然后将其塞到每个监听器，然后去通知每一个监听者去处理，即Inhibitor和Dispatcher会处理接收到的每个告警</p><p>下面看下处理流程</p><h3 id="告警聚合处理流程"><a href="#告警聚合处理流程" class="headerlink" title="告警聚合处理流程"></a>告警聚合处理流程</h3><p>根据上面的分析，聚合初始化之后，最终调用的是<code>processAlert</code>方法</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理告警，得到相应分组，并对相应的分组插入这个告警。</span></span><br><span class="line"><span class="comment">// @param alert 告警结构体</span></span><br><span class="line"><span class="comment">// @param route 已经匹配上的分组路由</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dispatcher)</span> <span class="title">processAlert</span><span class="params">(alert *types.Alert, route *Route)</span></span> &#123;</span><br><span class="line"><span class="comment">// 根据分组路由的信息，获得此分组下的匹配中的labels。</span></span><br><span class="line"><span class="comment">// 并根据所得labels得到唯一id(指纹 finger print)。</span></span><br><span class="line">groupLabels := getGroupLabels(alert, route)</span><br><span class="line">fp := groupLabels.Fingerprint()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加锁进行hashmap操作</span></span><br><span class="line">d.mtx.Lock()</span><br><span class="line"><span class="keyword">defer</span> d.mtx.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过分组路由获得分组map，如果分组列表hashmap不存在这个分组，</span></span><br><span class="line"><span class="comment">// 则进行创建。分组map里面key为分组finger print，value为具</span></span><br><span class="line"><span class="comment">// 体唯一标识的分组。</span></span><br><span class="line">group, ok := d.aggrGroups[route]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">group = <span class="keyword">map</span>[model.Fingerprint]*aggrGroup&#123;&#125;</span><br><span class="line">d.aggrGroups[route] = group</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If the group does not exist, create it.</span></span><br><span class="line"><span class="comment">// ----------------------------------------------------</span></span><br><span class="line"><span class="comment">// 假如当前告警的group labels的指纹在这个告警分组map里找不到，</span></span><br><span class="line"><span class="comment">// 则进行分组的创建。</span></span><br><span class="line">ag, ok := group[fp]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">ag = newAggrGroup(d.ctx, groupLabels, route, d.timeout, d.logger)</span><br><span class="line">group[fp] = ag</span><br><span class="line"><span class="comment">// 普罗米修斯的分组数量指标进行加一</span></span><br><span class="line">d.metrics.aggrGroups.Inc()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启新的协成，运行此告警指纹的分组</span></span><br><span class="line"><span class="keyword">go</span> ag.run(<span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, alerts ...*types.Alert)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">// 根据当前context的状态，来进行告警的处理。</span></span><br><span class="line">_, _, err := d.stage.Exec(ctx, d.logger, alerts...)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">lvl := level.Error(d.logger)</span><br><span class="line"><span class="keyword">if</span> ctx.Err() == context.Canceled &#123;</span><br><span class="line"><span class="comment">// It is expected for the context to be canceled on</span></span><br><span class="line"><span class="comment">// configuration reload or shutdown. In this case, the</span></span><br><span class="line"><span class="comment">// message should only be logged at the debug level.</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------</span></span><br><span class="line"><span class="comment">// 假如错误是因为reload或者关闭而导致的，那样日志等级为debug</span></span><br><span class="line">lvl = level.Debug(d.logger)</span><br><span class="line">&#125;</span><br><span class="line">lvl.Log(<span class="string">"msg"</span>, <span class="string">"Notify for alerts failed"</span>, <span class="string">"num_alerts"</span>, <span class="built_in">len</span>(alerts), <span class="string">"err"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err == <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入alert到这个唯一标识的分组里。</span></span><br><span class="line">ag.insert(alert)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第35行是进行告警发送的流程，最终执行的是Exec方法</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stage 在所给予的上下文限制中处理所有告警。</span></span><br><span class="line"><span class="keyword">type</span> Stage <span class="keyword">interface</span> &#123;</span><br><span class="line">Exec(ctx context.Context, l log.Logger, alerts ...*types.Alert) (context.Context, []*types.Alert, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// createReceiverStage 为一个接口人创建一个扇出的阶段管道。这里循环这个接受方式的</span></span><br><span class="line"><span class="comment">// 每一个接收人，然后为每个接收人创建一个MultiStage，用来装载多个阶段。每个Multistage</span></span><br><span class="line"><span class="comment">// 包含一个等待阶段，去重阶段，重试阶段和设置通知信息阶段。最后把每个MultiStage都添加</span></span><br><span class="line"><span class="comment">// 到扇出阶段，并进行返回。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createReceiverStage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">name <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">integrations []Integration,</span></span></span><br><span class="line"><span class="function"><span class="params">wait <span class="keyword">func</span>()</span> <span class="title">time</span>.<span class="title">Duration</span>,</span></span><br><span class="line"><span class="function"><span class="title">notificationLog</span> <span class="title">NotificationLog</span>,</span></span><br><span class="line"><span class="function"><span class="title">metrics</span> *<span class="title">metrics</span>,</span></span><br><span class="line"><span class="function">) <span class="title">Stage</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> fs FanoutStage</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> integrations &#123;</span><br><span class="line">recv := &amp;nflogpb.Receiver&#123;</span><br><span class="line">GroupName:   name,</span><br><span class="line">Integration: integrations[i].Name(),</span><br><span class="line">Idx:         <span class="keyword">uint32</span>(integrations[i].Index()),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s MultiStage</span><br><span class="line"><span class="comment">// 等待阶段</span></span><br><span class="line">s = <span class="built_in">append</span>(s, NewWaitStage(wait))</span><br><span class="line"><span class="comment">// 去重阶段</span></span><br><span class="line">s = <span class="built_in">append</span>(s, NewDedupStage(&amp;integrations[i], notificationLog, recv))</span><br><span class="line"><span class="comment">// 重试阶段</span></span><br><span class="line">s = <span class="built_in">append</span>(s, NewRetryStage(integrations[i], name, metrics))</span><br><span class="line"><span class="comment">// 设置通知信息阶段</span></span><br><span class="line">s = <span class="built_in">append</span>(s, NewSetNotifiesStage(notificationLog, recv))</span><br><span class="line"></span><br><span class="line">fs = <span class="built_in">append</span>(fs, s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在进行发送的时候依次进行，等待阶段、去重阶段、重试阶段、设置通知信息阶段，即分别是以下方法</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewWaitStage 返回一个新的等待阶段。设置wait方法到阶段之中。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWaitStage</span><span class="params">(wait <span class="keyword">func</span>()</span> <span class="title">time</span>.<span class="title">Duration</span>) *<span class="title">WaitStage</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;WaitStage&#123;</span><br><span class="line">wait: wait,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Exec implements the Stage interface.</span></span><br><span class="line"><span class="comment">// ------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Exec 实现了 Stage 接口，等待特定的一段时间，或者ctx.Done。取决于哪个事件先完成。</span></span><br><span class="line"><span class="comment">// 如果ctx.Done 先发生，则返回上下文里的错误。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ws *WaitStage)</span> <span class="title">Exec</span><span class="params">(ctx context.Context, l log.Logger, alerts ...*types.Alert)</span> <span class="params">(context.Context, []*types.Alert, error)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewDedupStage 包裹一个 DedupStage， 这个。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDedupStage</span><span class="params">(rs ResolvedSender, l NotificationLog, recv *nflogpb.Receiver)</span> *<span class="title">DedupStage</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;DedupStage&#123;</span><br><span class="line">rs:    rs,</span><br><span class="line">nflog: l,</span><br><span class="line">recv:  recv,</span><br><span class="line">now:   utcNow,</span><br><span class="line">hash:  hashAlert,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Exec 实现了 Stage 接口，将进行告警的去重，并获取消息日志，查看是否需要更新日志状态。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *DedupStage)</span> <span class="title">Exec</span><span class="params">(ctx context.Context, l log.Logger, alerts ...*types.Alert)</span> <span class="params">(context.Context, []*types.Alert, error)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...其余的方法可自行查看</span><br></pre></td></tr></table></figure><h4 id="WaitStage"><a href="#WaitStage" class="headerlink" title="WaitStage"></a>WaitStage</h4><p>等待间隔用来设置发送告警的等待时间，对于集群操作中，需要根据不同的peer设置不同的超时时间，如果仅仅一个Server本身，等待间隔设置为0；</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// clusterWait returns a function that inspects the current peer state and returns</span></span><br><span class="line"><span class="comment">// a duration of one base timeout for each peer with a higher ID than ourselves.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">clusterWait</span><span class="params">(p *cluster.Peer, timeout time.Duration)</span> <span class="title">func</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> time.Duration(p.Position()) * timeout</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>具体的实现上采用一个timer来传递信号，一旦时间到达后才返回对应的alerts，由于是串行执行的，所以消息传递会中止一段时间。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Exec implements the Stage interface.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ws *WaitStage)</span> <span class="title">Exec</span><span class="params">(ctx context.Context, l log.Logger, alerts ...*types.Alert)</span> <span class="params">(context.Context, []*types.Alert, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(ws.wait()):</span><br><span class="line">    <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">        <span class="keyword">return</span> ctx, <span class="literal">nil</span>, ctx.Err()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ctx, alerts, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DedupStage"><a href="#DedupStage" class="headerlink" title="DedupStage"></a>DedupStage</h4><p>DedupStage用于管理告警的去重，传递的参数中包含了一个NotificationLog,用来保存告警的发送记录。当有多个机器组成集群的时候，NotificationLog会通过协议去进行通信，传递彼此的记录信息，加入集群中的A如果发送了告警，该记录会传递给B机器，并进行merge操作，这样B机器在发送告警的时候如果查询已经发送，则不再进行告警发送。关于NotificationLog的实现nflog可以查看nflog/nflog.go文件。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DedupStage filters alerts.</span></span><br><span class="line"><span class="comment">// Filtering happens based on a notification log.</span></span><br><span class="line"><span class="keyword">type</span> DedupStage <span class="keyword">struct</span> &#123;</span><br><span class="line">    nflog NotificationLog</span><br><span class="line">    recv  *nflogpb.Receiver</span><br><span class="line">    conf  notifierConfig</span><br><span class="line"></span><br><span class="line">    now  <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Time</span></span></span><br><span class="line"><span class="function">    <span class="title">hash</span> <span class="title">func</span><span class="params">(*types.Alert)</span> <span class="title">uint64</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>具体的处理逻辑如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *DedupStage)</span> <span class="title">Exec</span><span class="params">(ctx context.Context, l log.Logger, alerts ...*types.Alert)</span> <span class="params">(context.Context, []*types.Alert, error)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    entries, err := n.nflog.Query(nflog.QGroupKey(gkey), nflog.QReceiver(n.recv))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err != nflog.ErrNotFound &#123;</span><br><span class="line">        <span class="keyword">return</span> ctx, <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> entry *nflogpb.Entry</span><br><span class="line">    <span class="keyword">switch</span> <span class="built_in">len</span>(entries) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        entry = entries[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> ctx, <span class="literal">nil</span>, fmt.Errorf(<span class="string">"unexpected entry result size %d"</span>, <span class="built_in">len</span>(entries))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n.needsUpdate(entry, firingSet, resolvedSet, repeatInterval) &#123;</span><br><span class="line">        <span class="keyword">return</span> ctx, alerts, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> ctx, <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的nflog.Query将根据接收和group key进行查询，一旦查找到，则不再返回对应的alerts. nflog设置了GC用来删除过期的日志记录。防止一直存在log中导致告警无法继续发送.</p><h4 id="RetryStage"><a href="#RetryStage" class="headerlink" title="RetryStage"></a>RetryStage</h4><p>RetryStage利用backoff策略来管理告警的重发，对于没有发送成功的告警将不断重试，直到超时时间,numFailedNotifications用来传递发送失败的统计metrics,numNotifications用来发送成功的metrics统计信息。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-tick.C:</span><br><span class="line">        now := time.Now()</span><br><span class="line">        retry, err := r.integration.Notify(ctx, sent...)</span><br><span class="line">        notificationLatencySeconds.WithLabelValues(r.integration.name).Observe(time.Since(now).Seconds())</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            numFailedNotifications.WithLabelValues(r.integration.name).Inc()</span><br><span class="line">            level.Debug(l).Log(<span class="string">"msg"</span>, <span class="string">"Notify attempt failed"</span>, <span class="string">"attempt"</span>, i, <span class="string">"integration"</span>, r.integration.name, <span class="string">"receiver"</span>, r.groupName, <span class="string">"err"</span>, err)</span><br><span class="line">            <span class="keyword">if</span> !retry &#123;</span><br><span class="line">                <span class="keyword">return</span> ctx, alerts, fmt.Errorf(<span class="string">"cancelling notify retry for %q due to unrecoverable error: %s"</span>, r.integration.name, err)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Save this error to be able to return the last seen error by an</span></span><br><span class="line">            <span class="comment">// integration upon context timeout.</span></span><br><span class="line">            iErr = err</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            numNotifications.WithLabelValues(r.integration.name).Inc()</span><br><span class="line">            <span class="keyword">return</span> ctx, alerts, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">        <span class="keyword">if</span> iErr != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ctx, <span class="literal">nil</span>, iErr</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ctx, <span class="literal">nil</span>, ctx.Err()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="SetNotifiesStage"><a href="#SetNotifiesStage" class="headerlink" title="SetNotifiesStage"></a>SetNotifiesStage</h4><p>SetNotifiesStage用来设置发送告警的信息到nfLog，该模块仅仅用于被该AM发送的告警的记录（Retry组件传递的alerts和Dedup组件中发送出去的告警信息）。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Exec implements the Stage interface.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n SetNotifiesStage)</span> <span class="title">Exec</span><span class="params">(ctx context.Context, l log.Logger, alerts ...*types.Alert)</span> <span class="params">(context.Context, []*types.Alert, error)</span></span> &#123;</span><br><span class="line">    gkey, ok := GroupKey(ctx)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> ctx, <span class="literal">nil</span>, fmt.Errorf(<span class="string">"group key missing"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    firing, ok := FiringAlerts(ctx)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> ctx, <span class="literal">nil</span>, fmt.Errorf(<span class="string">"firing alerts missing"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    resolved, ok := ResolvedAlerts(ctx)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> ctx, <span class="literal">nil</span>, fmt.Errorf(<span class="string">"resolved alerts missing"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ctx, alerts, n.nflog.Log(n.recv, gkey, firing, resolved)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="告警抑制处理流程"><a href="#告警抑制处理流程" class="headerlink" title="告警抑制处理流程"></a>告警抑制处理流程</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运行抑制器，会开始订阅告警。然后开始循环，如果订阅的告警遍历器里面有告警，</span></span><br><span class="line"><span class="comment">// 则获得告警，并循环每个抑制规则，如果匹配到</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ih *Inhibitor)</span> <span class="title">run</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 开始订阅告警</span></span><br><span class="line">it := ih.alerts.Subscribe()</span><br><span class="line"><span class="keyword">defer</span> it.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> a := &lt;-it.Next():</span><br><span class="line"><span class="comment">// 得到告警，</span></span><br><span class="line"><span class="keyword">if</span> err := it.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">level.Error(ih.logger).Log(<span class="string">"msg"</span>, <span class="string">"Error iterating alerts"</span>, <span class="string">"err"</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update the inhibition rules' cache.</span></span><br><span class="line"><span class="comment">// -----------------------------------------</span></span><br><span class="line"><span class="comment">// 循环每个抑制rule，假如当前告警匹配上某个source。</span></span><br><span class="line"><span class="comment">// 缓存这个告警到这个抑制rule的告警map里，map的key</span></span><br><span class="line"><span class="comment">// 为label的finger print，value为alert。</span></span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> ih.rules &#123;</span><br><span class="line"><span class="keyword">if</span> r.SourceMatchers.Match(a.Labels) &#123;</span><br><span class="line"><span class="keyword">if</span> err := r.scache.Set(a); err != <span class="literal">nil</span> &#123;</span><br><span class="line">level.Error(ih.logger).Log(<span class="string">"msg"</span>, <span class="string">"error on set alert"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链接：</p><p><a href="https://www.jianshu.com/p/239b145e2acc" target="_blank" rel="external">Prometheus Alertmanager报警组件</a></p><p><a href="https://just4fun.im/2018/05/25/study_alertmanager/" target="_blank" rel="external">https://just4fun.im/2018/05/25/study_alertmanager/</a></p><p><a href="https://github.com/annotated-golang/alertmanager-with-comment" target="_blank" rel="external">alertmanager-with-comment</a></p><p><a href="https://blog.csdn.net/u014029783/article/details/80663092?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.baidujs&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.baidujs" target="_blank" rel="external">Prometheus AlertManager代码阅读笔记 Notify组件</a></p><p><a href="https://blog.csdn.net/jianyuanPC/article/details/52756887?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.baidujs&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.baidujs" target="_blank" rel="external">Prometheus源码分析(二)配置文件说明</a></p><p><a href="https://www.modb.pro/db/103988" target="_blank" rel="external">Prometheus系列5 - Alertmanager源码阅读</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p id=&quot;div-border-top-green&quot;&gt;真正的坚强，是属于那些夜晚在被窝里哭泣，而白天却若无其事的人。未曾深夜痛哭过的人，不足以谈论人生。&lt;br&gt;&lt;/p&gt;

&lt;h2 id=&quot;基本概述&quot;&gt;&lt;a href=&quot;#基本概述&quot; class=&quot;headerlink&quot; title=&quot;基本概述&quot;&gt;&lt;/a&gt;基本概述&lt;/h2&gt;&lt;p&gt;我们先从应用的角度来看详细的介绍一下alertmanager以下简称am，以下是官方文档介绍。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The Alertmanager handles alerts sent by client applications such as the Prometheus server. It takes care of deduplicating, grouping, and routing them to the correct receiver integrations such as email, PagerDuty, or OpsGenie. It also takes care of silencing and inhibition of alerts.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;翻译一下就是，负责处理接受client（例如prometheus）发送的告警消息，包括重复告警的发送、聚合、发给相关人员，并且支持多种方式例如email或者pagerduty这种第三方通知告警平台，同时他还提供了静音以及告警抑制的功能。&lt;/p&gt;
&lt;p&gt;这些功能基本涵盖了目前各大公司的告警痛点，&lt;strong&gt;重复告警&lt;/strong&gt;（告警发生了但是一直也没人处理）、&lt;strong&gt;告警风暴&lt;/strong&gt;（某次版本上线导致的大量服务机器指标异常）、&lt;strong&gt;告警信息重复&lt;/strong&gt;（例如机器宕机之后又收到了网络不通的告警）。&lt;/p&gt;
&lt;p&gt;这里注意下，prometheus族包括am他们的实现思路都是基于label来做的，后面会从代码层面详细介绍下&lt;/p&gt;
&lt;p&gt;实现一个完整的监控体系需要以下几个功能：&lt;/p&gt;
    
    </summary>
    
      <category term="Prometheus" scheme="https://magiceses.github.io/categories/Prometheus/"/>
    
    
      <category term="Prometheus" scheme="https://magiceses.github.io/tags/Prometheus/"/>
    
      <category term="Alertmanager" scheme="https://magiceses.github.io/tags/Alertmanager/"/>
    
  </entry>
  
  <entry>
    <title>Python 进程线程协程(4)--线程池</title>
    <link href="https://magiceses.github.io/2019/10/13/python-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B-5/"/>
    <id>https://magiceses.github.io/2019/10/13/python-进程线程协程-5/</id>
    <published>2019-10-13T08:25:24.000Z</published>
    <updated>2021-10-11T07:20:00.198Z</updated>
    
    <content type="html"><![CDATA[<p id="div-border-top-green">你勤奋充电努力工作保持身材，对人微笑这些都不是为了取悦他人，而是为了扮靓自己照亮自己的心，告诉自己我是一股独立向上的力量。<br></p><p>在Python中还有一个线程池的概念，它也有并发处理能力，在一定程度上能提高系统运行效率；</p><p>线程的生命周期可以分为5个状态：创建、就绪、运行、阻塞和终止。自线程创建到终止，线程便不断在运行、创建和销毁这3个状态。一个线程的运行时间可由此可以分为3部分：线程的启动时间、线程体的运行时间和线程的销毁时间。在多线程处理的情景中，如果线程不能被重用，就意味着每次创建都需要经过启动、销毁和运行3个过程。这必然会增加系统相应的时间，降低了效率。看看之前介绍线程的博文的例子中（<a href="http://11026142.blog.51cto.com/11016142/1867519" target="_blank" rel="external"> 点击此处可以阅读</a>），有多少个任务，就创建多少个线程，但是由于Python特有的GIL限制，它并不是真正意义上的多线程，反而会因为频繁的切换任务等开销而降低了性能(<a href="http://11026142.blog.51cto.com/11016142/1864799" target="_blank" rel="external"> 点击此处可以了解Python的GIL</a>)。这种情况下可以使用线程池提高运行效率。</p><p>线程池的基本原理如下图，它是通过将事先创建多个能够执行任务的线程放入池中，所需要执行的任务通常要被安排在队列任务中。一般情况下，需要处理的任务比线程数目要多，线程执行完当前任务后，会从队列中取下一个任务，知道所有的任务完成。</p><p><img src="/images/python-process-3.png" alt="Python：线程、进程与协程(7)——线程池_Python"></p><p>由于线程预先被创建并放入线程池中，同时处理完当前任务之后并不销毁而是被安排处理下一个任务，因此能够避免多次创建线程，从而节省线程创建和销毁的开销，能带来更好的性能和系统稳定性。所以，说白了，Python的线程池也没有利用到多核或者多CPU的优势，只是跟普通的多线程相比，它不用去多次创建线程，节省了线程创建和销毁的时间，从而提高了性能。</p><p>Python中 线程池技术适合处理突发性大量请求或者需要大量线程来完成任务、但每个任务实际处理时间较短的场景，它能有效的避免由于系统创建线程过多而导致性能负荷过大、响应过慢等问题。下面介绍几种利用线程池的方法。</p><a id="more"></a><h2 id="自定义线程池模式"><a href="#自定义线程池模式" class="headerlink" title="自定义线程池模式"></a><strong>自定义线程池模式</strong></h2><p>我们可以利用Queue模块和threading模块来实现线程池。Queue用来创建任务队列，threading用来创建一个线程池子。</p><p>看下面例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Queue,threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    定义一个能够处理任务的线程类，属于自定义线程类，自定义线程类就需要定义run()函数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,workqueue,resultqueue,**kwargs)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self,**kwargs)</span><br><span class="line">        self.workqueue = workqueue<span class="comment">#存放任务的队列,任务一般都是函数</span></span><br><span class="line">        self.resultqueue = resultqueue<span class="comment">#存放结果的队列</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment">#从任务队列中取出一个任务，block设置为False表示如果队列空了，就会抛出异常</span></span><br><span class="line">                callable,args,kwargs = self.workqueue.get(block=<span class="keyword">False</span>)</span><br><span class="line">                res = callable(*args,**kwargs)</span><br><span class="line">                self.resultqueue.put(res)<span class="comment">#将任务的结果存放到结果队列中</span></span><br><span class="line">            <span class="keyword">except</span> Queue.Empty:<span class="comment">#抛出空队列异常</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkerManger</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    定义一个线程池的类</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,num=<span class="number">10</span>)</span>:</span><span class="comment">#默认这个池子里有10个线程</span></span><br><span class="line">        self.workqueue = Queue.Queue()<span class="comment">#任务队列，</span></span><br><span class="line">        self.resultqueue = Queue.Queue()<span class="comment">#存放任务结果的队列</span></span><br><span class="line">        self.workers = []<span class="comment">#所有的线程都存放在这个列表中</span></span><br><span class="line">        self._recruitthreads(num)<span class="comment">#创建一系列线程的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_recruitthreads</span><span class="params">(self,num)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        创建线程</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(num):</span><br><span class="line">            worker = Worker(self.workqueue,self.resultqueue)</span><br><span class="line">            self.workers.append(worker)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        启动线程池中每个线程</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> work <span class="keyword">in</span> self.workers:</span><br><span class="line">            work.start()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wait_for_complete</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        等待至任务队列中所有任务完成</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">while</span> len(self.workers):</span><br><span class="line">            worker = self.workers.pop()</span><br><span class="line">            worker.join()</span><br><span class="line">            <span class="keyword">if</span> worker.isAlive() <span class="keyword">and</span> <span class="keyword">not</span> self.workqueue.empty():</span><br><span class="line">                self.workers.append(worker)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_job</span><span class="params">(self,callable,*args,**kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        往任务队列中添加任务</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.workqueue.put((callable,args,kwargs))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_result</span><span class="params">(self,*args,**kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        获取结果队列</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.resultqueue.get(*args,**kwargs)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_result</span><span class="params">(self,result)</span>:</span></span><br><span class="line">        self.resultqueue.put(result)</span><br></pre></td></tr></table></figure><p>上面定义了一个线程池，它的初始化函数<strong>init</strong>()定义了一些存放相关数据的属性，这在Python的一些内部模块的类的定义中很常见，所有有时候多看看源码其实挺好的，学习大神的编程习惯和编程思想。</p><p>另外还要提到一点，Queue模块中的队列，不仅可以存放数据（指字符串，数值，列表，字典等等），还可以存放函数的（也就是任务），上面的代码中，callable是一个函数，当用put()将一个函数添加到队列时，put()接受的参数有函数对象以及该函数的相关参数，而且要是一个整体，所以就有了上面代码中的self.workqueue.put((callable,args,kwargs))。同理，当从这种存放函数的队列中取出数据，它返回的就是一个函数对象包括它的相关参数，有兴趣的可以打印出上面代码中run()里的callable,args,kwargs。</p><p>下面就简单的举个小例子吧。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib2,datetime</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">open_url</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        res = urllib2.urlopen(url).getcode()</span><br><span class="line">    <span class="keyword">except</span> urllib2.HTTPError, e:</span><br><span class="line">        res = e.code</span><br><span class="line">    <span class="comment">#print res</span></span><br><span class="line">    res = str(res)</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'/home/liulonghua/无标题文档'</span>,<span class="string">'wr'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(res)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    urls = [</span><br><span class="line">        <span class="string">'http://www.python.org'</span>,</span><br><span class="line">        <span class="string">'http://www.python.org/about/'</span>,</span><br><span class="line">        <span class="string">'http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html'</span>,</span><br><span class="line">        <span class="string">'http://www.python.org/doc/'</span>,</span><br><span class="line">        <span class="string">'http://www.python.org/download/'</span>,</span><br><span class="line">        <span class="string">'http://www.python.org/getit/'</span>,</span><br><span class="line">        <span class="string">'http://www.python.org/community/'</span>,</span><br><span class="line">        <span class="string">'https://wiki.python.org/moin/'</span>,</span><br><span class="line">        <span class="string">'http://planet.python.org/'</span>,</span><br><span class="line">        <span class="string">'https://wiki.python.org/moin/LocalUserGroups'</span>,</span><br><span class="line">        <span class="string">'http://www.python.org/psf/'</span>,</span><br><span class="line">        <span class="string">'http://docs.python.org/devguide/'</span>,</span><br><span class="line">        <span class="string">'http://www.python.org/community/awards/'</span></span><br><span class="line">    ]</span><br><span class="line">    t1 = datetime.datetime.now()</span><br><span class="line">    w = WorkerManger(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        w.add_job(open_url,url)</span><br><span class="line">    w.start()</span><br><span class="line">    w.wait_for_complete()</span><br><span class="line">    t2 = datetime.datetime.now()</span><br><span class="line">    <span class="keyword">print</span> t2 - t1</span><br></pre></td></tr></table></figure><p>最后结果如下：</p><p><img src="/images/python-process-4.png" alt="Python：线程、进程与协程(7)——线程池_进程池_02"></p><p>如果把上面代码改成用多线程而不是用线程池，会是怎样的呢？</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    urls = [</span><br><span class="line">        <span class="string">'http://www.python.org'</span>,</span><br><span class="line">        <span class="string">'http://www.python.org/about/'</span>,</span><br><span class="line">        <span class="string">'http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html'</span>,</span><br><span class="line">        <span class="string">'http://www.python.org/doc/'</span>,</span><br><span class="line">        <span class="string">'http://www.python.org/download/'</span>,</span><br><span class="line">        <span class="string">'http://www.python.org/getit/'</span>,</span><br><span class="line">        <span class="string">'http://www.python.org/community/'</span>,</span><br><span class="line">        <span class="string">'https://wiki.python.org/moin/'</span>,</span><br><span class="line">        <span class="string">'http://planet.python.org/'</span>,</span><br><span class="line">        <span class="string">'https://wiki.python.org/moin/LocalUserGroups'</span>,</span><br><span class="line">        <span class="string">'http://www.python.org/psf/'</span>,</span><br><span class="line">        <span class="string">'http://docs.python.org/devguide/'</span>,</span><br><span class="line">        <span class="string">'http://www.python.org/community/awards/'</span></span><br><span class="line">    ]</span><br><span class="line">    t1 = datetime.datetime.now()</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        t = threading.Thread(target=open_url,args=(url,))</span><br><span class="line">        t.start()</span><br><span class="line">        t.join()</span><br><span class="line">    t2 = datetime.datetime.now()</span><br><span class="line">    <span class="keyword">print</span> t2-t1</span><br></pre></td></tr></table></figure><p>运行效率的差异还是很大的，有兴趣的可以动手试试。</p><h2 id="使用现成的线程池模块"><a href="#使用现成的线程池模块" class="headerlink" title="使用现成的线程池模块"></a><strong>使用现成的线程池模块</strong></h2><p>下载安装也很简单，用pip工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install threadpool</span><br></pre></td></tr></table></figure><p><strong>注意：这里要提到一点，我就陷入这个坑，还好没有花多长时间就解决了。由于我的电脑里有python2.7.12,python3.5,还有一个PyPy5.4.1，上面的指令竟然将threadpool包安装到了PyPy目录下了，所以在python2.7.12里，我import threadpool，它一直报错，如果你的系统里有多个Python版本，又没有用virtualenvs虚拟环境工具，很容易造成这种混乱，虽然我安装了virtualenvs，但在自己的电脑上很少用，这里的解决方法是：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo python -m pip install threadpool</span><br></pre></td></tr></table></figure><p><strong>以区分PyPy，同理如果是在PyPy环境下安装第三方包的话，用sudo pypy -m pip install packagename,这个在之前的博文中也有介绍，感兴趣的可以<a href="http://11026142.blog.51cto.com/11016142/1858971" target="_blank" rel="external"> 点此</a></strong></p><p>该模块主要的类和方法：</p><ol><li><p>threadpool.ThreadPool:线程池类，主要是用来分派任务请求和收集运行结果。主要方法有：</p><ul><li><p><code>__init__</code>(self,number_workers,q_size,resq_size=0,poll_timeout=5):</p><p>建立线程池，并启动对应的num_workers的线程；q_size表示任务请求队列的大小，resq_size表示存放运行结果队列的大小。</p></li><li><p>createWorkers(self,num_workers，poll_timeout=5):</p><p>将num_workers数量对应的线程加入线程池</p></li><li><p>dismissWorkers(self,num_workers,do_join=False):</p><p>告诉num_workers数量的工作线程在执行完当前任务后退出</p></li><li><p>joinAllDismissWorkers(self):</p><p>在设置为退出的线程上执行Thread.join</p></li><li><p>putRequest(self,request,block=True,timeout=None):</p><p>加入一个任务请求到工作队列</p></li><li><p>pool(self,block=False)</p><p>处理任务队列中新请求。也就是循环的调用各个线程结果中的回调和错误回调。不过，当请求队列为空时会抛出 NoResultPending 异常，以表示所有的结果都处理完了。这个特点对于依赖线程执行结果继续加入请求队列的方式不太适合。</p></li><li><p>wait(self)</p><p>等待执行结果，直到所有任务完成。当所有执行结果返回后，线程池内部的线程并没有销毁，而是在等待新任务。因此，wait()之后依然可以在此调用pool.putRequest()往其中添加任务。</p></li></ul></li><li><p>threadpool.WorkerThread:处理任务的工作线程，主要有run()方法和dismiss()方法。</p></li><li><p>threadpool.WorkRequest:任务请求类，包含有具体执行方法的工作请求类</p><ul><li><p><code>__init__</code>(self,callable,args=None,kwds=None,requestID=None,callback=None,exc_callback=None)</p><p>创建一个工作请求。</p></li></ul></li><li><p>makeRequests(callable_,args_list,callback=None,exc_callback=_handle_thread_exception):</p><p>主要函数，用来创建具有相同的执行函数但参数不同的一系列工作请求。</p></li></ol><p>有了上面自定义线程池模式的基础，这个模块不难理解，有兴趣的可以去看看该模块的源码。它的使用步骤一般如下：</p><ul><li>（1）引入threadpool模块</li><li>（2）定义线程函数</li><li>（3）创建线程 池threadpool.ThreadPool()</li><li>（4）创建需要线程池处理的任务即threadpool.makeRequests()</li><li>（5）将创建的多个任务put到线程池中,threadpool.putRequest</li><li>（6）等到所有任务处理完毕theadpool.pool()</li></ul><p>将上面的例子用线程池模块进行修改，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threadpool</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    urls = [</span><br><span class="line">        <span class="string">'http://www.python.org'</span>,</span><br><span class="line">        <span class="string">'http://www.python.org/about/'</span>,</span><br><span class="line">        <span class="string">'http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html'</span>,</span><br><span class="line">        <span class="string">'http://www.python.org/doc/'</span>,</span><br><span class="line">        <span class="string">'http://www.python.org/download/'</span>,</span><br><span class="line">        <span class="string">'http://www.python.org/getit/'</span>,</span><br><span class="line">        <span class="string">'http://www.python.org/community/'</span>,</span><br><span class="line">        <span class="string">'https://wiki.python.org/moin/'</span>,</span><br><span class="line">        <span class="string">'http://planet.python.org/'</span>,</span><br><span class="line">        <span class="string">'https://wiki.python.org/moin/LocalUserGroups'</span>,</span><br><span class="line">        <span class="string">'http://www.python.org/psf/'</span>,</span><br><span class="line">        <span class="string">'http://docs.python.org/devguide/'</span>,</span><br><span class="line">        <span class="string">'http://www.python.org/community/awards/'</span></span><br><span class="line">    ]</span><br><span class="line">    t1 = datetime.datetime.now()</span><br><span class="line">    pool = threadpool.ThreadPool(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    requests = threadpool.makeRequests(open_url,urls)</span><br><span class="line">    [pool.putRequest(req) <span class="keyword">for</span> req <span class="keyword">in</span> requests]</span><br><span class="line">    pool.wait()</span><br><span class="line">    t2 = datetime.datetime.now()</span><br><span class="line">    <span class="keyword">print</span> t2-t1</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="/images/python-process-5.png" alt="Python：线程、进程与协程(7)——线程池_进程池_04"></p><h2 id="multiprocessing-dummy-执行多线程任务"><a href="#multiprocessing-dummy-执行多线程任务" class="headerlink" title="multiprocessing.dummy 执行多线程任务"></a><strong>multiprocessing.dummy 执行多线程任务</strong></h2><p>multiprocessing.dummy 模块与 multiprocessing 模块的区别： dummy 模块是多线程，而 multiprocessing 是多进程， api 都是通用的。</p><p>Python3里的multiprocessing里也有现成的线程池，如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing.pool <span class="keyword">import</span> ThreadPool</span><br></pre></td></tr></table></figure><p>有时候看到有人这么用dummy,from multiprocessing.dummy import Pool as ThreadPool ,把它当作了一个线程池。它的属性和方法可以参考<a href="http://11026142.blog.51cto.com/11016142/1876989" target="_blank" rel="external"> 进程池</a>。将上面的例子可以用这种方法改下代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing.dummy <span class="keyword">import</span> Pool <span class="keyword">as</span> ThreadPool </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    urls = [</span><br><span class="line">        <span class="string">'http://www.python.org'</span>,</span><br><span class="line">        <span class="string">'http://www.python.org/about/'</span>,</span><br><span class="line">        <span class="string">'http://www.onlamp.com/pub/a/python/2003/04/17/metaclasses.html'</span>,</span><br><span class="line">        <span class="string">'http://www.python.org/doc/'</span>,</span><br><span class="line">        <span class="string">'http://www.python.org/download/'</span>,</span><br><span class="line">        <span class="string">'http://www.python.org/getit/'</span>,</span><br><span class="line">        <span class="string">'http://www.python.org/community/'</span>,</span><br><span class="line">        <span class="string">'https://wiki.python.org/moin/'</span>,</span><br><span class="line">        <span class="string">'http://planet.python.org/'</span>,</span><br><span class="line">        <span class="string">'https://wiki.python.org/moin/LocalUserGroups'</span>,</span><br><span class="line">        <span class="string">'http://www.python.org/psf/'</span>,</span><br><span class="line">        <span class="string">'http://docs.python.org/devguide/'</span>,</span><br><span class="line">        <span class="string">'http://www.python.org/community/awards/'</span></span><br><span class="line">    ]</span><br><span class="line">    t1 = datetime.datetime.now()</span><br><span class="line">    pool =ThreadPool(<span class="number">2</span>)</span><br><span class="line">    pool.map(open_url,urls)</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line">    t2 = datetime.datetime.now()</span><br><span class="line">    <span class="keyword">print</span> t2-t1</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="/images/python-process-6.png" alt="Python：线程、进程与协程(7)——线程池_线程池_05"></p><p>原文： <a href="https://blog.51cto.com/u_11026142/1879245" target="_blank" rel="external">https://blog.51cto.com/u_11026142/1879245</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p id=&quot;div-border-top-green&quot;&gt;你勤奋充电努力工作保持身材，对人微笑这些都不是为了取悦他人，而是为了扮靓自己照亮自己的心，告诉自己我是一股独立向上的力量。&lt;br&gt;&lt;/p&gt;

&lt;p&gt;在Python中还有一个线程池的概念，它也有并发处理能力，在一定程度上能提高系统运行效率；&lt;/p&gt;
&lt;p&gt;线程的生命周期可以分为5个状态：创建、就绪、运行、阻塞和终止。自线程创建到终止，线程便不断在运行、创建和销毁这3个状态。一个线程的运行时间可由此可以分为3部分：线程的启动时间、线程体的运行时间和线程的销毁时间。在多线程处理的情景中，如果线程不能被重用，就意味着每次创建都需要经过启动、销毁和运行3个过程。这必然会增加系统相应的时间，降低了效率。看看之前介绍线程的博文的例子中（&lt;a href=&quot;http://11026142.blog.51cto.com/11016142/1867519&quot;&gt; 点击此处可以阅读&lt;/a&gt;），有多少个任务，就创建多少个线程，但是由于Python特有的GIL限制，它并不是真正意义上的多线程，反而会因为频繁的切换任务等开销而降低了性能(&lt;a href=&quot;http://11026142.blog.51cto.com/11016142/1864799&quot;&gt; 点击此处可以了解Python的GIL&lt;/a&gt;)。这种情况下可以使用线程池提高运行效率。&lt;/p&gt;
&lt;p&gt;线程池的基本原理如下图，它是通过将事先创建多个能够执行任务的线程放入池中，所需要执行的任务通常要被安排在队列任务中。一般情况下，需要处理的任务比线程数目要多，线程执行完当前任务后，会从队列中取下一个任务，知道所有的任务完成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/python-process-3.png&quot; alt=&quot;Python：线程、进程与协程(7)——线程池_Python&quot;&gt;&lt;/p&gt;
&lt;p&gt;由于线程预先被创建并放入线程池中，同时处理完当前任务之后并不销毁而是被安排处理下一个任务，因此能够避免多次创建线程，从而节省线程创建和销毁的开销，能带来更好的性能和系统稳定性。所以，说白了，Python的线程池也没有利用到多核或者多CPU的优势，只是跟普通的多线程相比，它不用去多次创建线程，节省了线程创建和销毁的时间，从而提高了性能。&lt;/p&gt;
&lt;p&gt;Python中 线程池技术适合处理突发性大量请求或者需要大量线程来完成任务、但每个任务实际处理时间较短的场景，它能有效的避免由于系统创建线程过多而导致性能负荷过大、响应过慢等问题。下面介绍几种利用线程池的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://magiceses.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://magiceses.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python 进程线程协程(4)--multiprocessing模块(下)</title>
    <link href="https://magiceses.github.io/2019/10/12/python-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B-4.2/"/>
    <id>https://magiceses.github.io/2019/10/12/python-进程线程协程-4.2/</id>
    <published>2019-10-11T17:25:24.000Z</published>
    <updated>2021-10-02T03:03:07.644Z</updated>
    
    <content type="html"><![CDATA[<p id="div-border-top-green">就算没有天分，只要你愿意每天花一点时间，做同样一件事情，不知不觉间，你就会走得很远。<br></p><p>上篇博文介绍了multiprocessing模块的内存共享，下面讲进程池。有些情况下，所要完成的工作可以上篇博文介绍了multiprocessing模块的内存共享，下面讲进程池。有些情况下，所要完成的工作可以分解并独立地分布到多个工作进程，对于这种简单的情况，可以用Pool类来管理固定数目的工作进程。作业的返回值会收集并作为一个列表返回。Pool可以提供指定数量的进程，供用户调用，当有新的请求提交到pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到规定最大值，那么该请求就会等待，直到池中有进程结束，才会创建新的进程来它。</p><p>在网上找到了一篇非常好的分析进程池源码的文章，在这里跟大家分享下，篇幅比较长，希望大家能够有耐心的看完它，仔细体会。</p><p>进程池使用multiprocessing.pool，pool的构造如下：</p><a id="more"></a><p><strong>multiprocessing.Pool([processes[, initializer[, initargs[, maxtasksperchild]]]])</strong></p><ul><li>processes表示pool中进程的数目，默认地为当前CPU的核数可以通过multiprocessing.cpu_count()方法参考你机器上cpu数量；</li><li>initializer表示工作进程start时调用的初始化函数；</li><li>initargs表示initializer函数的参数，如果initializer不为None，在每个工作进程start之前会调用；</li><li>maxtasksperchild表示每个工作进程在退出/被其他新的进程替代前，需要完成的工作任务数，默认为None，表示工作进程存活时间与pool相同，即不会自动退出/被替换。</li></ul><p>主要方法：</p><ul><li>apply(func[, args[, kwds]]) ：apply用于传递不定参数，同python中的apply函数一致（不过内置的apply函数从2.3以后就不建议使用了），主进程会阻塞于函数，主进程的执行流程同单进程一致；</li><li>apply_async(func[, args[, kwds[, callback]]]) ：与apply用法一致，但它是非阻塞的且支持结果返回后进行回调；</li></ul><p>主进程循环运行过程中不等待apply_async的返回结果，在主进程结束后，即使子进程还未返回整个程序也会退出。虽然apply_async是非阻塞的，但其返回结果的get方法却是阻塞的，如使用result.get()会阻塞主进程。</p><p>如果我们对返回结果不感兴趣， 那么可以在主进程中使用pool.close与pool.join来防止主进程退出。注意join方法一定要在close或terminate之后调用。</p><ul><li>map(func, iterable[, chunksize]) ：map方法与在功能上等价与内置的map()，只不过单个任务会并行运行。它会使进程阻塞直到结果返回。但需注意的是其第二个参数虽然描述的为iterable, 但在实际使用中发现只有在整个队列全部就绪后，程序才会运行子进程；</li><li>map_async(func, iterable[, chunksize[, callback]]) ：与map用法一致，但是它是非阻塞的。其有关事项见apply_async；</li><li>imap(func, iterable[, chunksize]) ：与map不同的是， imap的返回结果为iter，需要在主进程中主动使用next来驱动子进程的调用。即使子进程没有返回结果，主进程对于gen_list(l)的 iter还是会继续进行， 另外根据python2.6文档的描述，对于大数据量的iterable而言，将chunksize设置大一些比默认的1要好；</li><li>imap_unordered(func, iterable[, chunksize]) ：同imap一致，只不过其并不保证返回结果与迭代传入的顺序一致；</li><li>close() ：关闭pool，使其不再接受新的任务；</li><li>terminate() ：结束工作进程，不再处理未处理的任务；</li><li>join() ：主进程阻塞等待子进程的退出， join方法要在close或terminate之后使用。</li></ul><p>它的源码在multiprocessing包pool.py里，Pool对象的初始化函数如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pool</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Class which supports an async version of the `apply()` builtin</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    Process = Process</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, processes=None, initializer=None, initargs=<span class="params">()</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 maxtasksperchild=None)</span>:</span></span><br><span class="line">        self._setup_queues()</span><br><span class="line">        self._taskqueue = Queue.Queue()</span><br><span class="line">        self._cache = &#123;&#125;</span><br><span class="line">        self._state = RUN</span><br><span class="line">        self._maxtasksperchild = maxtasksperchild</span><br><span class="line">        self._initializer = initializer</span><br><span class="line">        self._initargs = initargs</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> processes <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                processes = cpu_count()</span><br><span class="line">            <span class="keyword">except</span> NotImplementedError:</span><br><span class="line">                processes = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> processes &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"Number of processes must be at least 1"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> initializer <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> <span class="keyword">not</span> hasattr(initializer, <span class="string">'__call__'</span>):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">'initializer must be a callable'</span>)</span><br><span class="line"></span><br><span class="line">        self._processes = processes</span><br><span class="line">        self._pool = []</span><br><span class="line">        self._repopulate_pool()</span><br><span class="line"></span><br><span class="line">        self._worker_handler = threading.Thread(</span><br><span class="line">            target=Pool._handle_workers,</span><br><span class="line">            args=(self, )</span><br><span class="line">            )</span><br><span class="line">        self._worker_handler.daemon = <span class="keyword">True</span></span><br><span class="line">        self._worker_handler._state = RUN</span><br><span class="line">        self._worker_handler.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        self._task_handler = threading.Thread(</span><br><span class="line">            target=Pool._handle_tasks,</span><br><span class="line">            args=(self._taskqueue, self._quick_put, self._outqueue,</span><br><span class="line">                  self._pool, self._cache)</span><br><span class="line">            )</span><br><span class="line">        self._task_handler.daemon = <span class="keyword">True</span></span><br><span class="line">        self._task_handler._state = RUN</span><br><span class="line">        self._task_handler.start()</span><br><span class="line"></span><br><span class="line">        self._result_handler = threading.Thread(</span><br><span class="line">            target=Pool._handle_results,</span><br><span class="line">            args=(self._outqueue, self._quick_get, self._cache)</span><br><span class="line">            )</span><br><span class="line">        self._result_handler.daemon = <span class="keyword">True</span></span><br><span class="line">        self._result_handler._state = RUN</span><br><span class="line">        self._result_handler.start()</span><br><span class="line"></span><br><span class="line">        self._terminate = Finalize(</span><br><span class="line">            self, self._terminate_pool,</span><br><span class="line">            args=(self._taskqueue, self._inqueue, self._outqueue, self._pool,</span><br><span class="line">                  self._worker_handler, self._task_handler,</span><br><span class="line">                  self._result_handler, self._cache),</span><br><span class="line">            exitpriority=<span class="number">15</span></span><br><span class="line">            )</span><br></pre></td></tr></table></figure><p>主要数据结构有：</p><ul><li>self._inqueue  接收任务队列（SimpleQueue），用于主进程将任务发送给worker进程;</li><li>self._outqueue  发送结果队列（SimpleQueue），用于worker进程将结果发送给主进程;</li><li>self._taskqueue  同步的任务队列，保存线程池分配给主进程的任务;</li><li>self._cache = {}  任务缓存;</li><li>self._processes  worker进程个数;</li><li>self._pool = []  woker进程队列。</li></ul><p>进程池工作时，任务的接收、分配。结果的返回，均由进程池内部的各个线程合作完成，来看看进程池内部由那些线程：</p><p><code>_work_handler</code>线程，负责保证进程池中的worker进程在有退出的情况下，创建出新的worker进程，并添加到进程队列（pools）中，保持进程池中的worker进程数始终为processes个。</p><p>_<code>worker_handler</code>线程回调函数为Pool.<code>_handler_workers</code>方法，在进程池state==RUN时，循环调用<code>_maintain_pool</code>方法，监控是否有进程退出，并创建新的进程，append到进程池pools中，保持进程池中的worker进程数始终为processes个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">self._worker_handler = threading.Thread(</span><br><span class="line">            target=Pool._handle_workers,</span><br><span class="line">            args=(self, )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pool._handle_workers方法在_worker_handler线程状态为运行时(status==RUN)，循环调用_maintain_pool方法：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_maintain_pool</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self._join_exited_workers():</span><br><span class="line">        self._repopulate_pool()</span><br><span class="line"></span><br><span class="line"><span class="comment"># _join_exited_workers()监控pools队列中的进程是否有结束的，有则等待其结束，并从pools中删除，当有进程结束时，调用_repopulate_pool()，创建新的进程：</span></span><br><span class="line">w = self.Process(target=worker,</span><br><span class="line">            　　  args=(self._inqueue, self._outqueue,</span><br><span class="line">                    　 self._initializer, self._initargs,      　　　　　　　　　　 </span><br><span class="line">                       self._maxtasksperchild)</span><br><span class="line">                 )</span><br><span class="line">self._pool.append(w)</span><br><span class="line"></span><br><span class="line"><span class="comment"># w是新创建的进程，它是用来处理实际任务的进程，worker是它的回调函数：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(inqueue, outqueue, initializer=None, initargs=<span class="params">()</span>, maxtasks=None)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> maxtasks <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> (type(maxtasks) == int <span class="keyword">and</span> maxtasks &gt; <span class="number">0</span>)</span><br><span class="line">    put = outqueue.put</span><br><span class="line">    get = inqueue.get</span><br><span class="line">    <span class="keyword">if</span> hasattr(inqueue, <span class="string">'_writer'</span>):</span><br><span class="line">        inqueue._writer.close()</span><br><span class="line">        outqueue._reader.close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> initializer <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        initializer(*initargs)</span><br><span class="line"></span><br><span class="line">    completed = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> maxtasks <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> (maxtasks <span class="keyword">and</span> completed &lt; maxtasks):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            task = get()</span><br><span class="line">        <span class="keyword">except</span> (EOFError, IOError):</span><br><span class="line">            debug(<span class="string">'worker got EOFError or IOError -- exiting'</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> task <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            debug(<span class="string">'worker got sentinel -- exiting'</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        job, i, func, args, kwds = task</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            result = (<span class="keyword">True</span>, func(*args, **kwds))</span><br><span class="line">        <span class="keyword">except</span> Exception, e:</span><br><span class="line">            result = (<span class="keyword">False</span>, e)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            put((job, i, result))</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            wrapped = MaybeEncodingError(e, result[<span class="number">1</span>])</span><br><span class="line">            debug(<span class="string">"Possible encoding error while sending result: %s"</span> % (</span><br><span class="line">                wrapped))</span><br><span class="line">            put((job, i, (<span class="keyword">False</span>, wrapped)))</span><br><span class="line">        completed += <span class="number">1</span></span><br><span class="line">    debug(<span class="string">'worker exiting after %d tasks'</span> % completed)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有worker进程都使用worker回调函数对任务进行统一的处理，从源码中可以看出：</span></span><br><span class="line"><span class="comment"># 它的功能是从接入任务队列中（inqueue）读取出task任务，然后根据任务的函数、参数进行调用（result = (True, func(*args, **kwds)，</span></span><br><span class="line"><span class="comment"># 再将结果放入结果队列中（outqueue)，如果有最大处理上限的限制maxtasks，那么当进程处理到任务数上限时退出。</span></span><br></pre></td></tr></table></figure><p><code>_task_handler</code>线程，负责从进程池中的task_queue中，将任务取出，放入接收任务队列（Pipe）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self._task_handler = threading.Thread(</span><br><span class="line">            target=Pool._handle_tasks,</span><br><span class="line">            args=(self._taskqueue, self._quick_put, self._outqueue, self._pool)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>Pool._handle_tasks方法不断从task_queue中获取任务，并放入接受任务队列（in_queue)，以此触发worker进程进行任务处理。当从task_queue读取到None元素时，表示进程池将要被终止（terminate)，不再处理之后的任务请求，同时向接受任务队列和结果任务队列put None元素，通知其他线程结束。</p><p>_handle_results线程，负责将处理完的任务结果，从outqueue（Pipe）中读取出来，放在任务缓存cache中，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self._result_handler = threading.Thread(</span><br><span class="line">        target=Pool._handle_results,</span><br><span class="line">        args=(self._outqueue, self._quick_get, self._cache)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>_terminate</code>，这里的<code>_terminate</code>并不是一个线程，而是一个Finalize对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">self._terminate = Finalize(</span><br><span class="line">            self, self._terminate_pool,</span><br><span class="line">            args=(self._taskqueue, self._inqueue, self._outqueue, self._pool,</span><br><span class="line">                  self._worker_handler, self._task_handler,</span><br><span class="line">                  self._result_handler, self._cache),</span><br><span class="line">            exitpriority=<span class="number">15</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># Finalize类的构造函数与线程构造函数类似，_terminate_pool是它的回调函数，args回调函数的参数。</span></span><br><span class="line"><span class="comment"># _terminate_pool函数负责终止进程池的工作：终止上述的三个线程，终止进程池中的worker进程，清除队列中的数据。</span></span><br><span class="line"><span class="comment"># _terminate是个对象而非线程，那么它如何像线程调用start()方法一样，来执行回调函数_terminate_pool呢？查看Pool源码，发现进程池的终止函数：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">terminate</span><span class="params">(self)</span>:</span></span><br><span class="line">    debug(<span class="string">'terminating pool'</span>)</span><br><span class="line">    self._state = TERMINATE</span><br><span class="line">    self._worker_handler._state = TERMINATE</span><br><span class="line">    self._terminate()</span><br><span class="line"><span class="comment"># 函数中最后将_terminate对象当做一个方法来执行，而_terminate本身是一个Finalize对象，我们看一下Finalize类的定义，发现它实现了__call__方法：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, wr=None)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">del</span> _finalizer_registry[self._key]</span><br><span class="line">    <span class="keyword">except</span> KeyError:</span><br><span class="line">        sub_debug(<span class="string">'finalizer no longer registered'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> self._pid != os.getpid():</span><br><span class="line">            res = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res = self._callback(*self._args, **self._kwargs)</span><br><span class="line">        self._weakref = self._callback = self._args = \</span><br><span class="line">                        self._kwargs = self._key = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"><span class="comment"># 而方法中 self._callback(*self._args, **self._kwargs) 这条语句，就执行了_terminate_pool函数，进而将进程池终止。</span></span><br></pre></td></tr></table></figure><p>下面接着看下客户端如何对向进程池分配任务，并获取结果的。</p><p>我们知道，当进程池中任务队列非空时，才会触发worker进程去工作，那么如何向进程池中的任务队列中添加任务呢，进程池类有两组关键方法来创建任务，分别是apply/apply_async和map/map_async，实际上进程池类的apply和map方法与python内建的两个同名方法类似，apply_async和map_async分别为它们的非阻塞版本。</p><p>首先来看apply_async方法，源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply_async</span><span class="params">(self, func, args=<span class="params">()</span>, kwds=&#123;&#125;, callback=None)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> self._state == RUN</span><br><span class="line">    result = ApplyResult(self._cache, callback)</span><br><span class="line">    self._taskqueue.put(([(result._job, <span class="keyword">None</span>, func, args, kwds)], <span class="keyword">None</span>))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"><span class="comment"># func表示执行此任务的方法</span></span><br><span class="line"><span class="comment"># args、kwds分别表func的位置参数和关键字参数</span></span><br><span class="line"><span class="comment"># callback表示一个单参数的方法，当有结果返回时，callback方法会被调用，参数即为任务执行后的结果</span></span><br></pre></td></tr></table></figure><p>每调用一次apply_result方法，实际上就向<code>_taskqueue</code>中添加了一条任务，注意这里采用了非阻塞（异步）的调用方式，即apply_async方法中新建的任务只是被添加到任务队列中，还并未执行，不需要等待，直接返回创建的ApplyResult对象，注意在创建ApplyResult对象时，将它放入进程池的缓存<code>_cache</code>中。</p><p>任务队列中有了新创建的任务，那么根据上节分析的处理流程，进程池的<code>_task_handler</code>线程，将任务从taskqueue中获取出来，放入<code>_inqueue</code>中，触发worker进程根据args和kwds调用func，运行结束后，将结果放入<code>_outqueue</code>，再由进程池中的<code>_handle_results</code>线程，将运行结果从<code>_outqueue</code>中取出，并找到<code>_cache</code>缓存中的ApplyResult对象，<code>_set</code>其运行结果，等待调用端获取。</p><p>apply_async方法既然是异步的，那么它如何知道任务结束，并获取结果呢？这里需要了解ApplyResult类中的两个主要方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, timeout=None)</span>:</span></span><br><span class="line">    self.wait(timeout)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self._ready:</span><br><span class="line">        <span class="keyword">raise</span> TimeoutError</span><br><span class="line">    <span class="keyword">if</span> self._success:</span><br><span class="line">        <span class="keyword">return</span> self._value</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> self._value</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_set</span><span class="params">(self, i, obj)</span>:</span></span><br><span class="line">    self._success, self._value = obj</span><br><span class="line">    <span class="keyword">if</span> self._callback <span class="keyword">and</span> self._success:</span><br><span class="line">        self._callback(self._value)</span><br><span class="line">    self._cond.acquire()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        self._ready = <span class="keyword">True</span></span><br><span class="line">        self._cond.notify()</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        self._cond.release()</span><br><span class="line">    <span class="keyword">del</span> self._cache[self._job]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从这两个方法名可以看出，get方法是提供给客户端获取worker进程运行结果的，而运行的结果是通过_handle_result线程调用_set方法，存放在ApplyResult对象中。</span></span><br><span class="line"><span class="comment"># _set方法将运行结果保存在ApplyResult._value中，唤醒阻塞在条件变量上的get方法。客户端通过调用get方法，返回运行结果。</span></span><br></pre></td></tr></table></figure><p>apply方法是以阻塞的方式运行获取进程结果，它的实现很简单，同样是调用apply_async，只不过不返回ApplyResult，而是直接返回worker进程运行的结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply</span><span class="params">(self, func, args=<span class="params">()</span>, kwds=&#123;&#125;)</span>:</span>     </span><br><span class="line">   <span class="keyword">assert</span> self._state == RUN       </span><br><span class="line">   <span class="keyword">return</span> self.apply_async(func, args, kwds).get()</span><br></pre></td></tr></table></figure><p>以上的apply/apply_async方法，每次只能向进程池分配一个任务，那如果想一次分配多个任务到进程池中，可以使用map/map_async方法。首先来看下map_async方法是如何定义的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map_async</span><span class="params">(self, func, iterable, chunksize=None, callback=None)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> self._state == RUN</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> hasattr(iterable, <span class="string">'__len__'</span>):</span><br><span class="line">        iterable = list(iterable)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> chunksize <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        chunksize, extra = divmod(len(iterable), len(self._pool) * <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">if</span> extra:</span><br><span class="line">            chunksize += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> len(iterable) == <span class="number">0</span>:</span><br><span class="line">            chunksize = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    task_batches = Pool._get_tasks(func, iterable, chunksize)</span><br><span class="line">    result = MapResult(self._cache, chunksize, len(iterable), callback)</span><br><span class="line">    self._taskqueue.put((((result._job, i, mapstar, (x,), &#123;&#125;)</span><br><span class="line">                              <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(task_batches)), <span class="keyword">None</span>))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># func表示执行此任务的方法</span></span><br><span class="line"><span class="comment"># iterable表示任务参数序列</span></span><br><span class="line"><span class="comment"># chunksize表示将iterable序列按每组chunksize的大小进行分割，每个分割后的序列提交给进程池中的一个任务进行处理</span></span><br><span class="line"><span class="comment"># callback表示一个单参数的方法，当有结果返回时，callback方法会被调用，参数即为任务执行后的结果</span></span><br></pre></td></tr></table></figure><p>从源码可以看出，map_async要比apply_async复杂，首先它会根据chunksize对任务参数序列进行分组，chunksize表示每组中的任务个数，当默认chunksize=None时，根据任务参数序列和进程池中进程数计算分组数：chunk, extra = divmod(len(iterable), len(self._pool) * 4)。假设进程池中进程数为len(self._pool)=4，任务参数序列iterable=range(123)，那么chunk=7, extra=11，向下执行，得出chunksize=8，表示将任务参数序列分为8组。任务实际分组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">task_batches = Pool._get_tasks(func, iterable, chunksize)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_tasks</span><span class="params">(func, it, size)</span>:</span></span><br><span class="line">    it = iter(it)</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        x = tuple(itertools.islice(it, size))</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> x:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">yield</span> (func, x)</span><br><span class="line"></span><br><span class="line">这里使用<span class="keyword">yield</span>将_get_tasks方法编译成生成器。实际上对于range(<span class="number">123</span>)这样的序列，按照chunksize=<span class="number">8</span>进行分组后，一共<span class="number">16</span>组每组的元素如下：</span><br><span class="line">(func, (<span class="number">0</span>,   <span class="number">1</span>,   <span class="number">2</span>,   <span class="number">3</span>,   <span class="number">4</span>,   <span class="number">5</span>,   <span class="number">6</span>,   <span class="number">7</span>))</span><br><span class="line">(func, (<span class="number">8</span>,   <span class="number">9</span>,   <span class="number">10</span>,  <span class="number">11</span>,  <span class="number">12</span>,  <span class="number">13</span>,  <span class="number">14</span>,  <span class="number">15</span>))</span><br><span class="line">(func, (<span class="number">16</span>,  <span class="number">17</span>,  <span class="number">18</span>,  <span class="number">19</span>,  <span class="number">20</span>,  <span class="number">21</span>,  <span class="number">22</span>,  <span class="number">23</span>))</span><br><span class="line">...</span><br><span class="line">(func, (<span class="number">112</span>, <span class="number">113</span>, <span class="number">114</span>, <span class="number">115</span>, <span class="number">116</span>, <span class="number">117</span>, <span class="number">118</span>, <span class="number">119</span>))</span><br><span class="line">(func, (<span class="number">120</span>, <span class="number">121</span>, <span class="number">122</span>))</span><br></pre></td></tr></table></figure><p>分组之后，这里定义了一个MapResult对象：result = MapResult(self._cache, chunksize, len(iterable), callback)它继承自AppyResult类，同样提供get和_set方法接口。将分组后的任务放入任务队列中，然后就返回刚刚创建的result对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">self._taskqueue.put((((result._job, i, mapstar, (x,), &#123;&#125;)</span><br><span class="line">                              <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(task_batches)), <span class="keyword">None</span>))</span><br><span class="line">以任务参数序列=range(<span class="number">123</span>)为例，实际上这里向任务队列中put了一个<span class="number">16</span>组元组元素的集合，元组依次为：</span><br><span class="line">(result._job, <span class="number">0</span>, mapstar, ((func, (<span class="number">0</span>,   <span class="number">1</span>,   <span class="number">2</span>,   <span class="number">3</span>,   <span class="number">4</span>,   <span class="number">5</span>,   <span class="number">6</span>,   <span class="number">7</span>)),), &#123;&#125;, <span class="keyword">None</span>)</span><br><span class="line">(result._job, <span class="number">1</span>, mapstar, ((func, (<span class="number">8</span>,   <span class="number">9</span>,   <span class="number">10</span>,  <span class="number">11</span>,  <span class="number">12</span>,  <span class="number">13</span>,  <span class="number">14</span>,  <span class="number">15</span>)),), &#123;&#125;, <span class="keyword">None</span>)</span><br><span class="line">……</span><br><span class="line">(result._job, <span class="number">15</span>, mapstar, ((func, (<span class="number">120</span>, <span class="number">121</span>, <span class="number">122</span>）),), &#123;&#125;, <span class="keyword">None</span>)</span><br><span class="line">注意每一个元组中的 i，它表示当前元组在整个任务元组集合中的位置，通过它，_handle_result线程才能将worker进程运行的结果，以正确的顺序填入到MapResult对象中。</span><br></pre></td></tr></table></figure><p>注意这里只调用了一次put方法，将16组元组作为一个整体序列放入任务队列，那么这个任务是否<code>_task_handler</code>线程是否也会像apply_async方法一样，将整个任务序列传递给<code>_inqueue</code>，这样就会导致进程池中的只有一个worker进程获取到任务序列，而并非起到多进程的处理方式。我们来看下<code>_task_handler</code>线程是怎样处理的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_handle_tasks</span><span class="params">(taskqueue, put, outqueue, pool, cache)</span>:</span></span><br><span class="line">    thread = threading.current_thread()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> taskseq, set_length <span class="keyword">in</span> iter(taskqueue.get, <span class="keyword">None</span>):</span><br><span class="line">        i = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i, task <span class="keyword">in</span> enumerate(taskseq):</span><br><span class="line">            <span class="keyword">if</span> thread._state:</span><br><span class="line">                debug(<span class="string">'task handler found thread._state != RUN'</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                put(task)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                job, ind = task[:<span class="number">2</span>]</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    cache[job]._set(ind, (<span class="keyword">False</span>, e))</span><br><span class="line">                <span class="keyword">except</span> KeyError:</span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> set_length:</span><br><span class="line">                debug(<span class="string">'doing set_length()'</span>)</span><br><span class="line">                set_length(i+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        debug(<span class="string">'task handler got sentinel'</span>)</span><br></pre></td></tr></table></figure><p>注意到语句 for i, task in enumerate(taskseq)，原来<code>_task_handler</code>线程在通过taskqueue获取到任务序列后，并不是直接放入<code>_inqueue</code>中的，而是将序列中任务按照之前分好的组，依次放入<code>_inqueue</code>中的，而循环中的task即上述的每个任务元组：(result._job, 0, mapstar, ((func, (0,  1,  2,  3,  4,  5,  6,  7)),), {}, None)。接着触发worker进程。worker进程获取出每组任务，进行任务的处理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">job, i, func, args, kwds = task </span><br><span class="line"><span class="keyword">try</span>: 　　</span><br><span class="line">    result = (<span class="keyword">True</span>, func(*args, **kwds))</span><br><span class="line"><span class="keyword">except</span> Exception, e:</span><br><span class="line">    result = (<span class="keyword">False</span>, e)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    put((job, i, result))</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    wrapped = MaybeEncodingError(e, result[<span class="number">1</span>])</span><br><span class="line">    debug(<span class="string">"Possible encoding error while sending result: %s"</span> % (</span><br><span class="line">        wrapped))</span><br><span class="line">    put((job, i, (<span class="keyword">False</span>, wrapped)))</span><br><span class="line"></span><br><span class="line">根据之前放入_inqueue的顺序对应关系：</span><br><span class="line">(result._job, <span class="number">0</span>, mapstar, ((func, (<span class="number">0</span>,   <span class="number">1</span>,   <span class="number">2</span>,   <span class="number">3</span>,   <span class="number">4</span>,   <span class="number">5</span>,   <span class="number">6</span>,   <span class="number">7</span>)),), &#123;&#125;, <span class="keyword">None</span>)</span><br><span class="line">job, i, func, args, kwds = task</span><br><span class="line">可以看出，元组中 mapstar 表示这里的回调函数func，((func, (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)),)和&#123;&#125;分别表示args和kwds参数。</span><br><span class="line">执行result = (<span class="keyword">True</span>, func(*args, **kwds))</span><br><span class="line">再来看下mapstar是如何定义的：</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mapstar</span><span class="params">(args)</span>:</span> </span><br><span class="line"><span class="keyword">return</span> map(*args)</span><br><span class="line">这里mapstar表示回调函数func，它的定义只有一个参数，而在worker进程执行回调时，使用的是func(*args, **kwds)语句，这里多一个参数能够正确执行吗？答案时肯定的，在调用mapstar时，如果kwds为空字典，那么传入第二个参数不会影响函数的调用，而一个无参函数func_with_none_params，在调用时使用func_with_none_params(*(), **&#123;&#125;)也是没有问题的，python会自动忽视传入的两个空参数。</span><br><span class="line">看到这里，我们明白了，实际上对任务参数分组后，每一组的任务是通过内建的map方法来进行调用的。</span><br><span class="line">运行之后调用put(job, i, result)将结果放入_outqueue中，_handle_result线程会从_outqueue中将结果取出，并找到_cache缓存中的MapResult对象，_set其运行结果</span><br></pre></td></tr></table></figure><p>现在来我们来总结下，进程池的map_async方法是如何运行的，我们将range(123)这个任务序列，将它传入map_async方法，假设不指定chunksize，并且cpu为四核，那么方法内部会分为16个组（0~14组每组8个元素，最后一组3个元素）。将分组后的任务放入任务队列，一共16组，那么每个进程需要运行4次来处理，每次通过内建的map方法，顺序将组中8个任务执行，再将结果放入<code>_outqueue</code>，找到<code>_cache</code>缓存中的MapResult对象，<code>_set</code>其运行结果，等待客户端获取。使用map_async方法会调用多个worker进程处理任务，每个worler进程运行结束，会将结果传入<code>_outqueue</code>，再有<code>_handle_result</code>线程将结果写入MapResult对象，那如何保证结果序列的顺序与调用map_async时传入的任务参数序列一致呢，我们来看看MapResult的构造函数和<code>_set</code>方法的实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, cache, chunksize, length, callback)</span>:</span></span><br><span class="line">    ApplyResult.__init__(self, cache, callback)</span><br><span class="line">    self._success = <span class="keyword">True</span></span><br><span class="line">    self._value = [<span class="keyword">None</span>] * length</span><br><span class="line">    self._chunksize = chunksize</span><br><span class="line">    <span class="keyword">if</span> chunksize &lt;= <span class="number">0</span>:</span><br><span class="line">        self._number_left = <span class="number">0</span></span><br><span class="line">        self._ready = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">del</span> cache[self._job]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self._number_left = length//chunksize + bool(length % chunksize)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_set</span><span class="params">(self, i, success_result)</span>:</span></span><br><span class="line">    success, result = success_result</span><br><span class="line">    <span class="keyword">if</span> success:</span><br><span class="line">        self._value[i*self._chunksize:(i+<span class="number">1</span>)*self._chunksize] = result</span><br><span class="line">        self._number_left -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self._number_left == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> self._callback:</span><br><span class="line">                self._callback(self._value)</span><br><span class="line">            <span class="keyword">del</span> self._cache[self._job]</span><br><span class="line">            self._cond.acquire()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self._ready = <span class="keyword">True</span></span><br><span class="line">                self._cond.notify()</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                self._cond.release()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self._success = <span class="keyword">False</span></span><br><span class="line">        self._value = result</span><br><span class="line">        <span class="keyword">del</span> self._cache[self._job]</span><br><span class="line">        self._cond.acquire()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self._ready = <span class="keyword">True</span></span><br><span class="line">            self._cond.notify()</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            self._cond.release()</span><br></pre></td></tr></table></figure><p>MapResult类中，<code>_value</code>保存map_async的运行结果，初始化时为一个元素为None的list，list的长度与任务参数序列的长度相同，<code>_chunksize</code>表示将任务分组后，每组有多少个任务，<code>_number_left</code>表示整个任务序列被分为多少个组。<code>_handle_result</code>线程会通过<code>_set</code>方法将worker进程的运行结果保存到<code>_value</code>中，那么如何将worker进程运行的结果填入到<code>_value</code>中正确的位置呢，还记得在map_async在向task_queue填入任务时，每组中的 i吗，i表示的就是当前任务组的组号，<code>_set</code>方法会根据当前任务的组号即参数 i，并且递减<code>_number_left</code>，当<code>_number_left</code>递减为0时，表示任务参数序列中的所有任务都已被woker进程处理，<code>_value</code>全部被计算出，唤醒阻塞在get方法上的条件变量，是客户端可以获取运行结果。</p><p>map函数为map_async的阻塞版本，它在map_async的基础上，调用get方法，直接阻塞到结果全部返回：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span><span class="params">(self, func, iterable, chunksize=None)</span>:</span>  </span><br><span class="line">  <span class="keyword">assert</span> self._state == RUN    </span><br><span class="line">  <span class="keyword">return</span> self.map_async(func, iterable, chunksize).get()</span><br></pre></td></tr></table></figure><p>我们知道，进程池内部由多个线程互相协作，向客户端提供可靠的服务，那么这些线程之间是怎样做到数据共享与同步的呢？在客户端使用apply/map函数向进程池分配任务时，使用<code>self._taskqueue</code>来存放任务元素，<code>_taskqueue</code>定义为Queue.Queue()，这是一个python标准库中的线程安全的同步队列，它保证通知时刻只有一个线程向队列添加或从队列获取元素。这样，主线程向进程池中分配任务（taskqueue.put），进程池中<code>_handle_tasks</code>线程读取<code>_taskqueue</code>队列中的元素，两个线程同时操作taskqueue，互不影响。进程池中有N个worker进程在等待任务下发，那么进程池中的<code>_handle_tasks</code>线程读取出任务后，又如何保证一个任务不被多个worker进程获取到呢？我们来看下<code>_handle_tasks</code>线程将任务读取出来之后如何交给worker进程的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> taskseq, set_length <span class="keyword">in</span> iter(taskqueue.get, <span class="keyword">None</span>):</span><br><span class="line">    i = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> i, task <span class="keyword">in</span> enumerate(taskseq):</span><br><span class="line">        <span class="keyword">if</span> thread._state:</span><br><span class="line">            debug(<span class="string">'task handler found thread._state != RUN'</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            put(task)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            job, ind = task[:<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                cache[job]._set(ind, (<span class="keyword">False</span>, e))</span><br><span class="line">            <span class="keyword">except</span> KeyError:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> set_length:</span><br><span class="line">            debug(<span class="string">'doing set_length()'</span>)</span><br><span class="line">            set_length(i+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    debug(<span class="string">'task handler got sentinel'</span>)</span><br><span class="line">在从taskqueue中get到任务之后，对任务中的每个task，调用了put函数，这个put函数实际上是将task放入了管道，而主进程与worker进程的交互，正是通过管道来完成的。</span><br><span class="line">再来看看worker进程的定义：</span><br><span class="line">w = self.Process(target=worker,</span><br><span class="line">                 args=(self._inqueue, self._outqueue,</span><br><span class="line">                         self._initializer,</span><br><span class="line">                   self._initargs, self._maxtasksperchild)</span><br><span class="line">            )</span><br><span class="line">其中self._inqueue和self._outqueue为SimpleQueue()对象，实际是带锁的管道，上述_handle_task线程调用的put函数，即为SimpleQueue对象的方法。我们看到，这里worker进程定义均相同，所以进程池中的worker进程共享self._inqueue和self._outqueue对象，那么当一个task元素被put到共享的_inqueue管道中时，如何确保只有一个worker获取到呢，答案同样是加锁，在SimpleQueue()类的定义中，put以及get方法都带有锁，进行同步，唯一不同的是，这里的锁是用于进程间同步的。这样就保证了多个worker之间能够确保任务的同步。与分配任务类似，在worker进程运行完之后，会将结果put会_outqueue，_outqueue同样是SimpleQueue类对象，可以在多个进程之间进行互斥。</span><br></pre></td></tr></table></figure><p>在worker进程运行结束之后，会将执行结果通过管道传回，进程池中有<code>_handle_result</code>线程来负责接收result，取出之后，通过调用<code>_set</code>方法将结果写回ApplyResult/MapResult对象，客户端可以通过get方法取出结果，这里通过使用条件变量进行同步，当<code>_set</code>函数执行之后，通过条件变量唤醒阻塞在get函数的主进程。</p><p>进程池终止工作通过调用Pool.terminate()来实现，这里的实现很巧妙，用了一个可调用对象，将终止Pool时的需要执行的回调函数先注册好，等到需要终止时，直接调用对象即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">self._terminate = Finalize(</span><br><span class="line">            　　　　self, self._terminate_pool,</span><br><span class="line">            　　　　args=(self._taskqueue, self._inqueue, self._outqueue, self._pool,</span><br><span class="line">                   self._worker_handler, self._task_handler,</span><br><span class="line">                   self._result_handler, self._cache),</span><br><span class="line">            　　　　exitpriority=<span class="number">15</span></span><br><span class="line">            )</span><br><span class="line">在Finalize类的实现了__call__方法，在运行self._terminate()时，就会调用构造self._terminate时传入的self._terminate_pool对象。</span><br></pre></td></tr></table></figure><p>使用map/map_async函数向进程池中批量分配任务时，使用了生成器表达式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self._taskqueue.put((((result._job, i, mapstar, (x,), &#123;&#125;) <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(task_batches)), <span class="keyword">None</span>))</span><br><span class="line">生成器表达式很简单，只需把列表解析的的[]换成()即可，上述表达的列表解析表示为：</span><br><span class="line">[(result._job, i, mapstar, (x,), &#123;&#125;) <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(task_batches)]</span><br><span class="line">这里使用生成器表达式的好处是，它相当于列表解析的扩展，是对内存有好的，因为它只是生成了一个生成器，当我们需要使用该生成器对应的逻辑目标数据时，它才会通过既定逻辑去生成该数据，所以不会大量占用内存。</span><br></pre></td></tr></table></figure><p>在Pool中，_worker_handler线程负责监控、创建新的工作进程，在监控工作进程退出时，同时将退出的进程从进程池中删除掉。这类似于，一边遍历一边删除列表。我们来看下下面代码的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> l:</span><br><span class="line">    <span class="keyword">if</span> i <span class="keyword">in</span> [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]:</span><br><span class="line">        l.remove(i)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>我们看到l没有将所有的3和4都删除掉，这是因为remove改变了l的大小。再看下面的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(len(l)):</span><br><span class="line">    <span class="keyword">if</span> l[i] <span class="keyword">in</span> [<span class="number">3</span>, <span class="number">4</span>]:</span><br><span class="line">        <span class="keyword">del</span> l[i]</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;pyshell#37&gt;"</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">if</span> l[i] <span class="keyword">in</span> [<span class="number">3</span>, <span class="number">4</span>]:</span><br><span class="line">IndexError: list index out of range</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>同样因为del l[i]时，l的大小改变，继续访问下去导致访问越界。而标准库中的进程池给出了遍历删除的一个正确示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(len(self._pool))):</span><br><span class="line">    worker = self._pool[i]   </span><br><span class="line">    <span class="keyword">if</span> worker.exitcode <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        worker.join()</span><br><span class="line">        cleaned = <span class="keyword">True</span>       </span><br><span class="line">        <span class="keyword">del</span> self._pool[i]</span><br></pre></td></tr></table></figure><p>使用reversed，从后向前删除list中的元素，这样会保证所有符合删除条件的元素被删除掉：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(len(l))):</span><br><span class="line">    <span class="keyword">if</span> l[i] <span class="keyword">in</span> [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]:</span><br><span class="line">        <span class="keyword">del</span> l[i]</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>原文：<a href="https://blog.51cto.com/u_11026142/1876989" target="_blank" rel="external">https://blog.51cto.com/u_11026142/1876989</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p id=&quot;div-border-top-green&quot;&gt;就算没有天分，只要你愿意每天花一点时间，做同样一件事情，不知不觉间，你就会走得很远。&lt;br&gt;&lt;/p&gt;

&lt;p&gt;上篇博文介绍了multiprocessing模块的内存共享，下面讲进程池。有些情况下，所要完成的工作可以上篇博文介绍了multiprocessing模块的内存共享，下面讲进程池。有些情况下，所要完成的工作可以分解并独立地分布到多个工作进程，对于这种简单的情况，可以用Pool类来管理固定数目的工作进程。作业的返回值会收集并作为一个列表返回。Pool可以提供指定数量的进程，供用户调用，当有新的请求提交到pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到规定最大值，那么该请求就会等待，直到池中有进程结束，才会创建新的进程来它。&lt;/p&gt;
&lt;p&gt;在网上找到了一篇非常好的分析进程池源码的文章，在这里跟大家分享下，篇幅比较长，希望大家能够有耐心的看完它，仔细体会。&lt;/p&gt;
&lt;p&gt;进程池使用multiprocessing.pool，pool的构造如下：&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://magiceses.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://magiceses.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python 进程线程协程(4)--multiprocessing模块(中)</title>
    <link href="https://magiceses.github.io/2019/10/11/python-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B-4.1/"/>
    <id>https://magiceses.github.io/2019/10/11/python-进程线程协程-4.1/</id>
    <published>2019-10-10T19:25:24.000Z</published>
    <updated>2021-10-11T07:17:25.631Z</updated>
    
    <content type="html"><![CDATA[<p id="div-border-top-green">生活的精彩，不只是轰轰烈烈，有的人你看了一辈子却忽视了一辈子，有的人你只看了一眼却影响了你的一生，有的人热情的为你而快乐却被你冷落，有的人让你拥有短暂的快乐却得到你思绪的连锁，有的人一个无心的表情却成了永恒的思念，这就是人生。<br></p><p>上篇博文介绍了Python的multiprocessing模块创建进程Process 类,进程间通信,进程间的同步三个部分，下面接着介绍学习进程共享。</p><h2 id="内存共享"><a href="#内存共享" class="headerlink" title="内存共享"></a>内存共享</h2><p>在多进程情况下，由于每个进程有自己独立的内存空间，怎样能实现内存共享呢？multiprocessing模块提供了Value, Array，这两个是函数，详细定义在sharedctypes.py里,有兴趣的可以去看看（等了解了ctypes模块后回头再分享下我的理解，今天就先放放）</p><a id="more"></a><h3 id="Value"><a href="#Value" class="headerlink" title="Value"></a><strong>Value</strong></h3><p>Value的初始化非常简单，直接类似Value(‘d’, 0.0)即可，具体构造方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multiprocessing.Value(typecode_or_type, *args[,lock])。</span><br></pre></td></tr></table></figure><p>返回从共享内存中分配的一个ctypes 对象,其中typecode_or_type定义了返回的类型。它要么是一个ctypes类型，要么是一个代表ctypes类型的code;</p><p>ctypes是Python的一个外部函数库，它提供了和C语言兼任的数据类型，可以调用DLLs或者共享库的函数，能被用作在python中包裹这些库;</p><p>*args是传递给ctypes的构造参数。</p><p>对于共享<strong>整数</strong>或者<strong>单个字符</strong>，初始化比较简单，参照下图映射关系：</p><p><img src="/images/python-process-1.png" alt="image-20211001130628878"></p><p>比如整数1，可用Value(‘h’,1)</p><p>如果共享的是<strong>字符串</strong>，则在上表是找不到映射关系的，就是没有对应的Type code可用。所以我们需要使用原始的ctype类型，对应关系如下：</p><p><img src="/images/python-process-2.png" alt="image-20211001130557103"></p><p>比如上面的Value(‘h’,1)也可以用Value(c_short,1)，字符串的话，可以用Value(c_char_p,”hello”)，很好理解的。</p><p>它返回的是个对象，所以，它也有一些属性和方法，而返回的对象是基于<strong>SynchronizedBase</strong>类，该类的定义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynchronizedBase</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, obj, lock=None)</span>:</span></span><br><span class="line">        self._obj = obj</span><br><span class="line">        self._lock = lock <span class="keyword">or</span> RLock()</span><br><span class="line">        self.acquire = self._lock.acquire</span><br><span class="line">        self.release = self._lock.release</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__reduce__</span><span class="params">(self)</span>:</span></span><br><span class="line">        assert_spawning(self)</span><br><span class="line">        <span class="keyword">return</span> synchronized, (self._obj, self._lock)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_obj</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._obj</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_lock</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._lock</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;%s wrapper for %s&gt;'</span> % (type(self).__name__, self._obj)</span><br></pre></td></tr></table></figure><p>所以它的属性和方法有：</p><ul><li>value：获取值;</li><li>get_lock()：获取锁对象;</li><li>acquire/release：参考RLock对象的acquire方法，release方法，是一样的，一个是获取锁，一个是释放锁。很好理解的。</li></ul><p>下面举个例子来体会一下这些方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Value,Process</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(val)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line">        val.value += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">v = Value(<span class="string">'i'</span>,<span class="number">0</span>)</span><br><span class="line">p_list = [Process(target=fun,args=(v,)) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> p_list:</span><br><span class="line">    p.start()</span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> p_list:</span><br><span class="line">    p.join()</span><br><span class="line"><span class="keyword">print</span> v.value</span><br></pre></td></tr></table></figure><p>上述代码是多个进程修改v值，我们期待它输出的是100，但是实际上并输出的并不是100，Value的构造函数默认的lock是True，它会创建一个锁对象用于同步访问控制，这就容易造成一个错误的意识，认为Value在多进程中是安全的，但实际上并不是，要想真正的控制同步访问，需要实现获取这个锁。所以需要修改fun()函数。如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(val)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line">        <span class="keyword">with</span> v.get_lock():</span><br><span class="line">            val.value += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>或者如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(val)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line">        <span class="keyword">if</span> v.acquire():</span><br><span class="line">            val.value += <span class="number">1</span></span><br><span class="line">        v.release()</span><br></pre></td></tr></table></figure><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a><strong>Array</strong></h3><p>有了上面的基础，这个就比较好理解了，它返回从共享内存分配的ctypes数组，原型如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multiprocessing.Array(typecode_or_type, size_or_initializer, *,lock=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>ypecode_or_type确定返回数组的元素的类型：它是一个ctypes类型或一个字符类型代码类型的<strong>数组</strong>模块使用的类型。</p><p>size_or_initializer：如果它是一个整数，那么它确定数组的长度，并且数组将被初始化为零。否则，size_or_initializer是用于初始化数组的序列，其长度决定数组的长度。</p><p>如果关键字参数中有lock的话，lock为True，则会创建一个新的锁对象，以同步对该值的访问。如果lock是Lock或RLock对象，那么它将用于同步对该值的访问。如果lock是False，那么对返回的对象的访问不会被锁自动保护，因此它不一定是“进程安全的”。</p><p>它返回值的属性和方法同Value差不多，有兴趣的可以自己写代码试试，在此不举例子。</p><h2 id="服务器进程"><a href="#服务器进程" class="headerlink" title="服务器进程"></a>服务器进程</h2><p>通过Manager()返回的一个manager对象控制一个服务器进程，它保持住Python对象并允许其它进程使用代理操作它们。同时它用起来很方便，而且支持本地和远程内存共享。</p><p>Manager()返回的manager支持的类型有list, dict, Namespace, Lock, RLock, Semaphore, BoundedSemaphore, Condition, Event, Queue, Value和Array。</p><p>该部分的实现在managers.py文件里，Manager()的定义很简单，如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Manager</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Returns a manager associated with a running server process</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The managers methods such as `Lock()`, `Condition()` and `Queue()`</span></span><br><span class="line"><span class="string">    can be used to create shared objects.</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">from</span> multiprocessing.managers <span class="keyword">import</span> SyncManager</span><br><span class="line">    m = SyncManager()</span><br><span class="line">    m.start()</span><br><span class="line">    <span class="keyword">return</span> m</span><br></pre></td></tr></table></figure><p>它返回一个已经启动的SyncManager对象，管理器进程将在垃圾收集或其父进程退出时立即关闭。SyncManager继承自BaseManager。BaseManager的定义也在managers.py文件里，有兴趣的可以看看，初始化如下：BaseManager([address[, authkey]])</p><p>address：是管理器进程侦听新连接的地址。 如果地址是无，则选择任意一个;</p><p>authkey：是将用于检查到服务器进程的传入连接的有效性的认证密钥。 如果authkey是None，那么使用当前进程current_process()的authkey； 否则使用的authkey，它必须是字符串;</p><p>一旦创建BaseManager对象，应调用start()或get_server()。serve_forever()以确保管理器对象引用已启动的管理器进程。</p><p>BaseManager对象的方法和属性有：</p><p><strong>start([initializer [，initargs]])</strong>：启动子过程以启动管理器。 如果初始化程序不是None，那么子程序在启动时会调用initializer(*initargs);</p><p><strong>get_server()：</strong> 返回一个Server对象，它表示在Manager控制下的实际服务器。 Server对象支持serve_forever()方法，Server对象也定义在managers.py文件里，该类的作用用因为解释就是“Server class which runs in a process controlled by a manager object”，有兴趣的可以去看看，了解下;</p><p><strong>connect()：</strong>将本地管理器对象连接到远程管理器进程;</p><p><strong>shutdown()：</strong>停止管理器在使用的进程。这仅在用start（）已启动服务器进程时可用，可以被多次调用;</p><p><strong>register(typeid [，callable [，proxytype [，exposed [，method_to_typeid [，create_method]]]]])：</strong>可以用于向管理器类注册类型或可调用的类方法。</p><ul><li>typeid是用于标识特定类型的共享对象的“类型标识符”。这必须是字符串;</li><li>callable是用于为该类型标识符创建可调用的对象。如果将使用from_address（）类方法创建管理器实例，或者如果create_method参数为False，那么这可以保留为None;</li><li>proxytype是BaseProxy的子类，BaseProxy使用typeid来创建共享对象的代理。如果为None，那么会自动创建一个代理类;</li><li>exposed用于指定一个序列的方法名称，该名称可以允许使用typeid的代理对象BaseProxy的<code>_callmethod()</code>方法来访问,(如果exposed为None，则使用<code>proxytype._exposed_</code>，如果存在）。在没有指定公开列表的情况下，将可以访问共享对象的所有“公共方法”。（这里的“公共方法”是指具有<code>__call __()</code>方法并且名称不以“_”开头的任何属性。）</li><li>method_to_typeid是一个映射，用于指定返回代理的那些公开方法的返回类型。它将方法名映射到typeid字符串。 （如果method_to_typeid为None，则使用proxytype._method_to<em>typeid</em>，如果存在）。如果方法的名称不是此映射的键，或者映射为None，则方法返回的对象将按值复制;</li><li>create_method确定是否应该使用名称typeid创建一个方法，该方法可以用于告诉服务器进程创建一个新的共享对象并为其返回一个代理。默认情况下为True;</li><li><strong>address：</strong>管理器使用的地址</li><li><strong>join(timeout=None)：</strong>阻塞</li></ul><p>现在可以来看看，SyncManager类的定义了，其实很简单。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncManager</span><span class="params">(BaseManager)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Subclass of `BaseManager` which supports a number of shared object types.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The types registered are those intended for the synchronization</span></span><br><span class="line"><span class="string">    of threads, plus `dict`, `list` and `Namespace`.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The `multiprocessing.Manager()` function creates started instances of</span></span><br><span class="line"><span class="string">    this class.</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">SyncManager.register(<span class="string">'Queue'</span>, Queue.Queue)</span><br><span class="line">SyncManager.register(<span class="string">'JoinableQueue'</span>, Queue.Queue)</span><br><span class="line">SyncManager.register(<span class="string">'Event'</span>, threading.Event, EventProxy)</span><br><span class="line">SyncManager.register(<span class="string">'Lock'</span>, threading.Lock, AcquirerProxy)</span><br><span class="line">SyncManager.register(<span class="string">'RLock'</span>, threading.RLock, AcquirerProxy)</span><br><span class="line">SyncManager.register(<span class="string">'Semaphore'</span>, threading.Semaphore, AcquirerProxy)</span><br><span class="line">SyncManager.register(<span class="string">'BoundedSemaphore'</span>, threading.BoundedSemaphore,</span><br><span class="line">                     AcquirerProxy)</span><br><span class="line">SyncManager.register(<span class="string">'Condition'</span>, threading.Condition, ConditionProxy)</span><br><span class="line">SyncManager.register(<span class="string">'Pool'</span>, Pool, PoolProxy)</span><br><span class="line">SyncManager.register(<span class="string">'list'</span>, list, ListProxy)</span><br><span class="line">SyncManager.register(<span class="string">'dict'</span>, dict, DictProxy)</span><br><span class="line">SyncManager.register(<span class="string">'Value'</span>, Value, ValueProxy)</span><br><span class="line">SyncManager.register(<span class="string">'Array'</span>, Array, ArrayProxy)</span><br><span class="line">SyncManager.register(<span class="string">'Namespace'</span>, Namespace, NamespaceProxy)</span><br><span class="line"></span><br><span class="line"><span class="comment"># types returned by methods of PoolProxy</span></span><br><span class="line">SyncManager.register(<span class="string">'Iterator'</span>, proxytype=IteratorProxy, create_method=<span class="keyword">False</span>)</span><br><span class="line">SyncManager.register(<span class="string">'AsyncResult'</span>, create_method=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure><p>上面的Queue()、Event()等等都是该类的方法，比如Event()，它是创建一个共享的threading.Event对象并返回一个代理。当然除了上面这些外，其实我们也可以用register()向管理器注册新的类型，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing.managers <span class="keyword">import</span> BaseManager</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MathsClass</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mul</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x * y</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyManager</span><span class="params">(BaseManager)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">MyManager.register(<span class="string">'Maths'</span>, MathsClass)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    manager = MyManager()</span><br><span class="line">    manager.start()</span><br><span class="line">    maths = manager.Maths()</span><br><span class="line">    <span class="keyword">print</span> maths.add(<span class="number">4</span>, <span class="number">3</span>)         <span class="comment"># prints 7</span></span><br><span class="line">    <span class="keyword">print</span> maths.mul(<span class="number">7</span>, <span class="number">8</span>)         <span class="comment"># prints 56</span></span><br></pre></td></tr></table></figure><p>下面看个简单的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(ns)</span>:</span></span><br><span class="line">    ns.x.append(<span class="number">1</span>)</span><br><span class="line">    ns.y.append(<span class="string">'x'</span>)</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    manager = multiprocessing.Manager()</span><br><span class="line">    ns = manager.Namespace()</span><br><span class="line">    ns.x = []</span><br><span class="line">    ns.y = []</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"before"</span>,ns</span><br><span class="line">    p = multiprocessing.Process(target=fun,args=(ns))</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"after"</span>,ns</span><br></pre></td></tr></table></figure><p>本程序的目的是想得到x=[1],y=[‘x’],但是没有得到，这是为什么呢？这是因为manager对象仅能传播一个可变对象本身所做的修改，如果一个manager.list()对象，管理列表本身的任何更改会传播到所有其他进程，但是如果容器对象内部还包括可修改对象，则内部可修改对象的任何更改都不会传播到其他进程。上面例子中，ns是一个容器，它本身的改变会传播到所有进程，但是它的内部对象x,y是可变对象，它们的改变不会传播到其他进程，所有没有得到我们所要的结果。可以作如下修改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(ns,x,y)</span>:</span></span><br><span class="line">    x.append(<span class="number">1</span>)</span><br><span class="line">    y.append(<span class="string">'x'</span>)</span><br><span class="line">    ns.x = x</span><br><span class="line">    ns.y = y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    manager = multiprocessing.Manager()</span><br><span class="line">    ns = manager.Namespace()</span><br><span class="line">    ns.x = []</span><br><span class="line">    ns.y = []</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"before"</span>,ns</span><br><span class="line">    p = multiprocessing.Process(target=fun,args=(ns,ns.x,ns.y,))</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"after"</span>,ns</span><br></pre></td></tr></table></figure><p>这个例子比较简单，以后碰到好的例子，再跟大家分享。另外Python官方手册上有很多帮助大家理解这些概念的例子，有兴趣的可以去看看，今天就写到这儿了，不正之处欢迎批评指正！下篇博文介绍进程池和线程池。</p><p>原文：<a href="https://blog.51cto.com/u_11026142/1874807" target="_blank" rel="external">https://blog.51cto.com/u_11026142/1874807</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p id=&quot;div-border-top-green&quot;&gt;生活的精彩，不只是轰轰烈烈，有的人你看了一辈子却忽视了一辈子，有的人你只看了一眼却影响了你的一生，有的人热情的为你而快乐却被你冷落，有的人让你拥有短暂的快乐却得到你思绪的连锁，有的人一个无心的表情却成了永恒的思念，这就是人生。&lt;br&gt;&lt;/p&gt;

&lt;p&gt;上篇博文介绍了Python的multiprocessing模块创建进程Process 类,进程间通信,进程间的同步三个部分，下面接着介绍学习进程共享。&lt;/p&gt;
&lt;h2 id=&quot;内存共享&quot;&gt;&lt;a href=&quot;#内存共享&quot; class=&quot;headerlink&quot; title=&quot;内存共享&quot;&gt;&lt;/a&gt;内存共享&lt;/h2&gt;&lt;p&gt;在多进程情况下，由于每个进程有自己独立的内存空间，怎样能实现内存共享呢？multiprocessing模块提供了Value, Array，这两个是函数，详细定义在sharedctypes.py里,有兴趣的可以去看看（等了解了ctypes模块后回头再分享下我的理解，今天就先放放）&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://magiceses.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://magiceses.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python 进程线程协程(4)--multiprocessing模块(上)</title>
    <link href="https://magiceses.github.io/2019/10/10/python-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B-4.0/"/>
    <id>https://magiceses.github.io/2019/10/10/python-进程线程协程-4.0/</id>
    <published>2019-10-09T19:25:24.000Z</published>
    <updated>2021-10-11T08:49:35.444Z</updated>
    
    <content type="html"><![CDATA[<p id="div-border-top-green">人生中你不要忘记奋斗，人生的路，无需苛求，时光如水，总是无言。转眼已是岁末，日子于平淡中匆匆走过，光阴流逝中有欢乐也有痛苦，有过平静也有过坎坷，我们就在这跌跌撞撞中继续人生的风雨兼程。<br></p><p>multiprocessing模块是Python提供的用于多进程开发的包，multiprocessing包提供本地和远程两种并发，通过使用子进程而非线程有效地回避了全局解释器锁。</p><h2 id="创建进程Process-类"><a href="#创建进程Process-类" class="headerlink" title="创建进程Process 类"></a>创建进程Process 类</h2><p>创建进程的类，其源码在multiprocessing包的process.py里，有兴趣的可以对照着源码边理解边学习。它的用法同threading.Thread差不多，从它的类定义上就可以看的出来，如下：<br><a id="more"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Process</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Process objects represent activity that is run in a separate process</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The class is analagous to `threading.Thread`</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    _Popen = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, group=None, target=None, name=None, args=<span class="params">()</span>, kwargs=&#123;&#125;)</span>:</span></span><br><span class="line">        <span class="keyword">assert</span> group <span class="keyword">is</span> <span class="keyword">None</span>, <span class="string">'group argument must be None for now'</span></span><br><span class="line">        count = _current_process._counter.next()</span><br><span class="line">        self._identity = _current_process._identity + (count,)</span><br><span class="line">        self._authkey = _current_process._authkey</span><br><span class="line">        self._daemonic = _current_process._daemonic</span><br><span class="line">        self._tempdir = _current_process._tempdir</span><br><span class="line">        self._parent_pid = os.getpid()</span><br><span class="line">        self._popen = <span class="keyword">None</span></span><br><span class="line">        self._target = target</span><br><span class="line">        self._args = tuple(args)</span><br><span class="line">        self._kwargs = dict(kwargs)</span><br><span class="line">        self._name = name <span class="keyword">or</span> type(self).__name__ + <span class="string">'-'</span> + \</span><br><span class="line">                     <span class="string">':'</span>.join(str(i) <span class="keyword">for</span> i <span class="keyword">in</span> self._identity)</span><br></pre></td></tr></table></figure><p>Process([group [, target [, name [, args [, kwargs]]]]])</p><ul><li>group实质上不使用,是保留项，便于以后扩展;</li><li>target表示调用对象;</li><li>args表示调用对象的位置参数元组;</li><li>kwargs表示调用对象的字典;</li><li>name为别名，即进程的名字;</li></ul><p>它的方法/属性跟threading.Thread也有很多类似的地方，主要有：</p><ul><li><p>start()：开始进程活动;</p></li><li><p>run()：表示进程的活动方法，可以在子类中覆盖它;</p></li><li><p>join([timeout])：是用来阻塞当前上下文，直至该进程运行结束，一个进程可以被join()多次，timeout单位是秒;</p></li><li><p>terminate()：结束进程。在Unix上使用的是SIGTERM，在Windows平台上使用TerminateProcess;</p></li><li><p>is_alive()：判断进程是否还活着;</p></li><li><p>name：一个字符串，表示进程的名字，也可以通过赋值语句利用它来修改进程的名字;</p></li><li><p>ident：进程的ID，如果进程没开始，结果是None;</p></li><li><p>pid：同ident，大家可以看看ident和pid的实现，是利用了os模块的getpid()方法;</p></li><li><p>authkey:设置/获取进程的授权密码。当初始化多进程时，使用os.urandom()为主进程分配一个随机字符串。当创建一个Process对象时，它将继承其父进程的认证密钥， 但是可以通过将authkey设置为另一个字节字符串来改变。这里authkey为什么既可以设置授权密码又可以获取呢？那是因为它的定义使用了property装饰器，源码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">authkey</span><span class="params">(self)</span>:</span></span><br><span class="line">   <span class="keyword">return</span> self._authkey</span><br><span class="line"></span><br><span class="line"><span class="meta">@authkey.setter</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">authkey</span><span class="params">(self, authkey)</span>:</span></span><br><span class="line">   <span class="string">'''</span></span><br><span class="line"><span class="string">    Set authorization key of process</span></span><br><span class="line"><span class="string">   '''</span></span><br><span class="line">   self._authkey = AuthenticationString(authkey)</span><br></pre></td></tr></table></figure><p>这是property的一个高级用法，如果理解了其实也很简单，有兴趣的去查看其它资料</p></li><li><p>daemon：一个布尔值，指示进程是(True)否(False)是一个守护进程。它必须在调用start()之前设置，否则会引发RuntimeError。它的初始值继承自创建它的进程；进程不是一个守护进程，所以在进程中创建的所有进程默认daemon = False</p></li><li><p>exitcode：返回进程退出时的代码。进程运行时其值为None，如果为–N，表示被信号N结束。</p></li></ul><h3 id="单进程示例"><a href="#单进程示例" class="headerlink" title="单进程示例"></a>单进程示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(interval)</span>:</span></span><br><span class="line">    n = <span class="number">5</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"The now is %s"</span>% datetime.datetime.now()</span><br><span class="line">        time.sleep(interval)</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line">    p = multiprocessing.Process(target = worker, args = (<span class="number">3</span>,))</span><br><span class="line">    p.start()<span class="comment">#开始进程</span></span><br><span class="line">    <span class="comment">#p.terminate()#结束进程</span></span><br><span class="line">    <span class="comment">#p.join(9)#阻塞当前上下文</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"p.authkey"</span>,p.authkey<span class="comment">#获取进程的授权密码</span></span><br><span class="line">    p.authkey = <span class="string">u"123"</span><span class="comment">#设置进程的授权密码</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"p.authkey"</span>, p.authkey<span class="comment">#获取进程的授权密码</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"p.pid:"</span>, p.pid,p.ident<span class="comment">#进程ID</span></span><br><span class="line">    p.name = <span class="string">'helloworld'</span><span class="comment">#修改进程名字</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"p.name:"</span>, p.name<span class="comment">#进程名字</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"p.is_alive:"</span>, p.is_alive()<span class="comment">#是否是活的</span></span><br></pre></td></tr></table></figure><p>运行结果如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p.authkey ��H�&#123;&lt;&#125;��2�&#125;�4GRU��B���k�g�`</span><br><span class="line">p.authkey 123</span><br><span class="line">p.pid: 16812 16812</span><br><span class="line">p.name: helloworld</span><br><span class="line">p.is_alive: True</span><br><span class="line">The now is 2021-10-01 12:47:49.605902</span><br><span class="line">The now is 2021-10-01 12:47:52.607205</span><br><span class="line">The now is 2021-10-01 12:47:55.608201</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure><p>上面的代码有两行注释掉的，大家可以把注释去掉，体会、理解这两个方法的用处，在此不贴我的运行结果了。</p><h3 id="自定义进程类"><a href="#自定义进程类" class="headerlink" title="自定义进程类"></a>自定义进程类</h3><p>自定义进程类，并开启多个进程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProcess</span><span class="params">(multiprocessing.Process)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    自定义进程类</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,interval,group=None,target=None,name=None,args=<span class="params">()</span>,kwargs=&#123;&#125;)</span>:</span></span><br><span class="line">        multiprocessing.Process.__init__(self,group,target,name,args,kwargs=kwargs)</span><br><span class="line">        self.interval = interval</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        n = <span class="number">5</span></span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">"the time is %s"</span>%datetime.datetime.now())</span><br><span class="line">            time.sleep(self.interval)</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker_1</span><span class="params">(interval)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"worker_1"</span></span><br><span class="line">    time.sleep(interval)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"end worker_1"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker_2</span><span class="params">(interval)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"worker_2"</span></span><br><span class="line">    time.sleep(interval)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"end worker_2"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker_3</span><span class="params">(interval)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"worker_3"</span></span><br><span class="line">    time.sleep(interval)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"end worker_3"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    p1 = MyProcess(interval=<span class="number">2</span>,target = worker_1, args = (<span class="number">2</span>,))</span><br><span class="line">    p2 = MyProcess(interval=<span class="number">2</span>,target = worker_2, args = (<span class="number">3</span>,))</span><br><span class="line">    p3 = MyProcess(interval=<span class="number">2</span>,target = worker_3, args = (<span class="number">4</span>,))</span><br><span class="line"></span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    p3.start()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"current process"</span>,multiprocessing.current_process(),multiprocessing.active_children()</span><br><span class="line">    print(<span class="string">"The number of CPU is:"</span> + str(multiprocessing.cpu_count()))</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> multiprocessing.active_children():</span><br><span class="line">        print(<span class="string">"child   p.name:"</span> + p.name + <span class="string">"\tp.id"</span> + str(p.pid))</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"END!!!!!!!!!!!!!!!!!"</span></span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">current process &lt;_MainProcess(MainProcess, started)&gt; [&lt;MyProcess(MyProcess-1, started)&gt;, &lt;MyProcess(MyProcess-3, started)&gt;, &lt;MyProcess(MyProcess-2, started)&gt;]</span><br><span class="line">the time is 2021-10-01 12:50:49.486355</span><br><span class="line">the time is 2021-10-01 12:50:49.486963</span><br><span class="line">the time is 2021-10-01 12:50:49.487489</span><br><span class="line">The number of CPU is:16</span><br><span class="line">child   p.name:MyProcess-1p.id16837</span><br><span class="line">child   p.name:MyProcess-3p.id16839</span><br><span class="line">child   p.name:MyProcess-2p.id16838</span><br><span class="line">END!!!!!!!!!!!!!!!!!</span><br><span class="line">the time is 2021-10-01 12:50:51.487652</span><br><span class="line">the time is 2021-10-01 12:50:51.487670</span><br><span class="line">the time is 2021-10-01 12:50:51.488012</span><br></pre></td></tr></table></figure><p>看看打印出来的时间，三个进程应该是并行执行的。</p><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>multiprocessing模块支持两种进程间的通信方式：Queue(队列)和Pipe(管道)。</p><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p>multiprocessing中的Queue类的定义在queues.py文件里。和Queue.Queue差不多，multiprocessing中的Queue类实现了Queue.Queue的大部分方法（可以参考上篇博文<a href="http://11026142.blog.51cto.com/11016142/1867877" target="_blank" rel="external"> Python：线程、进程与协程(3)——Queue模块及源码分析</a>），但task_done()和join()没有实现，主要方法和属性有:</p><ul><li>qsize()：返回Queue的大小;</li><li>empty()：返回一个布尔值，表示Queue是否为空;</li><li>full()：返回一个布尔值，表示Queue是否满;</li><li>put(item[, block[, timeout]])：向队列里添加元素item,block设置为False的时候，如果队列满了则抛出Full异常。如果block设置为True，timeout设置为None时，则会一种等到有空位的时候再添加进队列；否则会根据timeout设定的超时值抛出Full异常;</li><li>put_nowait(item)：等价与put(item,False);</li><li>get([block[, timeout]])：从队列中删除元素并返回该元素的值，如果timeout是一个正数，它会阻塞最多超时秒数，并且如果在该时间内没有可用的项目，则引发Empty异常;</li><li>get_nowait()：等价于get(False);</li><li>close()：表示该Queue不在加入新的元素;</li><li>join_thread()：加入后台线程。这只能在调用close（）之后使用。它阻塞直到后台线程退出，确保缓冲区中的所有数据都已刷新到管道。默认情况下，如果进程不是队列的创建者，则退出， 它将尝试加入队列的后台线程。 该进程可以调用cancel_join_thread()来做;</li><li>cancel_join_thread()：在阻塞中阻止join_thread()，防止后台线程在进程退出时被自动连接 ，肯能会导致数据丢失。</li></ul><h3 id="Pipe"><a href="#Pipe" class="headerlink" title="Pipe"></a>Pipe</h3><p>Pipe不是类，是函数，该函数定义在 multiprocessing中的connection.py里，函数原型Pipe(duplex=True)</p><p>返回一对通过管道连接的连接对象conn1和conn2。</p><p>如果duplex是True（默认值），则管道是双向的。</p><p>如果duplex是False，则管道是单向的：conn1只能用于接收消息，conn2只能用于发送消息。</p><p>Pipe()返回的两个连接对象表示管道的两端，每个连接对象都有send()和recv()方法（还有其它方法），分别是发送和接受消息。下面举个简单的例子，一个发送数据，一个接受数据:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proc1</span><span class="params">(pipe)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    发送数据</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">100</span>):</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"send: %s"</span> %(i)</span><br><span class="line">            pipe.send(i)<span class="comment">#发送数据</span></span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">proc2</span><span class="params">(pipe)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    接收数据</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"proc2 rev:"</span>, pipe.recv()<span class="comment">#接受数据</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    pipe1,pipe2 = multiprocessing.Pipe()<span class="comment">#返回两个连接对象</span></span><br><span class="line">    p1 = multiprocessing.Process(target=proc1, args=(pipe1,))</span><br><span class="line">    p2 = multiprocessing.Process(target=proc2, args=(pipe2,))</span><br><span class="line"></span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line"></span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">send: 0</span><br><span class="line">proc2 rev: 0</span><br><span class="line">send: 1</span><br><span class="line">proc2 rev: 1</span><br><span class="line">send: 2</span><br><span class="line">proc2 rev: 2</span><br><span class="line">send: 3</span><br><span class="line">proc2 rev: 3</span><br><span class="line">send: 4</span><br><span class="line">proc2 rev: 4</span><br><span class="line">send: 5</span><br><span class="line">proc2 rev: 5</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure><h2 id="进程间同步"><a href="#进程间同步" class="headerlink" title="进程间同步"></a>进程间同步</h2><p>multiprocessing包含与threading中所有同步原语等同的原语,它也有Lock，RLock，Even，Condition，Semaphore,BoundedSemaphore。用法都差不多，它们的定义在 multiprocessing包的synchronize.py文件里，在此不过多介绍，有兴趣的可以参考<a href="http://11026142.blog.51cto.com/11016142/1867519" target="_blank" rel="external"> Python：线程、进程与协程(2)——threading模块</a>里相关的概念理解。如果理解了相关概念，在 multiprocessing模块中使用是一样的，看下面这个简单的例子吧，有两个进程要向某个文件中写入内容，为了避免访问冲突，可以使用锁。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker_with</span><span class="params">(lock, f)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> lock:<span class="comment">#Lock等对象也是支持上下文管理器协议的。</span></span><br><span class="line">        fs = open(f, <span class="string">'a+'</span>)</span><br><span class="line">        n = <span class="number">10</span></span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">1</span>:</span><br><span class="line">            fs.write(<span class="string">"Lockd acquired via with\n"</span>)</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">        fs.close()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker_no_with</span><span class="params">(lock, f)</span>:</span></span><br><span class="line">    lock.acquire()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        fs = open(f, <span class="string">'a+'</span>)</span><br><span class="line">        n = <span class="number">10</span></span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">1</span>:</span><br><span class="line">            fs.write(<span class="string">"Lock acquired directly\n"</span>)</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">        fs.close()</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    lock = multiprocessing.Lock()<span class="comment">#定义锁</span></span><br><span class="line">    f = <span class="string">"/home/liulonghua/files.txt"</span></span><br><span class="line">    w = multiprocessing.Process(target = worker_with, args=(lock, f))</span><br><span class="line">    nw = multiprocessing.Process(target = worker_no_with, args=(lock, f))</span><br><span class="line">    w.start()</span><br><span class="line">    nw.start()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"end"</span></span><br></pre></td></tr></table></figure><p>multiprocessing提供了threading包中没有的IPC(比如Pipe和Queue)，效率上更高。应优先考虑Pipe和Queue，避免使用Lock/Event/Semaphore/Condition等同步方式 (因为它们占据的不是用户进程的资源)。</p><p>多进程应该避免共享资源。在多线程中，我们可以比较容易地共享资源，比如使用全局变量或者传递参数。在多进程情况下，由于每个进程有自己独立的内存空间，以上方法并不合适。此时我们可以通过共享内存和Manager的方法来共享资源。但这样做提高了程序的复杂度，并因为同步的需要而降低了程序的效率。下篇博文再接着讲进程共享和进程池等。</p><p>原文：<a href="https://blog.51cto.com/u_11026142/1873260" target="_blank" rel="external">https://blog.51cto.com/u_11026142/1873260</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p id=&quot;div-border-top-green&quot;&gt;人生中你不要忘记奋斗，人生的路，无需苛求，时光如水，总是无言。转眼已是岁末，日子于平淡中匆匆走过，光阴流逝中有欢乐也有痛苦，有过平静也有过坎坷，我们就在这跌跌撞撞中继续人生的风雨兼程。&lt;br&gt;&lt;/p&gt;

&lt;p&gt;multiprocessing模块是Python提供的用于多进程开发的包，multiprocessing包提供本地和远程两种并发，通过使用子进程而非线程有效地回避了全局解释器锁。&lt;/p&gt;
&lt;h2 id=&quot;创建进程Process-类&quot;&gt;&lt;a href=&quot;#创建进程Process-类&quot; class=&quot;headerlink&quot; title=&quot;创建进程Process 类&quot;&gt;&lt;/a&gt;创建进程Process 类&lt;/h2&gt;&lt;p&gt;创建进程的类，其源码在multiprocessing包的process.py里，有兴趣的可以对照着源码边理解边学习。它的用法同threading.Thread差不多，从它的类定义上就可以看的出来，如下：&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="https://magiceses.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://magiceses.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python 进程线程协程(0)--简单使用</title>
    <link href="https://magiceses.github.io/2019/10/08/python-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B-0/"/>
    <id>https://magiceses.github.io/2019/10/08/python-进程线程协程-0/</id>
    <published>2019-10-08T05:25:24.000Z</published>
    <updated>2021-10-11T08:53:10.091Z</updated>
    
    <content type="html"><![CDATA[<p id="div-border-top-green">生活从未变得容易，只不过是我们变得更加坚强，你若不想做，总会找到借口，你若想做，总会找到方法，输不起的人，往往也赢不了人，当你勇敢跨出第一步的时候你就已经赢了，犹豫一千次都不如实践一次，所有的努力和付出一定会有收获。<br></p><p>什么是线程？<br>为什么要使用多线程？<br>GIL 全局解释器<br><a id="more"></a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock,Thread</span><br><span class="line"><span class="keyword">import</span> time,os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">                                      python多线程详解</span></span><br><span class="line"><span class="string">      什么是线程？</span></span><br><span class="line"><span class="string">      线程也叫轻量级进程，是操作系统能够进行运算调度的最小单位，它被包涵在进程之中，是进程中的实际运作单位。</span></span><br><span class="line"><span class="string">      线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所</span></span><br><span class="line"><span class="string">      拥有的全部资源。一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    为什么要使用多线程？</span></span><br><span class="line"><span class="string">    线程在程序中是独立的、并发的执行流。与分隔的进程相比，进程中线程之间的隔离程度要小，它们共享内存、文件句柄</span></span><br><span class="line"><span class="string">    和其他进程应有的状态。</span></span><br><span class="line"><span class="string">    因为线程的划分尺度小于进程，使得多线程程序的并发性高。进程在执行过程之中拥有独立的内存单元，而多个线程共享</span></span><br><span class="line"><span class="string">    内存，从而极大的提升了程序的运行效率。</span></span><br><span class="line"><span class="string">    线程比进程具有更高的性能，这是由于同一个进程中的线程都有共性，多个线程共享一个进程的虚拟空间。线程的共享环境</span></span><br><span class="line"><span class="string">    包括进程代码段、进程的共有数据等，利用这些共享的数据，线程之间很容易实现通信。</span></span><br><span class="line"><span class="string">    操作系统在创建进程时，必须为改进程分配独立的内存空间，并分配大量的相关资源，但创建线程则简单得多。因此，使用多线程</span></span><br><span class="line"><span class="string">    来实现并发比使用多进程的性能高得要多。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    总结起来，使用多线程编程具有如下几个优点：</span></span><br><span class="line"><span class="string">    进程之间不能共享内存，但线程之间共享内存非常容易。</span></span><br><span class="line"><span class="string">    操作系统在创建进程时，需要为该进程重新分配系统资源，但创建线程的代价则小得多。因此使用多线程来实现多任务并发执行比使用多进程的效率高</span></span><br><span class="line"><span class="string">    python语言内置了多线程功能支持，而不是单纯地作为底层操作系统的调度方式，从而简化了python的多线程编程。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    普通创建方式</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># def run(n):</span></span><br><span class="line"><span class="comment">#     print('task',n)</span></span><br><span class="line"><span class="comment">#     time.sleep(1)</span></span><br><span class="line"><span class="comment">#     print('2s')</span></span><br><span class="line"><span class="comment">#     time.sleep(1)</span></span><br><span class="line"><span class="comment">#     print('1s')</span></span><br><span class="line"><span class="comment">#     time.sleep(1)</span></span><br><span class="line"><span class="comment">#     print('0s')</span></span><br><span class="line"><span class="comment">#     time.sleep(1)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># if __name__ == '__main__':</span></span><br><span class="line"><span class="comment">#     t1 = threading.Thread(target=run,args=('t1',))     # target是要执行的函数名（不是函数），args是函数对应的参数，以元组的形式存在</span></span><br><span class="line"><span class="comment">#     t2 = threading.Thread(target=run,args=('t2',))</span></span><br><span class="line"><span class="comment">#     t1.start()</span></span><br><span class="line"><span class="comment">#     t2.start()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    自定义线程：继承threading.Thread来定义线程类，其本质是重构Thread类中的run方法</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># class MyThread(threading.Thread):</span></span><br><span class="line"><span class="comment">#     def __init__(self,n):</span></span><br><span class="line"><span class="comment">#         super(MyThread,self).__init__()   #重构run函数必须写</span></span><br><span class="line"><span class="comment">#         self.n = n</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     def run(self):</span></span><br><span class="line"><span class="comment">#         print('task',self.n)</span></span><br><span class="line"><span class="comment">#         time.sleep(1)</span></span><br><span class="line"><span class="comment">#         print('2s')</span></span><br><span class="line"><span class="comment">#         time.sleep(1)</span></span><br><span class="line"><span class="comment">#         print('1s')</span></span><br><span class="line"><span class="comment">#         time.sleep(1)</span></span><br><span class="line"><span class="comment">#         print('0s')</span></span><br><span class="line"><span class="comment">#         time.sleep(1)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># if __name__ == '__main__':</span></span><br><span class="line"><span class="comment">#     t1 = MyThread('t1')</span></span><br><span class="line"><span class="comment">#     t2 = MyThread('t2')</span></span><br><span class="line"><span class="comment">#     t1.start()</span></span><br><span class="line"><span class="comment">#     t2.start()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    守护线程</span></span><br><span class="line"><span class="string">    下面这个例子，这里使用setDaemon(True)把所有的子线程都变成了主线程的守护线程，</span></span><br><span class="line"><span class="string">    因此当主线程结束后，子线程也会随之结束，所以当主线程结束后，整个程序就退出了。</span></span><br><span class="line"><span class="string">    所谓’线程守护’，就是主线程不管该线程的执行情况，只要是其他子线程结束且主线程执行完毕，主线程都会关闭。也就是说:主线程不等待该守护线程的执行完再去关闭。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># def run(n):</span></span><br><span class="line"><span class="comment">#     print('task',n)</span></span><br><span class="line"><span class="comment">#     time.sleep(1)</span></span><br><span class="line"><span class="comment">#     print('3s')</span></span><br><span class="line"><span class="comment">#     time.sleep(1)</span></span><br><span class="line"><span class="comment">#     print('2s')</span></span><br><span class="line"><span class="comment">#     time.sleep(1)</span></span><br><span class="line"><span class="comment">#     print('1s')</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># if __name__ == '__main__':</span></span><br><span class="line"><span class="comment">#     t=threading.Thread(target=run,args=('t1',))</span></span><br><span class="line"><span class="comment">#     t.setDaemon(True)</span></span><br><span class="line"><span class="comment">#     t.start()</span></span><br><span class="line"><span class="comment">#     print('end')</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    通过执行结果可以看出，设置守护线程之后，当主线程结束时，子线程也将立即结束，不再执行</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    主线程等待子线程结束</span></span><br><span class="line"><span class="string">    为了让守护线程执行结束之后，主线程再结束，我们可以使用join方法，让主线程等待子线程执行</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># def run(n):</span></span><br><span class="line"><span class="comment">#     print('task',n)</span></span><br><span class="line"><span class="comment">#     time.sleep(2)</span></span><br><span class="line"><span class="comment">#     print('5s')</span></span><br><span class="line"><span class="comment">#     time.sleep(2)</span></span><br><span class="line"><span class="comment">#     print('3s')</span></span><br><span class="line"><span class="comment">#     time.sleep(2)</span></span><br><span class="line"><span class="comment">#     print('1s')</span></span><br><span class="line"><span class="comment"># if __name__ == '__main__':</span></span><br><span class="line"><span class="comment">#     t=threading.Thread(target=run,args=('t1',))</span></span><br><span class="line"><span class="comment">#     t.setDaemon(True)    #把子线程设置为守护线程，必须在start()之前设置</span></span><br><span class="line"><span class="comment">#     t.start()</span></span><br><span class="line"><span class="comment">#     t.join()     #设置主线程等待子线程结束</span></span><br><span class="line"><span class="comment">#     print('end')</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    多线程共享全局变量</span></span><br><span class="line"><span class="string">    线程时进程的执行单元，进程时系统分配资源的最小执行单位，所以在同一个进程中的多线程是共享资源的</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># g_num = 100</span></span><br><span class="line"><span class="comment"># def work1():</span></span><br><span class="line"><span class="comment">#     global  g_num</span></span><br><span class="line"><span class="comment">#     for i in range(3):</span></span><br><span class="line"><span class="comment">#         g_num+=1</span></span><br><span class="line"><span class="comment">#     print('in work1 g_num is : %d' % g_num)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># def work2():</span></span><br><span class="line"><span class="comment">#     global g_num</span></span><br><span class="line"><span class="comment">#     print('in work2 g_num is : %d' % g_num)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># if __name__ == '__main__':</span></span><br><span class="line"><span class="comment">#     t1 = threading.Thread(target=work1)</span></span><br><span class="line"><span class="comment">#     t1.start()</span></span><br><span class="line"><span class="comment">#     time.sleep(1)</span></span><br><span class="line"><span class="comment">#     t2=threading.Thread(target=work2)</span></span><br><span class="line"><span class="comment">#     t2.start()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">        由于线程之间是进行随机调度，并且每个线程可能只执行n条执行之后，当多个线程同时修改同一条数据时可能会出现脏数据，</span></span><br><span class="line"><span class="string">    所以出现了线程锁，即同一时刻允许一个线程执行操作。线程锁用于锁定资源，可以定义多个锁，像下面的代码，当需要独占</span></span><br><span class="line"><span class="string">    某一个资源时，任何一个锁都可以锁定这个资源，就好比你用不同的锁都可以把这个相同的门锁住一样。</span></span><br><span class="line"><span class="string">        由于线程之间是进行随机调度的，如果有多个线程同时操作一个对象，如果没有很好地保护该对象，会造成程序结果的不可预期，</span></span><br><span class="line"><span class="string">    我们因此也称为“线程不安全”。</span></span><br><span class="line"><span class="string">        为了防止上面情况的发生，就出现了互斥锁（Lock）</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># def work():</span></span><br><span class="line"><span class="comment">#     global n</span></span><br><span class="line"><span class="comment">#     lock.acquire()</span></span><br><span class="line"><span class="comment">#     temp = n</span></span><br><span class="line"><span class="comment">#     time.sleep(0.1)</span></span><br><span class="line"><span class="comment">#     n = temp-1</span></span><br><span class="line"><span class="comment">#     lock.release()</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># if __name__ == '__main__':</span></span><br><span class="line"><span class="comment">#     lock = Lock()</span></span><br><span class="line"><span class="comment">#     n = 100</span></span><br><span class="line"><span class="comment">#     l = []</span></span><br><span class="line"><span class="comment">#     for i in range(100):</span></span><br><span class="line"><span class="comment">#         p = Thread(target=work)</span></span><br><span class="line"><span class="comment">#         l.append(p)</span></span><br><span class="line"><span class="comment">#         p.start()</span></span><br><span class="line"><span class="comment">#     for p in l:</span></span><br><span class="line"><span class="comment">#         p.join()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    递归锁：RLcok类的用法和Lock类一模一样，但它支持嵌套，在多个锁没有释放的时候一般会使用RLock类</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># def func(lock):</span></span><br><span class="line"><span class="comment">#     global gl_num</span></span><br><span class="line"><span class="comment">#     lock.acquire()</span></span><br><span class="line"><span class="comment">#     gl_num += 1</span></span><br><span class="line"><span class="comment">#     time.sleep(1)</span></span><br><span class="line"><span class="comment">#     print(gl_num)</span></span><br><span class="line"><span class="comment">#     lock.release()</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># if __name__ == '__main__':</span></span><br><span class="line"><span class="comment">#     gl_num = 0</span></span><br><span class="line"><span class="comment">#     lock = threading.RLock()</span></span><br><span class="line"><span class="comment">#     for i in range(10):</span></span><br><span class="line"><span class="comment">#         t = threading.Thread(target=func,args=(lock,))</span></span><br><span class="line"><span class="comment">#         t.start()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    信号量（BoundedSemaphore类）</span></span><br><span class="line"><span class="string">    互斥锁同时只允许一个线程更改数据，而Semaphore是同时允许一定数量的线程更改数据，比如厕所有3个坑，</span></span><br><span class="line"><span class="string">    那最多只允许3个人上厕所，后面的人只能等里面有人出来了才能再进去</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># def run(n,semaphore):</span></span><br><span class="line"><span class="comment">#     semaphore.acquire()   #加锁</span></span><br><span class="line"><span class="comment">#     time.sleep(3)</span></span><br><span class="line"><span class="comment">#     print('run the thread:%s\n' % n)</span></span><br><span class="line"><span class="comment">#     semaphore.release()    #释放</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># if __name__== '__main__':</span></span><br><span class="line"><span class="comment">#     num=0</span></span><br><span class="line"><span class="comment">#     semaphore = threading.BoundedSemaphore(5)   #最多允许5个线程同时运行</span></span><br><span class="line"><span class="comment">#     for i in range(22):</span></span><br><span class="line"><span class="comment">#         t = threading.Thread(target=run,args=('t-%s' % i,semaphore))</span></span><br><span class="line"><span class="comment">#         t.start()</span></span><br><span class="line"><span class="comment">#     while threading.active_count() !=1:</span></span><br><span class="line"><span class="comment">#         pass</span></span><br><span class="line"><span class="comment">#     else:</span></span><br><span class="line"><span class="comment">#         print('----------all threads done-----------')</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    python线程的事件用于主线程控制其他线程的执行，事件是一个简单的线程同步对象，其主要提供以下的几个方法：</span></span><br><span class="line"><span class="string">        clear将flag设置为 False</span></span><br><span class="line"><span class="string">        set将flag设置为 True</span></span><br><span class="line"><span class="string">        is_set判断是否设置了flag</span></span><br><span class="line"><span class="string">        wait会一直监听flag，如果没有检测到flag就一直处于阻塞状态</span></span><br><span class="line"><span class="string">    事件处理的机制：全局定义了一个Flag，当Flag的值为False，那么event.wait()就会阻塞，当flag值为True，</span></span><br><span class="line"><span class="string">    那么event.wait()便不再阻塞</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">event = threading.Event()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lighter</span><span class="params">()</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    event.set()         <span class="comment">#初始者为绿灯</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="number">5</span> &lt; count &lt;=<span class="number">10</span>:</span><br><span class="line">            event.clear()  <span class="comment">#红灯，清除标志位</span></span><br><span class="line">            print(<span class="string">"\33[41;lmred light is on...\033[0m]"</span>)</span><br><span class="line">        <span class="keyword">elif</span> count &gt; <span class="number">10</span>:</span><br><span class="line">            event.set()    <span class="comment">#绿灯，设置标志位</span></span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'\33[42;lmgreen light is on...\033[0m'</span>)</span><br><span class="line"></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">car</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">if</span> event.is_set():     <span class="comment">#判断是否设置了标志位</span></span><br><span class="line">            print(<span class="string">'[%s] running.....'</span>%name)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'[%s] sees red light,waiting...'</span>%name)</span><br><span class="line">            event.wait()</span><br><span class="line">            print(<span class="string">'[%s] green light is on,start going...'</span>%name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># startTime = time.time()</span></span><br><span class="line">light = threading.Thread(target=lighter,)</span><br><span class="line">light.start()</span><br><span class="line"></span><br><span class="line">car = threading.Thread(target=car,args=(<span class="string">'MINT'</span>,))</span><br><span class="line">car.start()</span><br><span class="line">endTime = time.time()</span><br><span class="line"><span class="comment"># print('用时：',endTime-startTime)</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">                           GIL  全局解释器</span></span><br><span class="line"><span class="string">        在非python环境中，单核情况下，同时只能有一个任务执行。多核时可以支持多个线程同时执行。但是在python中，无论有多少个核</span></span><br><span class="line"><span class="string">        同时只能执行一个线程。究其原因，这就是由于GIL的存在导致的。</span></span><br><span class="line"><span class="string">        GIL的全程是全局解释器，来源是python设计之初的考虑，为了数据安全所做的决定。某个线程想要执行，必须先拿到GIL，我们可以</span></span><br><span class="line"><span class="string">        把GIL看做是“通行证”，并且在一个python进程之中，GIL只有一个。拿不到线程的通行证，并且在一个python进程中，GIL只有一个，</span></span><br><span class="line"><span class="string">        拿不到通行证的线程，就不允许进入CPU执行。GIL只在cpython中才有，因为cpython调用的是c语言的原生线程，所以他不能直接操</span></span><br><span class="line"><span class="string">        作cpu，而只能利用GIL保证同一时间只能有一个线程拿到数据。而在pypy和jpython中是没有GIL的</span></span><br><span class="line"><span class="string">        python在使用多线程的时候，调用的是c语言的原生过程。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">                            python针对不同类型的代码执行效率也是不同的</span></span><br><span class="line"><span class="string">        1、CPU密集型代码（各种循环处理、计算等），在这种情况下，由于计算工作多，ticks技术很快就会达到阀值，然后出发GIL的</span></span><br><span class="line"><span class="string">        释放与再竞争（多个线程来回切换当然是需要消耗资源的），所以python下的多线程对CPU密集型代码并不友好。</span></span><br><span class="line"><span class="string">        2、IO密集型代码（文件处理、网络爬虫等设计文件读写操作），多线程能够有效提升效率（单线程下有IO操作会进行IO等待，</span></span><br><span class="line"><span class="string">        造成不必要的时间浪费，而开启多线程能在线程A等待时，自动切换到线程B，可以不浪费CPU的资源，从而能提升程序的执行</span></span><br><span class="line"><span class="string">        效率）。所以python的多线程对IO密集型代码比较友好。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    主要要看任务的类型，我们把任务分为I/O密集型和计算密集型，而多线程在切换中又分为I/O切换和时间切换。如果任务属于是I/O密集型，</span></span><br><span class="line"><span class="string">    若不采用多线程，我们在进行I/O操作时，势必要等待前面一个I/O任务完成后面的I/O任务才能进行，在这个等待的过程中，CPU处于等待</span></span><br><span class="line"><span class="string">    状态，这时如果采用多线程的话，刚好可以切换到进行另一个I/O任务。这样就刚好可以充分利用CPU避免CPU处于闲置状态，提高效率。但是</span></span><br><span class="line"><span class="string">    如果多线程任务都是计算型，CPU会一直在进行工作，直到一定的时间后采取多线程时间切换的方式进行切换线程，此时CPU一直处于工作状态，</span></span><br><span class="line"><span class="string">    此种情况下并不能提高性能，相反在切换多线程任务时，可能还会造成时间和资源的浪费，导致效能下降。这就是造成上面两种多线程结果不能的解释。</span></span><br><span class="line"><span class="string">结论:I/O密集型任务，建议采取多线程，还可以采用多进程+协程的方式(例如:爬虫多采用多线程处理爬取的数据)；对于计算密集型任务，python此时就不适用了。</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="https://blog.51cto.com/u_11026142/category1.html" target="_blank" rel="external">python 相关知识总结</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p id=&quot;div-border-top-green&quot;&gt;生活从未变得容易，只不过是我们变得更加坚强，你若不想做，总会找到借口，你若想做，总会找到方法，输不起的人，往往也赢不了人，当你勇敢跨出第一步的时候你就已经赢了，犹豫一千次都不如实践一次，所有的努力和付出一定会有收获。&lt;br&gt;&lt;/p&gt;

&lt;p&gt;什么是线程？&lt;br&gt;为什么要使用多线程？&lt;br&gt;GIL 全局解释器&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="https://magiceses.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://magiceses.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python 进程线程协程(1)--概念</title>
    <link href="https://magiceses.github.io/2019/10/08/python-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B-1/"/>
    <id>https://magiceses.github.io/2019/10/08/python-进程线程协程-1/</id>
    <published>2019-10-07T19:25:24.000Z</published>
    <updated>2021-10-02T03:03:07.654Z</updated>
    
    <content type="html"><![CDATA[<p id="div-border-top-green">年龄就像是验金石。人们到了一定的年龄之后，一类人变得越发有趣，一类人变得越发无聊。前者开始创造生活，后者开始被生活创造。不幸的是，大多数人偷懒，愿意把后半生的命运交给前半生的惯性。幸运的是，一小部分人开始有能力刹住边性，去重新定位方向。<br></p><p>最近的业余时间主要放在了学习Python线程、进程和协程里，第一次用python的多线程和多进程是在两个月前，当时只是简单的看了几篇博文然后就跟着用，没有仔细去研究，第一次用的感觉它们其实挺简单的，最近这段时间通过看书， 看Python 中文官方文档等等相关资料，发现并没有想想中的那么简单，很多知识点需要仔细去理解，Python线程、进程和协程应该是Python的高级用法。Python的高级用法有很多，看看Python 中文官方文档就知道了，当然有时间看看这些模块是怎么实现的对自己的提高是很有帮助的。选择了编程这个行业，就是要不断的学习、思考、归纳总结经验，路漫漫其修远兮，吾将上下而求索，希望能与各位共勉。接下来要花好几篇博文的篇幅来讲讲我学习线程、进程和协程的经验，有讲得不好的地方，希望大家批评指正。这篇博文主要讲讲与之有关的概念。</p><a id="more"></a><h2 id="线程与多线程"><a href="#线程与多线程" class="headerlink" title="线程与多线程"></a>线程与多线程</h2><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul><li>线程，有时被称为轻量级进程(Lightweight Process，LWP），是程序执行流的最小单元；</li><li>一个标准的线程由线程ID，当前指令指针(PC），寄存器集合和堆栈组成。有了这些它能够记录自己运行到了什么地方，可以称为线程的上下文；</li><li>线程的运行可能被抢占(中断)或暂时的被挂起(也叫睡眠)让其它的线程运行，这叫做让步；</li><li>线程也有就绪、阻塞和运行三种基本状态。就绪状态是指线程具备运行的所有条件，逻辑上可以运行，在等待处理机；运行状态是指线程占有处理机正在运行；阻塞状态是指线程在等待一个事件（如某个信号量），逻辑上不可执行</li><li>线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不独立拥有系统资源，但它可与同属一个进程的其它线程共享该进程所拥有的全部资源。</li></ul><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><ul><li><p>每一个应用程序都至少有一个进程和一个线程。线程是程序中一个单一的顺序控制流程。在单个程序中同时运行多个线程完成不同的被划分成一块一块的工作，称为多线程；</p></li><li><p>很好理解，开发软件就是每个人或者每个小组负责一个模块，当所有人（组）相关的模块都编写完后，就开始合并代码，然后就测试，修复bug</p><p>除非代码依赖第方资源，否则在单处理器的机器上使用多线程，不会加速代码的执行速度，甚至会增加一些线程管理的开销；</p><p>实际上，在单处理器的系统中，每个线程会被安排成每次只运行一小会，然后就把CPU让出来，让其它的线程去运行。比如线程切换等等，这些都是要花费资源和时间的，所以在单CPU机器上使用多线程有时候不但感觉不到执行速度变快，反而变慢了；</p></li><li><p>多线程会从多处理器或者多核的机器上获益，它会在每个处理器上并行执行每个线程，从而提高执行速度；</p></li><li><p>线程之间可以共享运行结果。但是这样做有一定的危险，比如两个线程更新同一个数据，但是这两个线程运行的结果不一样，这叫做竞态条件，这个会造成竞争危害，会发生不可预测的结果。所以利用锁机制可以保护数据。</p></li></ul><h3 id="Python中的多线程"><a href="#Python中的多线程" class="headerlink" title="Python中的多线程"></a>Python中的多线程</h3><p>python的多线程并没有想象中的那么理想，是因为有一个叫GIL的东西在限制。那什么是GIL呢？GIL中文名叫全局解释器锁，是python虚拟机上用作<strong>互斥线程</strong>的一种机制，<strong>它的作用就是要保证在任何情况下虚拟机上只有一个线程被运行，而其它线程都处在等待GIL锁被释放的状态</strong>。所以它是个“伪多线程”，它的情况就跟上面说的在单处理器机器上运行多线程一样，不会加速代码的执行速度，甚至会增加一些线程管理的开销。</p><p>python虚拟机上多线程是按如下方式执行的：</p><ul><li>a、设置 GIL</li><li>b、切换到一个线程去运行；</li><li>c、运行指定数量的字节码指令或者线程主动让出控制(可以调用 time.sleep(0))；</li><li>d、把线程设置为睡眠状态；</li><li>e、解锁 GIL；</li><li>f、再次重复以上所有步骤</li></ul><p>在调用外部代码(如 C/C++扩展函数)的时候，GIL将会被锁定，直到这个函数结束为止(由于在这期间没有Python的字节码被运行，所以不会做线程切换)。比如带有I/O操作(会调用内建的操作系统C代码，I/O操作就是输入输出操作，要想详细了解它可以参考其它资料)的线程，GIL会在这个I/O操作被调用之前就被释放。</p><p>对于纯计算的程序，没有I/O操作，解释器会根据sys.ssetcheckinterval()的设置来自动进行线程间的切换，默认情况下是每隔100个时钟就会释放GIL锁从而轮换到其它线程执行。</p><p>那为什么Python中还要在多线程中引入GIL呢？是为了<strong>保证对虚拟机内部共享资源访问的互斥性</strong>。python对象的对象管理与引用计数器密切相关，当计数器的值为0，该对象会被垃圾回收器回收(不了解这块知识的可以在网上查找相关资料或者看《Python源码解析》这本书)，当撤销对一个对象的引用时，python解释器会对该对象以及其计数器管理进行以下两步操作：</p><ul><li>a、使引用计数器减1</li><li>b、判断计数器的值是否为0，如果为0，则销毁该对象</li></ul><p>假设现在有A、B两个线程同时引用同一个对象obj，这时obj对象的引用计数器的值就为2,如果现在A线程打算撤销对obj的引用，当执行完第一步”使引用计数器值减1“的时候，由于存在多线程调度机制，A恰好在这个关键点被挂起了，而进入了B线程执行的状态，如果这个时候B线程也是要撤销对obj的引用，并且完成了上面的a,b两个步骤，这时obj的引用计数器就是0了，obj对象就被销毁了，内存被释放出来了，麻烦就可能出现了，当A线程再次被唤醒时，它肯定会接着执行上面的b步骤，结果发现已经面目全非了，那么其操作结果完全未知。所以引入了GIL，<strong>保证对虚拟机内部共享资源访问的互斥性。</strong></p><p>GIL的引入使多线程不能在多核系统中发挥优势，但也带来了一些好处，就是大大简化了Python线程中共享资源的管理。不过Python提供了其它方式绕过了GIL的局限性来充分利用多核的计算能力，比如多进程multiprocessing模块、C语言扩展方式、ctypes库等等。</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程（有时被称为重量级进程）是程序的一次执行。每个进程都有自己的地址空间、内存、数据栈以及其它记录其运行轨迹的辅助数据。操作系统管理在其上运行的所有进程，并为这些进程公平地分配时间。进程也可以通过fork和spawn操作来完成其它的任务，不过各个进程有自己的内存空间、数据栈等，所以只能使用进程间通讯（IPC），而不能直接共享信息。</p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><ul><li>协程是一种用户级的轻量级线程，不同于线程的地方在于协程不是操作系统进行切换，而是由程序员编码进行切换的，也就是说切换是由程序员控制的，这样就没有了线程所谓的安全问题；</li><li>协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。</li></ul><p>python里面怎么使用协程？答案是使用gevent模块。使用协程，可以不受线程开销的限制。所以最推荐的方法，是多进程+协程（可以看作是每个进程里都是单线程，而这个单线程是协程化的）多进程+协程下，避开了CPU切换的开销，又能把多个CPU充分利用起来。</p><p>原文： <a href="https://blog.51cto.com/u_11026142/1864799" target="_blank" rel="external">Python：线程、进程与协程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p id=&quot;div-border-top-green&quot;&gt;年龄就像是验金石。人们到了一定的年龄之后，一类人变得越发有趣，一类人变得越发无聊。前者开始创造生活，后者开始被生活创造。不幸的是，大多数人偷懒，愿意把后半生的命运交给前半生的惯性。幸运的是，一小部分人开始有能力刹住边性，去重新定位方向。&lt;br&gt;&lt;/p&gt;

&lt;p&gt;最近的业余时间主要放在了学习Python线程、进程和协程里，第一次用python的多线程和多进程是在两个月前，当时只是简单的看了几篇博文然后就跟着用，没有仔细去研究，第一次用的感觉它们其实挺简单的，最近这段时间通过看书， 看Python 中文官方文档等等相关资料，发现并没有想想中的那么简单，很多知识点需要仔细去理解，Python线程、进程和协程应该是Python的高级用法。Python的高级用法有很多，看看Python 中文官方文档就知道了，当然有时间看看这些模块是怎么实现的对自己的提高是很有帮助的。选择了编程这个行业，就是要不断的学习、思考、归纳总结经验，路漫漫其修远兮，吾将上下而求索，希望能与各位共勉。接下来要花好几篇博文的篇幅来讲讲我学习线程、进程和协程的经验，有讲得不好的地方，希望大家批评指正。这篇博文主要讲讲与之有关的概念。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://magiceses.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://magiceses.github.io/tags/Python/"/>
    
  </entry>
  
</feed>
