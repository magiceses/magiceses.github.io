<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Courier New:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Prometheus,Alertmanager," />





  <link rel="alternate" href="/atom.xml" title="天青色等烟雨" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon/favicon.ico?v=5.0.1" />






<meta name="description" content="人生不过如此，且行且珍惜，每一次的失败，都是成功的伏笔；每一次的考验，都有一份收获；每一次的泪水，都有一次醒悟；每一次的磨难，都有生命的财富。

高可用简介之前我们主要讨论了Prometheus Server自身的高可用问题。而接下来，重点将放在告警处理也就是Alertmanager部分。如下所示。

为了提升Promthues的服务可用性，通常用户会部署两个或者两个以上的Promthus Ser">
<meta property="og:type" content="article">
<meta property="og:title" content="Alertmanager 高可用总结-上">
<meta property="og:url" content="https://magiceses.github.io/2020/12/24/prometheus-alertmanager-高可用总结-上/index.html">
<meta property="og:site_name" content="天青色等烟雨">
<meta property="og:description" content="人生不过如此，且行且珍惜，每一次的失败，都是成功的伏笔；每一次的考验，都有一份收获；每一次的泪水，都有一次醒悟；每一次的磨难，都有生命的财富。

高可用简介之前我们主要讨论了Prometheus Server自身的高可用问题。而接下来，重点将放在告警处理也就是Alertmanager部分。如下所示。

为了提升Promthues的服务可用性，通常用户会部署两个或者两个以上的Promthus Ser">
<meta property="og:image" content="https://magiceses.github.io/images/prometheus-alertmanager-0.png">
<meta property="og:image" content="https://magiceses.github.io/images/prometheus-alertmanager-1.png">
<meta property="og:image" content="https://magiceses.github.io/images/prometheus-alertmanager-2.png">
<meta property="og:image" content="https://magiceses.github.io/images/prometheus-alertmanager-3.png">
<meta property="og:image" content="https://magiceses.github.io/images/prometheus-alertmanager-4.jpg">
<meta property="og:image" content="https://magiceses.github.io/images/prometheus-alertmanager-5.jpg">
<meta property="og:image" content="https://magiceses.github.io/images/prometheus-alertmanager-6.png">
<meta property="og:image" content="https://magiceses.github.io/images/prometheus-alertmanager-7.png">
<meta property="og:updated_time" content="2021-10-02T07:58:41.111Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Alertmanager 高可用总结-上">
<meta name="twitter:description" content="人生不过如此，且行且珍惜，每一次的失败，都是成功的伏笔；每一次的考验，都有一份收获；每一次的泪水，都有一次醒悟；每一次的磨难，都有生命的财富。

高可用简介之前我们主要讨论了Prometheus Server自身的高可用问题。而接下来，重点将放在告警处理也就是Alertmanager部分。如下所示。

为了提升Promthues的服务可用性，通常用户会部署两个或者两个以上的Promthus Ser">
<meta name="twitter:image" content="https://magiceses.github.io/images/prometheus-alertmanager-0.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"hide"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: undefined,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="https://magiceses.github.io/2020/12/24/prometheus-alertmanager-高可用总结-上/"/>


<!-- 网页加载条 -->
<script src="/js/src/pace.min.js"></script>
  <title> Alertmanager 高可用总结-上 | 天青色等烟雨 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">天青色等烟雨</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">而我在等你</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-guestbook">
          <a href="/guestbook" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-commenting"></i> <br />
            
            留言
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
      
      
        <li class="menu-item"> <a title="把这个链接拖到你的工具栏中,任何网页都可以High" href='javascript:(
/*
 * Copyright (C) 2016 Never_yu (Neveryu.github.io) <React.dong.yu@gmail.com>
 * Sina Weibo (http://weibo.com/Neveryu)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function go() {

var songs = [
  "http://dl.stream.qqmusic.qq.com/C400001Qu4I30eVFYb.m4a?vkey=2127178E4405E7B8B268F20F05232485735CCF4FF8C1432F0360D2626D0B6C9564B5627C7AB481BBC685FEDB0946A50E97C66F0D1B008226&guid=7175649092&uin=0&fromtag=66",
  "",
  "",
  ""
];

function c() {
  var e = document.createElement("link");
  e.setAttribute("type", "text/css");
  e.setAttribute("rel", "stylesheet");
  e.setAttribute("href", f);
  e.setAttribute("class", l);
  document.body.appendChild(e)
}

function h() {
  var e = document.getElementsByClassName(l);
  for (var t = 0; t < e.length; t++) {
    document.body.removeChild(e[t])
  }
}

function p() {
  var e = document.createElement("div");
  e.setAttribute("class", a);
  document.body.appendChild(e);
  setTimeout(function() {
    document.body.removeChild(e)
  }, 100)
}

function d(e) {
  return {
    height : e.offsetHeight,
    width : e.offsetWidth
  }
}

function v(i) {
  var s = d(i);
  return s.height > e && s.height < n && s.width > t && s.width < r
}

function m(e) {
  var t = e;
  var n = 0;
  while (!!t) {
    n += t.offsetTop;
    t = t.offsetParent
  }
  return n
}

function g() {
  var e = document.documentElement;
  if (!!window.innerWidth) {
    return window.innerHeight
  } else if (e && !isNaN(e.clientHeight)) {
    return e.clientHeight
  }
  return 0
}

function y() {
  if (window.pageYOffset) {
    return window.pageYOffset
  }
  return Math.max(document.documentElement.scrollTop, document.body.scrollTop)
}

function E(e) {
  var t = m(e);
  return t >= w && t <= b + w
}

function S() {
  var e = document.getElementById("audio_element_id");
  if(e != null){
    var index = parseInt(e.getAttribute("curSongIndex"));
    if(index > songs.length - 2) {
      index = 0;
    } else {
      index++;
    }
    e.setAttribute("curSongIndex", index);
    N();
  }

  e.src = i;
  e.play()
}

function x(e) {
  e.className += " " + s + " " + o
}

function T(e) {
  e.className += " " + s + " " + u[Math.floor(Math.random() * u.length)]
}

function N() {
  var e = document.getElementsByClassName(s);
  var t = new RegExp("\\b" + s + "\\b");
  for (var n = 0; n < e.length; ) {
    e[n].className = e[n].className.replace(t, "")
  }
}

function initAudioEle() {
  var e = document.getElementById("audio_element_id");
  if(e === null){
    e = document.createElement("audio");
    e.setAttribute("class", l);
    e.setAttribute("curSongIndex", 0);
    e.id = "audio_element_id";
    e.loop = false;
    e.bgcolor = 0;
    e.addEventListener("canplay", function() {
      setTimeout(function() {
        x(k)
      }, 500);
      setTimeout(function() {
        N();
        p();
        for (var e = 0; e < O.length; e++) {
          T(O[e])
        }
      }, 15500)
    }, true);
    e.addEventListener("ended", function() {
      N();
      h();
      go();
    }, true);
    e.innerHTML = " <p>If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.</p> <p>";
    document.body.appendChild(e);
  }
}

initAudioEle();
var e = 30;
var t = 30;
var n = 350;
var r = 350;

var curSongIndex = parseInt(document.getElementById("audio_element_id").getAttribute("curSongIndex"));
var i = songs[curSongIndex];

var s = "mw-harlem_shake_me";
var o = "im_first";
var u = ["im_drunk", "im_baked", "im_trippin", "im_blown"];
var a = "mw-strobe_light";

/* harlem-shake-style.css，替换成你的位置，也可以直接使用：//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css */
var f = "//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css";

var l = "mw_added_css";
var b = g();
var w = y();
var C = document.getElementsByTagName("*");
var k = null;
for (var L = 0; L < C.length; L++) {
  var A = C[L];
  if (v(A)) {
    if (E(A)) {
      k = A;
      break
    }
  }
}
if (A === null) {
  console.warn("Could not find a node of the right size. Please try a different page.");
  return
}
c();
S();
var O = [];
for (var L = 0; L < C.length; L++) {
  var A = C[L];
  if (v(A)) {
    O.push(A)
  }
}
})()'><i class="menu-item-icon fa fa-music fa-fw"></i> High一下</a></li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search fa-lg"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Alertmanager 高可用总结-上
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2020-12-24T22:25:24+08:00" content="2020-12-24">
              2020-12-24
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Prometheus/" itemprop="url" rel="index">
                    <span itemprop="name">Prometheus</span>
                  </a>
                </span>

                
                

              
            </span>
          

          

          

          
          

          
              &nbsp; | &nbsp;
              <span class="page-pv">热度
              <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>℃
              </span>
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p id="div-border-top-green">人生不过如此，且行且珍惜，每一次的失败，都是成功的伏笔；每一次的考验，都有一份收获；每一次的泪水，都有一次醒悟；每一次的磨难，都有生命的财富。<br></p>

<h2 id="高可用简介"><a href="#高可用简介" class="headerlink" title="高可用简介"></a>高可用简介</h2><p>之前我们主要讨论了Prometheus Server自身的高可用问题。而接下来，重点将放在告警处理也就是Alertmanager部分。如下所示。</p>
<p><img src="/images/prometheus-alertmanager-0.png" alt="image-20210906110008076"></p>
<p>为了提升Promthues的服务可用性，通常用户会部署两个或者两个以上的Promthus Server，它们具有完全相同的配置包括Job配置，以及告警配置等。当某一个Prometheus Server发生故障后可以确保Promthues持续可用。</p>
<a id="more"></a>
<p>同时基于Alertmanager的告警分组机制即使不同的Prometheus Sever分别发送相同的告警给Alertmanager，Alertmanager也可以自动将这些告警合并为一个通知向receiver发送。</p>
<p><img src="/images/prometheus-alertmanager-1.png" alt="image-20210906110119996"></p>
<p>但不幸的是，虽然Alertmanager能够同时处理多个相同的Prometheus Server所产生的告警。但是由于单个Alertmanager的存在，当前的部署结构存在明显的单点故障风险，当Alertmanager单点失效后，告警的后续所有业务全部失效。</p>
<p>如下所示，最直接的方式，就是尝试部署多套Alertmanager。但是由于Alertmanager之间不存在并不了解彼此的存在，因此则会出现告警通知被不同的Alertmanager重复发送多次的问题。</p>
<p><img src="/images/prometheus-alertmanager-2.png" alt="image-20210906110143793"></p>
<p>为了解决这一问题，如下所示。Alertmanager引入了Gossip机制。Gossip机制为多个Alertmanager之间提供了信息传递的机制。确保及时在多个Alertmanager分别接收到相同告警信息的情况下，也只有一个告警通知被发送给Receiver。</p>
<p><img src="/images/prometheus-alertmanager-3.png" alt="image-20210906110223932"></p>
<h2 id="Gossip协议"><a href="#Gossip协议" class="headerlink" title="Gossip协议"></a>Gossip协议</h2><p>Gossip protocol 也叫 Epidemic Protocol （流行病协议），实际上它还有很多别名，比如：“流言算法”、“疫情传播算法”等。</p>
<p>这个协议的作用就像其名字表示的意思一样，非常容易理解，它的方式其实在我们日常生活中也很常见，比如电脑病毒的传播，森林大火，细胞扩散等等。</p>
<p><strong>这里先简单介绍一下 Gossip 协议的执行过程：</strong></p>
<p>Gossip 过程是由种子节点发起，当一个种子节点有状态需要更新到网络中的其他节点时，它会随机的选择周围几个节点散播消息，收到消息的节点也会重复该过程，直至最终网络中所有的节点都收到了消息。这个过程可能需要一定的时间，由于不能保证某个时刻所有节点都收到消息，但是理论上最终所有节点都会收到消息，因此它是一个最终一致性协议。</p>
<p><strong>Gossip 演示</strong></p>
<p>现在，我们通过一个具体的实例来深入体会一下 Gossip 传播的完整过程</p>
<p><strong>为了表述清楚，我们先做一些前提设定</strong></p>
<p>1、Gossip 是周期性的散播消息，把周期限定为 1 秒</p>
<p>2、被感染节点随机选择 k 个邻接节点（fan-out）散播消息，这里把 fan-out 设置为 3，每次最多往 3 个节点散播。</p>
<p>3、每次散播消息都选择尚未发送过的节点进行散播</p>
<p>4、收到消息的节点不再往发送节点散播，比如 A -&gt; B，那么 B 进行散播的时候，不再发给 A。</p>
<p>注意：Gossip 过程是异步的，也就是说发消息的节点不会关注对方是否收到，即不等待响应；不管对方有没有收到，它都会每隔 1 秒向周围节点发消息。异步是它的优点，而消息冗余则是它的缺点。</p>
<p>这里一共有 16 个节点，节点 1 为初始被感染节点，通过 Gossip 过程，最终所有节点都被感染：</p>
<video src="/Users/stark/Pictures/screenshot/gossip.mp4"></video>

<h3 id="Gossip-的特点（优势）"><a href="#Gossip-的特点（优势）" class="headerlink" title="Gossip 的特点（优势）"></a><strong>Gossip 的特点（优势）</strong></h3><p><strong>1）扩展性</strong></p>
<p>网络可以允许节点的任意增加和减少，新增加的节点的状态最终会与其他节点一致。</p>
<p><strong>2）容错</strong></p>
<p>网络中任何节点的宕机和重启都不会影响 Gossip 消息的传播，Gossip 协议具有天然的分布式系统容错特性。</p>
<p><strong>3）去中心化</strong></p>
<p>Gossip 协议不要求任何中心节点，所有节点都可以是对等的，任何一个节点无需知道整个网络状况，只要网络是连通的，任意一个节点就可以把消息散播到全网。</p>
<p><strong>4）一致性收敛</strong></p>
<p>Gossip 协议中的消息会以一传十、十传百一样的指数级速度在网络中快速传播，因此系统状态的不一致可以在很快的时间内收敛到一致。消息传播速度达到了 logN。</p>
<p><strong>5）简单</strong></p>
<p>Gossip 协议的过程极其简单，实现起来几乎没有太多复杂性。</p>
<h3 id="Gossip-的缺陷"><a href="#Gossip-的缺陷" class="headerlink" title="Gossip 的缺陷"></a><strong>Gossip 的缺陷</strong></h3><p>分布式网络中，没有一种完美的解决方案，Gossip 协议跟其他协议一样，也有一些不可避免的缺陷，主要是两个：</p>
<p><strong>1）消息的延迟</strong></p>
<p>由于 Gossip 协议中，节点只会随机向少数几个节点发送消息，消息最终是通过多个轮次的散播而到达全网的，因此使用 Gossip 协议会造成不可避免的消息延迟。不适合用在对实时性要求较高的场景下。</p>
<p><strong>2）消息冗余</strong></p>
<p>Gossip 协议规定，节点会定期随机选择周围节点发送消息，而收到消息的节点也会重复该步骤，因此就不可避免的存在消息重复发送给同一节点的情况，造成了消息的冗余，同时也增加了收到消息的节点的处理压力。而且，由于是定期发送，因此，即使收到了消息的节点还会反复收到重复消息，加重了消息的冗余。</p>
<h3 id="Gossip-类型"><a href="#Gossip-类型" class="headerlink" title="Gossip 类型"></a><strong>Gossip 类型</strong></h3><p>Gossip 有两种类型：</p>
<ul>
<li>Anti-Entropy（反熵）：以固定的概率传播所有的数据</li>
<li>Rumor-Mongering（谣言传播）：仅传播新到达的数据</li>
</ul>
<p>Anti-Entropy 是 SI model，节点只有两种状态，Suspective 和 Infective，叫做 simple epidemics。</p>
<p>Rumor-Mongering 是 SIR model，节点有三种状态，Suspective，Infective 和 Removed，叫做 complex epidemics。</p>
<p>其实，Anti-entropy 反熵是一个很奇怪的名词，之所以定义成这样，Jelasity 进行了解释，因为 entropy 是指混乱程度（disorder），而在这种模式下可以消除不同节点中数据的 disorder，因此 Anti-entropy 就是 anti-disorder。换句话说，它可以提高系统中节点之间的 similarity。</p>
<p>在 SI model 下，一个节点会把所有的数据都跟其他节点共享，以便消除节点之间数据的任何不一致，它可以保证最终、完全的一致。</p>
<p>由于在 SI model 下消息会不断反复的交换，因此消息数量是非常庞大的，无限制的（unbounded），这对一个系统来说是一个巨大的开销。</p>
<p>但是在 Rumor Mongering（SIR Model） 模型下，消息可以发送得更频繁，因为消息只包含最新 update，体积更小。而且，一个 Rumor 消息在某个时间点之后会被标记为 removed，并且不再被传播，因此，SIR model 下，系统有一定的概率会不一致。</p>
<p>而由于，SIR Model 下某个时间点之后消息不再传播，因此消息是有限的，系统开销小。</p>
<h3 id="Gossip-中的通信模式"><a href="#Gossip-中的通信模式" class="headerlink" title="Gossip 中的通信模式"></a><strong>Gossip 中的通信模式</strong></h3><p>在 Gossip 协议下，网络中两个节点之间有三种通信方式:</p>
<ul>
<li>Push: 节点 A 将数据 (key,value,version) 及对应的版本号推送给 B 节点，B 节点更新 A 中比自己新的数据</li>
<li>Pull：A 仅将数据 key, version 推送给 B，B 将本地比 A 新的数据（Key, value, version）推送给 A，A 更新本地</li>
<li>Push/Pull：与 Pull 类似，只是多了一步，A 再将本地比 B 新的数据推送给 B，B 则更新本地</li>
</ul>
<p>如果把两个节点数据同步一次定义为一个周期，则在一个周期内，Push 需通信 1 次，Pull 需 2 次，Push/Pull 则需 3 次。虽然消息数增加了，但从效果上来讲，Push/Pull 最好，理论上一个周期内可以使两个节点完全一致。直观上，Push/Pull 的收敛速度也是最快的。</p>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h3><p>对于一个节点数为 N 的网络来说，假设每个 Gossip 周期，新感染的节点都能再感染至少一个新节点，那么 Gossip 协议退化成一个二叉树查找，经过 LogN 个周期之后，感染全网，时间开销是 O(LogN)。由于每个周期，每个节点都会至少发出一次消息，因此，消息复杂度（消息数量 = N * N）是 O(N^2) 。注意，这是 Gossip 理论上最优的收敛速度，但是在实际情况中，最优的收敛速度是很难达到的。</p>
<p>假设某个节点在第 i 个周期被感染的概率为 pi，第 i+1 个周期被感染的概率为 pi+1 ，</p>
<p>1）则 Pull 的方式:</p>
<p><img src="/images/prometheus-alertmanager-4.jpg" alt="img"></p>
<p>2）Push 方式：</p>
<p><img src="/images/prometheus-alertmanager-5.jpg" alt="img"></p>
<p>显然 Pull 的收敛速度大于 Push ，而每个节点在每个周期被感染的概率都是固定的 p (0&lt;p&lt;1)，因此 Gossip 算法是基于 p 的平方收敛，也称为概率收敛，这在众多的一致性算法中是非常独特的。</p>
<h2 id="高可用方案"><a href="#高可用方案" class="headerlink" title="高可用方案"></a>高可用方案</h2><p>上面我们详细介绍了goosip协议的实现，简单的说，Gossip有两种实现方式分别为Push-based和Pull-based。在Push-based当集群中某一节点A完成一个工作后，随机的从其它节点B并向其发送相应的消息，节点B接收到消息后在重复完成相同的工作，直到传播到集群中的所有节点。而Pull-based的实现中节点A会随机的向节点B发起询问是否有新的状态需要同步，如果有则返回。</p>
<p>在简单了解了Gossip协议之后，我们来看Alertmanager是如何基于Gossip协议实现集群高可用的。如下所示，当Alertmanager接收到来自Prometheus的告警消息后，会按照以下流程对告警进行处理：</p>
<p><img src="/images/prometheus-alertmanager-6.png" alt="image-20210906112831633"></p>
<ul>
<li>在第一个阶段Silence中，Alertmanager会判断当前通知是否匹配到任何的静默规则，如果没有则进入下一个阶段，否则则中断流水线不发送通知；</li>
<li>在第二个阶段Wait中，Alertmanager会根据当前Alertmanager在集群中所在的顺序(index)等待index * 5s的时间；</li>
<li>当前Alertmanager等待阶段结束后，Dedup阶段则会判断当前Alertmanager数据库中该通知是否已经发送，如果已经发送则中断流水线，不发送告警，否则则进入下一阶段Send对外发送告警通知；</li>
<li>告警发送完成后该Alertmanager进入最后一个阶段Gossip，Gossip会通知其他Alertmanager实例当前告警已经发送。其他实例接收到Gossip消息后，则会在自己的数据库中保存该通知已发送的记录。</li>
</ul>
<p>因此如下所示，Gossip机制的关键在于两点：</p>
<p><img src="/images/prometheus-alertmanager-7.png" alt="image-20210906113513907"></p>
<ul>
<li>Silence设置同步：Alertmanager启动阶段基于Pull-based从集群其它节点同步Silence状态，当有新的Silence产生时使用Push-based方式在集群中传播Gossip信息；</li>
<li>通知发送状态同步：告警通知发送完成后，基于Push-based同步告警发送状态。Wait阶段可以确保集群状态一致。</li>
</ul>
<p>Alertmanager基于Gossip实现的集群机制虽然不能保证所有实例上的数据时刻保持一致，但是实现了CAP理论中的AP系统，即可用性和分区容错性。同时对于Prometheus Server而言保持了配置了简单性，Promthues Server之间不需要任何的状态同步。</p>
<h2 id="高可用源码分析"><a href="#高可用源码分析" class="headerlink" title="高可用源码分析"></a>高可用源码分析</h2><h3 id="集群启动"><a href="#集群启动" class="headerlink" title="集群启动"></a>集群启动</h3><p>下面是从main.go中摘录的一些关于alertmanager组件集群的代码流程：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码来自alertmanager/cmd/alertmanager/main.go</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化集群</span></span><br><span class="line">	<span class="keyword">var</span> peer *cluster.Peer</span><br><span class="line">	<span class="keyword">if</span> *clusterBindAddr != <span class="string">""</span> &#123;</span><br><span class="line">		peer, err = cluster.Create(</span><br><span class="line">			log.With(logger, <span class="string">"component"</span>, <span class="string">"cluster"</span>),</span><br><span class="line">			prometheus.DefaultRegisterer,</span><br><span class="line">			*clusterBindAddr,</span><br><span class="line">			*clusterAdvertiseAddr,</span><br><span class="line">			*peers,</span><br><span class="line">			<span class="literal">true</span>,</span><br><span class="line">			*pushPullInterval,</span><br><span class="line">			*gossipInterval,</span><br><span class="line">			*tcpTimeout,</span><br><span class="line">			*probeTimeout,</span><br><span class="line">			*probeInterval,</span><br><span class="line">		)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			level.Error(logger).Log(<span class="string">"msg"</span>, <span class="string">"unable to initialize gossip mesh"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 设置普罗米修斯集群指标，为已启用</span></span><br><span class="line">		clusterEnabled.Set(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> peer != <span class="literal">nil</span> &#123;</span><br><span class="line">		c := peer.AddState(<span class="string">"nfl"</span>, notificationLog, prometheus.DefaultRegisterer)</span><br><span class="line">		notificationLog.SetBroadcast(c.Broadcast)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> peer != <span class="literal">nil</span> &#123;</span><br><span class="line">		c := peer.AddState(<span class="string">"sil"</span>, silences, prometheus.DefaultRegisterer)</span><br><span class="line">		silences.SetBroadcast(c.Broadcast)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 集群peer的状态监听器已经进行注册成功，现在可以进行加入集群和初始化状态。</span></span><br><span class="line">	<span class="comment">// Peer state listeners have been registered, now we can join and get the initial state.</span></span><br><span class="line">	<span class="keyword">if</span> peer != <span class="literal">nil</span> &#123;</span><br><span class="line">		err = peer.Join(</span><br><span class="line">			*reconnectInterval,</span><br><span class="line">			*peerReconnectTimeout,</span><br><span class="line">		)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			level.Warn(logger).Log(<span class="string">"msg"</span>, <span class="string">"unable to join gossip mesh"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		ctx, cancel := context.WithTimeout(context.Background(), *settleTimeout)</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			cancel()</span><br><span class="line">			<span class="keyword">if</span> err := peer.Leave(<span class="number">10</span> * time.Second); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				level.Warn(logger).Log(<span class="string">"msg"</span>, <span class="string">"unable to leave gossip mesh"</span>, <span class="string">"err"</span>, err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">		<span class="keyword">go</span> peer.Settle(ctx, *gossipInterval*<span class="number">10</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">	waitFunc := <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">	<span class="keyword">if</span> peer != <span class="literal">nil</span> &#123;</span><br><span class="line">		waitFunc = clusterWait(peer, *peerTimeout)</span><br><span class="line">	&#125;</span><br><span class="line">	timeoutFunc := <span class="function"><span class="keyword">func</span><span class="params">(d time.Duration)</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> d &lt; notify.MinTimeout &#123;</span><br><span class="line">			d = notify.MinTimeout</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> d + waitFunc()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">		pipeline := pipelineBuilder.New(</span><br><span class="line">			receivers,</span><br><span class="line">			waitFunc,</span><br><span class="line">			inhibitor,</span><br><span class="line">			silencer,</span><br><span class="line">			notificationLog,</span><br><span class="line">			peer,</span><br><span class="line">		)</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  disp = dispatch.NewDispatcher(alerts, routes, pipeline, marker, timeoutFunc, logger, dispMetrics)</span><br></pre></td></tr></table></figure>
<p>在<code>cluster.Create</code>中主要就是一些初始化集群的工作，里面比较重要的就是用到了<code>ml, err := memberlist.Create(cfg)</code>，这里用到了一个基于Gossip协议来传播消息，用来管理分布式集群内节点发现、 节点失效探测、节点列表的软件包<code>memberlist</code>，关于这个包，有必要分析一下，没兴趣的可以跳过这一节：</p>
<h3 id="memberlist"><a href="#memberlist" class="headerlink" title="memberlist"></a>memberlist</h3><p>memberlist 是HashiCorp公司出品的go语言开发库，使用基于Gossip协议管理集群成员和成员失败检测。咱们本文的主题就是memberlist。严格说起来，memberlist是基于Gossip协议变种实现的，它的指导论文是康奈尔大学计算机科学系Abhinandan Das, Indranil Gupta, Ashish Motivala在2002年发表的《SWIM:Scalable Weakly-consistent/Infection-styleProcess Group Membership Protocol》。</p>
<p>Membership协议中文名是 可伸缩最终一致性感染成员组协议。原理通过一个有效的点对点随机探测机制进行监控协议成员的故障检测、更新传播。Memberlist 构建在SWIM Membership之上，跟原始gossip协议有了一些补充和调整。咱们接下去从项目介绍、节点状态、消息类型、数据通讯来解说下。</p>
<p>项目结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">total 536</span><br><span class="line">-rw-r--r--  1 stark  staff  15977  6  2 15:34 LICENSE</span><br><span class="line">-rw-r--r--  1 stark  staff    670  6  2 15:34 Makefile</span><br><span class="line">-rw-r--r--  1 stark  staff   3195  6  2 15:34 README.md</span><br><span class="line">-rw-r--r--  1 stark  staff    591  6  2 15:34 alive_delegate.go</span><br><span class="line">-rw-r--r--  1 stark  staff   1745  6  2 15:34 awareness.go</span><br><span class="line">-rw-r--r--  1 stark  staff   3311  6  2 15:34 broadcast.go # 广播模块</span><br><span class="line">-rw-r--r--  1 stark  staff  15003  6  2 15:34 config.go</span><br><span class="line">-rw-r--r--  1 stark  staff    376  6  2 15:34 conflict_delegate.go</span><br><span class="line">-rw-r--r--  1 stark  staff   1851  6  2 15:34 delegate.go</span><br><span class="line">-rw-r--r--  1 stark  staff   1870  6  2 15:34 event_delegate.go</span><br><span class="line">-rw-r--r--  1 stark  staff    666  6  2 15:34 go.mod</span><br><span class="line">-rw-r--r--  1 stark  staff   4720  6  2 15:34 go.sum</span><br><span class="line">-rw-r--r--  1 stark  staff   4505  6  2 15:34 keyring.go</span><br><span class="line">-rw-r--r--  1 stark  staff    454  6  2 15:34 logging.go</span><br><span class="line">-rw-r--r--  1 stark  staff  22474  6  2 15:34 memberlist.go # 主体模块</span><br><span class="line">-rw-r--r--  1 stark  staff    570  6  2 15:34 merge_delegate.go</span><br><span class="line">-rw-r--r--  1 stark  staff   4390  6  2 15:34 mock_transport.go</span><br><span class="line">-rw-r--r--  1 stark  staff  35144  6  2 15:34 net.go # 通信模块</span><br><span class="line">-rw-r--r--  1 stark  staff  10031  6  2 15:34 net_transport.go</span><br><span class="line">-rw-r--r--  1 stark  staff    645  6  2 15:34 ping_delegate.go</span><br><span class="line">-rw-r--r--  1 stark  staff  11384  6  2 15:34 queue.go</span><br><span class="line">-rw-r--r--  1 stark  staff   5074  6  2 15:34 security.go</span><br><span class="line">-rw-r--r--  1 stark  staff  37938  6  2 15:34 state.go # 状态模块</span><br><span class="line">-rw-r--r--  1 stark  staff   4298  6  2 15:34 suspicion.go</span><br><span class="line">-rw-r--r--  1 stark  staff    399  6  2 15:34 tag.sh</span><br><span class="line">-rw-r--r--  1 stark  staff    211  6  2 15:34 todo.md</span><br><span class="line">-rw-r--r--  1 stark  staff   4579  6  2 15:34 transport.go</span><br><span class="line">-rw-r--r--  1 stark  staff   8170  6  2 15:34 util.go</span><br></pre></td></tr></table></figure>
<p>项目基本流程如下：</p>
<ul>
<li><p>项目在memberlist.go 函数Create启动，调用sate.go中函数schedule</p>
</li>
<li><p>Schedule函数开启probe协程、pushpull协程、gossip协程</p>
</li>
<li><p>probe协程：进行节点状态维护</p>
</li>
<li><p>push/pull协程：进行节点状态、用户数据同步</p>
</li>
<li><p>gossip协程：进行udp广播发送消息。</p>
</li>
</ul>
<h4 id="Memberlist-结构体"><a href="#Memberlist-结构体" class="headerlink" title="Memberlist 结构体"></a>Memberlist 结构体</h4><p>在结构体Memberlist中，成员变量也是按照功能不同分隔</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码来自 github.com/hashicorp/memberlist/memberlist.go</span></span><br><span class="line"><span class="keyword">type</span> Memberlist <span class="keyword">struct</span> &#123;</span><br><span class="line">	sequenceNum <span class="keyword">uint32</span> <span class="comment">// Local sequence number</span></span><br><span class="line">	incarnation <span class="keyword">uint32</span> <span class="comment">// Local incarnation number</span></span><br><span class="line">	numNodes    <span class="keyword">uint32</span> <span class="comment">// Number of known nodes (estimate)</span></span><br><span class="line">	pushPullReq <span class="keyword">uint32</span> <span class="comment">// Number of push/pull requests</span></span><br><span class="line"></span><br><span class="line">	advertiseLock sync.RWMutex</span><br><span class="line">	advertiseAddr net.IP</span><br><span class="line">	advertisePort <span class="keyword">uint16</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//配置</span></span><br><span class="line">	config         *Config </span><br><span class="line">  <span class="comment">//本地服务关闭的标志位</span></span><br><span class="line">	shutdown       <span class="keyword">int32</span> <span class="comment">// Used as an atomic boolean value</span></span><br><span class="line">	shutdownCh     <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">  <span class="comment">//本节点退出的标志位</span></span><br><span class="line">	leave          <span class="keyword">int32</span> <span class="comment">// Used as an atomic boolean value</span></span><br><span class="line">	leaveBroadcast <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	shutdownLock sync.Mutex <span class="comment">// Serializes calls to Shutdown</span></span><br><span class="line">	leaveLock    sync.Mutex <span class="comment">// Serializes calls to Leave</span></span><br><span class="line"></span><br><span class="line">	transport NodeAwareTransport</span><br><span class="line"></span><br><span class="line">	handoffCh            <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	highPriorityMsgQueue *list.List</span><br><span class="line">	lowPriorityMsgQueue  *list.List</span><br><span class="line">	msgQueueLock         sync.Mutex</span><br><span class="line"></span><br><span class="line">	nodeLock   sync.RWMutex</span><br><span class="line">	nodes      []*nodeState          <span class="comment">// Known nodes</span></span><br><span class="line">	nodeMap    <span class="keyword">map</span>[<span class="keyword">string</span>]*nodeState <span class="comment">// Maps Node.Name -&gt; NodeState</span></span><br><span class="line">	nodeTimers <span class="keyword">map</span>[<span class="keyword">string</span>]*suspicion <span class="comment">// Maps Node.Name -&gt; suspicion timer</span></span><br><span class="line">	awareness  *awareness</span><br><span class="line"></span><br><span class="line">	tickerLock sync.Mutex</span><br><span class="line">	tickers    []*time.Ticker</span><br><span class="line">	stopTick   <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	probeIndex <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	ackLock     sync.Mutex</span><br><span class="line">	ackHandlers <span class="keyword">map</span>[<span class="keyword">uint32</span>]*ackHandler</span><br><span class="line"></span><br><span class="line">	broadcasts *TransmitLimitedQueue</span><br><span class="line"></span><br><span class="line">	logger *log.Logger</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Config-结构体"><a href="#Config-结构体" class="headerlink" title="Config 结构体"></a>Config 结构体</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// The name of this node. This must be unique in the cluster.</span></span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Transport is a hook for providing custom code to communicate with</span></span><br><span class="line">	<span class="comment">// other nodes. If this is left nil, then memberlist will by default</span></span><br><span class="line">	<span class="comment">// make a NetTransport using BindAddr and BindPort from this structure.</span></span><br><span class="line">	Transport Transport</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Configuration related to what address to bind to and ports to</span></span><br><span class="line">	<span class="comment">// listen on. The port is used for both UDP and TCP gossip. It is</span></span><br><span class="line">	<span class="comment">// assumed other nodes are running on this port, but they do not need</span></span><br><span class="line">	<span class="comment">// to.</span></span><br><span class="line">	BindAddr <span class="keyword">string</span></span><br><span class="line">	BindPort <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Configuration related to what address to advertise to other</span></span><br><span class="line">	<span class="comment">// cluster members. Used for nat traversal.</span></span><br><span class="line">	AdvertiseAddr <span class="keyword">string</span></span><br><span class="line">	AdvertisePort <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// ProtocolVersion is the configured protocol version that we</span></span><br><span class="line">	<span class="comment">// will _speak_. This must be between ProtocolVersionMin and</span></span><br><span class="line">	<span class="comment">// ProtocolVersionMax.</span></span><br><span class="line">	ProtocolVersion <span class="keyword">uint8</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// TCPTimeout is the timeout for establishing a stream connection with</span></span><br><span class="line">	<span class="comment">// a remote node for a full state sync, and for stream read and write</span></span><br><span class="line">	<span class="comment">// operations. This is a legacy name for backwards compatibility, but</span></span><br><span class="line">	<span class="comment">// should really be called StreamTimeout now that we have generalized</span></span><br><span class="line">	<span class="comment">// the transport.</span></span><br><span class="line">	TCPTimeout time.Duration</span><br><span class="line"></span><br><span class="line">	<span class="comment">// IndirectChecks is the number of nodes that will be asked to perform</span></span><br><span class="line">	<span class="comment">// an indirect probe of a node in the case a direct probe fails. Memberlist</span></span><br><span class="line">	<span class="comment">// waits for an ack from any single indirect node, so increasing this</span></span><br><span class="line">	<span class="comment">// number will increase the likelihood that an indirect probe will succeed</span></span><br><span class="line">	<span class="comment">// at the expense of bandwidth.</span></span><br><span class="line">	IndirectChecks <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// RetransmitMult is the multiplier for the number of retransmissions</span></span><br><span class="line">	<span class="comment">// that are attempted for messages broadcasted over gossip. The actual</span></span><br><span class="line">	<span class="comment">// count of retransmissions is calculated using the formula:</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//   Retransmits = RetransmitMult * log(N+1)</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// This allows the retransmits to scale properly with cluster size. The</span></span><br><span class="line">	<span class="comment">// higher the multiplier, the more likely a failed broadcast is to converge</span></span><br><span class="line">	<span class="comment">// at the expense of increased bandwidth.</span></span><br><span class="line">	RetransmitMult <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// SuspicionMult is the multiplier for determining the time an</span></span><br><span class="line">	<span class="comment">// inaccessible node is considered suspect before declaring it dead.</span></span><br><span class="line">	<span class="comment">// The actual timeout is calculated using the formula:</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">//   SuspicionTimeout = SuspicionMult * log(N+1) * ProbeInterval</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// This allows the timeout to scale properly with expected propagation</span></span><br><span class="line">	<span class="comment">// delay with a larger cluster size. The higher the multiplier, the longer</span></span><br><span class="line">	<span class="comment">// an inaccessible node is considered part of the cluster before declaring</span></span><br><span class="line">	<span class="comment">// it dead, giving that suspect node more time to refute if it is indeed</span></span><br><span class="line">	<span class="comment">// still alive.</span></span><br><span class="line">	SuspicionMult <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// SuspicionMaxTimeoutMult is the multiplier applied to the</span></span><br><span class="line">	<span class="comment">// SuspicionTimeout used as an upper bound on detection time. This max</span></span><br><span class="line">	<span class="comment">// timeout is calculated using the formula:</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// SuspicionMaxTimeout = SuspicionMaxTimeoutMult * SuspicionTimeout</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// If everything is working properly, confirmations from other nodes will</span></span><br><span class="line">	<span class="comment">// accelerate suspicion timers in a manner which will cause the timeout</span></span><br><span class="line">	<span class="comment">// to reach the base SuspicionTimeout before that elapses, so this value</span></span><br><span class="line">	<span class="comment">// will typically only come into play if a node is experiencing issues</span></span><br><span class="line">	<span class="comment">// communicating with other nodes. It should be set to a something fairly</span></span><br><span class="line">	<span class="comment">// large so that a node having problems will have a lot of chances to</span></span><br><span class="line">	<span class="comment">// recover before falsely declaring other nodes as failed, but short</span></span><br><span class="line">	<span class="comment">// enough for a legitimately isolated node to still make progress marking</span></span><br><span class="line">	<span class="comment">// nodes failed in a reasonable amount of time.</span></span><br><span class="line">	SuspicionMaxTimeoutMult <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// PushPullInterval is the interval between complete state syncs.</span></span><br><span class="line">	<span class="comment">// Complete state syncs are done with a single node over TCP and are</span></span><br><span class="line">	<span class="comment">// quite expensive relative to standard gossiped messages. Setting this</span></span><br><span class="line">	<span class="comment">// to zero will disable state push/pull syncs completely.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Setting this interval lower (more frequent) will increase convergence</span></span><br><span class="line">	<span class="comment">// speeds across larger clusters at the expense of increased bandwidth</span></span><br><span class="line">	<span class="comment">// usage.</span></span><br><span class="line">	PushPullInterval time.Duration</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ProbeInterval and ProbeTimeout are used to configure probing</span></span><br><span class="line">	<span class="comment">// behavior for memberlist.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// ProbeInterval is the interval between random node probes. Setting</span></span><br><span class="line">	<span class="comment">// this lower (more frequent) will cause the memberlist cluster to detect</span></span><br><span class="line">	<span class="comment">// failed nodes more quickly at the expense of increased bandwidth usage.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// ProbeTimeout is the timeout to wait for an ack from a probed node</span></span><br><span class="line">	<span class="comment">// before assuming it is unhealthy. This should be set to 99-percentile</span></span><br><span class="line">	<span class="comment">// of RTT (round-trip time) on your network.</span></span><br><span class="line">	ProbeInterval time.Duration</span><br><span class="line">	ProbeTimeout  time.Duration</span><br><span class="line"></span><br><span class="line">	<span class="comment">// DisableTcpPings will turn off the fallback TCP pings that are attempted</span></span><br><span class="line">	<span class="comment">// if the direct UDP ping fails. These get pipelined along with the</span></span><br><span class="line">	<span class="comment">// indirect UDP pings.</span></span><br><span class="line">	DisableTcpPings <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// DisableTcpPingsForNode is like DisableTcpPings, but lets you control</span></span><br><span class="line">	<span class="comment">// whether to perform TCP pings on a node-by-node basis.</span></span><br><span class="line">	DisableTcpPingsForNode <span class="function"><span class="keyword">func</span><span class="params">(nodeName <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	// <span class="title">AwarenessMaxMultiplier</span> <span class="title">will</span> <span class="title">increase</span> <span class="title">the</span> <span class="title">probe</span> <span class="title">interval</span> <span class="title">if</span> <span class="title">the</span> <span class="title">node</span></span></span><br><span class="line"><span class="function">	// <span class="title">becomes</span> <span class="title">aware</span> <span class="title">that</span> <span class="title">it</span> <span class="title">might</span> <span class="title">be</span> <span class="title">degraded</span> <span class="title">and</span> <span class="title">not</span> <span class="title">meeting</span> <span class="title">the</span> <span class="title">soft</span> <span class="title">real</span></span></span><br><span class="line"><span class="function">	// <span class="title">time</span> <span class="title">requirements</span> <span class="title">to</span> <span class="title">reliably</span> <span class="title">probe</span> <span class="title">other</span> <span class="title">nodes</span>.</span></span><br><span class="line"><span class="function">	<span class="title">AwarenessMaxMultiplier</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	// <span class="title">GossipInterval</span> <span class="title">and</span> <span class="title">GossipNodes</span> <span class="title">are</span> <span class="title">used</span> <span class="title">to</span> <span class="title">configure</span> <span class="title">the</span> <span class="title">gossip</span></span></span><br><span class="line"><span class="function">	// <span class="title">behavior</span> <span class="title">of</span> <span class="title">memberlist</span>.</span></span><br><span class="line"><span class="function">	//</span></span><br><span class="line"><span class="function">	// <span class="title">GossipInterval</span> <span class="title">is</span> <span class="title">the</span> <span class="title">interval</span> <span class="title">between</span> <span class="title">sending</span> <span class="title">messages</span> <span class="title">that</span> <span class="title">need</span></span></span><br><span class="line"><span class="function">	// <span class="title">to</span> <span class="title">be</span> <span class="title">gossiped</span> <span class="title">that</span> <span class="title">haven</span>'<span class="title">t</span> <span class="title">been</span> <span class="title">able</span> <span class="title">to</span> <span class="title">piggyback</span> <span class="title">on</span> <span class="title">probing</span> <span class="title">messages</span>.</span></span><br><span class="line"><span class="function">	// <span class="title">If</span> <span class="title">this</span> <span class="title">is</span> <span class="title">set</span> <span class="title">to</span> <span class="title">zero</span>, <span class="title">non</span>-<span class="title">piggyback</span> <span class="title">gossip</span> <span class="title">is</span> <span class="title">disabled</span>. <span class="title">By</span> <span class="title">lowering</span></span></span><br><span class="line"><span class="function">	// <span class="title">this</span> <span class="title">value</span> <span class="params">(more frequent)</span> <span class="title">gossip</span> <span class="title">messages</span> <span class="title">are</span> <span class="title">propagated</span> <span class="title">across</span></span></span><br><span class="line"><span class="function">	// <span class="title">the</span> <span class="title">cluster</span> <span class="title">more</span> <span class="title">quickly</span> <span class="title">at</span> <span class="title">the</span> <span class="title">expense</span> <span class="title">of</span> <span class="title">increased</span> <span class="title">bandwidth</span>.</span></span><br><span class="line"><span class="function">	//</span></span><br><span class="line"><span class="function">	// <span class="title">GossipNodes</span> <span class="title">is</span> <span class="title">the</span> <span class="title">number</span> <span class="title">of</span> <span class="title">random</span> <span class="title">nodes</span> <span class="title">to</span> <span class="title">send</span> <span class="title">gossip</span> <span class="title">messages</span> <span class="title">to</span></span></span><br><span class="line"><span class="function">	// <span class="title">per</span> <span class="title">GossipInterval</span>. <span class="title">Increasing</span> <span class="title">this</span> <span class="title">number</span> <span class="title">causes</span> <span class="title">the</span> <span class="title">gossip</span> <span class="title">messages</span></span></span><br><span class="line"><span class="function">	// <span class="title">to</span> <span class="title">propagate</span> <span class="title">across</span> <span class="title">the</span> <span class="title">cluster</span> <span class="title">more</span> <span class="title">quickly</span> <span class="title">at</span> <span class="title">the</span> <span class="title">expense</span> <span class="title">of</span></span></span><br><span class="line"><span class="function">	// <span class="title">increased</span> <span class="title">bandwidth</span>.</span></span><br><span class="line"><span class="function">	//</span></span><br><span class="line"><span class="function">	// <span class="title">GossipToTheDeadTime</span> <span class="title">is</span> <span class="title">the</span> <span class="title">interval</span> <span class="title">after</span> <span class="title">which</span> <span class="title">a</span> <span class="title">node</span> <span class="title">has</span> <span class="title">died</span> <span class="title">that</span></span></span><br><span class="line"><span class="function">	// <span class="title">we</span> <span class="title">will</span> <span class="title">still</span> <span class="title">try</span> <span class="title">to</span> <span class="title">gossip</span> <span class="title">to</span> <span class="title">it</span>. <span class="title">This</span> <span class="title">gives</span> <span class="title">it</span> <span class="title">a</span> <span class="title">chance</span> <span class="title">to</span> <span class="title">refute</span>.</span></span><br><span class="line"><span class="function">	<span class="title">GossipInterval</span>      <span class="title">time</span>.<span class="title">Duration</span></span></span><br><span class="line"><span class="function">	<span class="title">GossipNodes</span>         <span class="title">int</span></span></span><br><span class="line"><span class="function">	<span class="title">GossipToTheDeadTime</span> <span class="title">time</span>.<span class="title">Duration</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	// <span class="title">GossipVerifyIncoming</span> <span class="title">controls</span> <span class="title">whether</span> <span class="title">to</span> <span class="title">enforce</span> <span class="title">encryption</span> <span class="title">for</span> <span class="title">incoming</span></span></span><br><span class="line"><span class="function">	// <span class="title">gossip</span>. <span class="title">It</span> <span class="title">is</span> <span class="title">used</span> <span class="title">for</span> <span class="title">upshifting</span> <span class="title">from</span> <span class="title">unencrypted</span> <span class="title">to</span> <span class="title">encrypted</span> <span class="title">gossip</span> <span class="title">on</span></span></span><br><span class="line"><span class="function">	// <span class="title">a</span> <span class="title">running</span> <span class="title">cluster</span>.</span></span><br><span class="line"><span class="function">	<span class="title">GossipVerifyIncoming</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	// <span class="title">GossipVerifyOutgoing</span> <span class="title">controls</span> <span class="title">whether</span> <span class="title">to</span> <span class="title">enforce</span> <span class="title">encryption</span> <span class="title">for</span> <span class="title">outgoing</span></span></span><br><span class="line"><span class="function">	// <span class="title">gossip</span>. <span class="title">It</span> <span class="title">is</span> <span class="title">used</span> <span class="title">for</span> <span class="title">upshifting</span> <span class="title">from</span> <span class="title">unencrypted</span> <span class="title">to</span> <span class="title">encrypted</span> <span class="title">gossip</span> <span class="title">on</span></span></span><br><span class="line"><span class="function">	// <span class="title">a</span> <span class="title">running</span> <span class="title">cluster</span>.</span></span><br><span class="line"><span class="function">	<span class="title">GossipVerifyOutgoing</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	// <span class="title">EnableCompression</span> <span class="title">is</span> <span class="title">used</span> <span class="title">to</span> <span class="title">control</span> <span class="title">message</span> <span class="title">compression</span>. <span class="title">This</span> <span class="title">can</span></span></span><br><span class="line"><span class="function">	// <span class="title">be</span> <span class="title">used</span> <span class="title">to</span> <span class="title">reduce</span> <span class="title">bandwidth</span> <span class="title">usage</span> <span class="title">at</span> <span class="title">the</span> <span class="title">cost</span> <span class="title">of</span> <span class="title">slightly</span> <span class="title">more</span> <span class="title">CPU</span></span></span><br><span class="line"><span class="function">	// <span class="title">utilization</span>. <span class="title">This</span> <span class="title">is</span> <span class="title">only</span> <span class="title">available</span> <span class="title">starting</span> <span class="title">at</span> <span class="title">protocol</span> <span class="title">version</span> 1.</span></span><br><span class="line"><span class="function">	<span class="title">EnableCompression</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	// <span class="title">SecretKey</span> <span class="title">is</span> <span class="title">used</span> <span class="title">to</span> <span class="title">initialize</span> <span class="title">the</span> <span class="title">primary</span> <span class="title">encryption</span> <span class="title">key</span> <span class="title">in</span> <span class="title">a</span> <span class="title">keyring</span>.</span></span><br><span class="line"><span class="function">	// <span class="title">The</span> <span class="title">primary</span> <span class="title">encryption</span> <span class="title">key</span> <span class="title">is</span> <span class="title">the</span> <span class="title">only</span> <span class="title">key</span> <span class="title">used</span> <span class="title">to</span> <span class="title">encrypt</span> <span class="title">messages</span> <span class="title">and</span></span></span><br><span class="line"><span class="function">	// <span class="title">the</span> <span class="title">first</span> <span class="title">key</span> <span class="title">used</span> <span class="title">while</span> <span class="title">attempting</span> <span class="title">to</span> <span class="title">decrypt</span> <span class="title">messages</span>. <span class="title">Providing</span> <span class="title">a</span></span></span><br><span class="line"><span class="function">	// <span class="title">value</span> <span class="title">for</span> <span class="title">this</span> <span class="title">primary</span> <span class="title">key</span> <span class="title">will</span> <span class="title">enable</span> <span class="title">message</span>-<span class="title">level</span> <span class="title">encryption</span> <span class="title">and</span></span></span><br><span class="line"><span class="function">	// <span class="title">verification</span>, <span class="title">and</span> <span class="title">automatically</span> <span class="title">install</span> <span class="title">the</span> <span class="title">key</span> <span class="title">onto</span> <span class="title">the</span> <span class="title">keyring</span>.</span></span><br><span class="line"><span class="function">	// <span class="title">The</span> <span class="title">value</span> <span class="title">should</span> <span class="title">be</span> <span class="title">either</span> 16, 24, <span class="title">or</span> 32 <span class="title">bytes</span> <span class="title">to</span> <span class="title">select</span> <span class="title">AES</span>-128,</span></span><br><span class="line"><span class="function">	// <span class="title">AES</span>-192, <span class="title">or</span> <span class="title">AES</span>-256.</span></span><br><span class="line"><span class="function">	<span class="title">SecretKey</span> []<span class="title">byte</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	// <span class="title">The</span> <span class="title">keyring</span> <span class="title">holds</span> <span class="title">all</span> <span class="title">of</span> <span class="title">the</span> <span class="title">encryption</span> <span class="title">keys</span> <span class="title">used</span> <span class="title">internally</span>. <span class="title">It</span> <span class="title">is</span></span></span><br><span class="line"><span class="function">	// <span class="title">automatically</span> <span class="title">initialized</span> <span class="title">using</span> <span class="title">the</span> <span class="title">SecretKey</span> <span class="title">and</span> <span class="title">SecretKeys</span> <span class="title">values</span>.</span></span><br><span class="line"><span class="function">	<span class="title">Keyring</span> *<span class="title">Keyring</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	// <span class="title">Delegate</span> <span class="title">and</span> <span class="title">Events</span> <span class="title">are</span> <span class="title">delegates</span> <span class="title">for</span> <span class="title">receiving</span> <span class="title">and</span> <span class="title">providing</span></span></span><br><span class="line"><span class="function">	// <span class="title">data</span> <span class="title">to</span> <span class="title">memberlist</span> <span class="title">via</span> <span class="title">callback</span> <span class="title">mechanisms</span>. <span class="title">For</span> <span class="title">Delegate</span>, <span class="title">see</span></span></span><br><span class="line"><span class="function">	// <span class="title">the</span> <span class="title">Delegate</span> <span class="title">interface</span>. <span class="title">For</span> <span class="title">Events</span>, <span class="title">see</span> <span class="title">the</span> <span class="title">EventDelegate</span> <span class="title">interface</span>.</span></span><br><span class="line"><span class="function">	//</span></span><br><span class="line"><span class="function">	// <span class="title">The</span> <span class="title">DelegateProtocolMin</span>/<span class="title">Max</span> <span class="title">are</span> <span class="title">used</span> <span class="title">to</span> <span class="title">guarantee</span> <span class="title">protocol</span>-<span class="title">compatibility</span></span></span><br><span class="line"><span class="function">	// <span class="title">for</span> <span class="title">any</span> <span class="title">custom</span> <span class="title">messages</span> <span class="title">that</span> <span class="title">the</span> <span class="title">delegate</span> <span class="title">might</span> <span class="title">do</span> <span class="params">(broadcasts,</span></span></span><br><span class="line"><span class="function"><span class="params">	// local/remote state, etc.)</span>. <span class="title">If</span> <span class="title">you</span> <span class="title">don</span>'<span class="title">t</span> <span class="title">set</span> <span class="title">these</span>, <span class="title">then</span> <span class="title">the</span> <span class="title">protocol</span></span></span><br><span class="line"><span class="function">	// <span class="title">versions</span> <span class="title">will</span> <span class="title">just</span> <span class="title">be</span> <span class="title">zero</span>, <span class="title">and</span> <span class="title">version</span> <span class="title">compliance</span> <span class="title">won</span>'<span class="title">t</span> <span class="title">be</span> <span class="title">done</span>.</span></span><br><span class="line"><span class="function">	<span class="title">Delegate</span>                <span class="title">Delegate</span></span></span><br><span class="line"><span class="function">	<span class="title">DelegateProtocolVersion</span> <span class="title">uint8</span></span></span><br><span class="line"><span class="function">	<span class="title">DelegateProtocolMin</span>     <span class="title">uint8</span></span></span><br><span class="line"><span class="function">	<span class="title">DelegateProtocolMax</span>     <span class="title">uint8</span></span></span><br><span class="line"><span class="function">	<span class="title">Events</span>                  <span class="title">EventDelegate</span></span></span><br><span class="line"><span class="function">	<span class="title">Conflict</span>                <span class="title">ConflictDelegate</span></span></span><br><span class="line"><span class="function">	<span class="title">Merge</span>                   <span class="title">MergeDelegate</span></span></span><br><span class="line"><span class="function">	<span class="title">Ping</span>                    <span class="title">PingDelegate</span></span></span><br><span class="line"><span class="function">	<span class="title">Alive</span>                   <span class="title">AliveDelegate</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	// <span class="title">DNSConfigPath</span> <span class="title">points</span> <span class="title">to</span> <span class="title">the</span> <span class="title">system</span>'<span class="title">s</span> <span class="title">DNS</span> <span class="title">config</span> <span class="title">file</span>, <span class="title">usually</span> <span class="title">located</span></span></span><br><span class="line"><span class="function">	// <span class="title">at</span> /<span class="title">etc</span>/<span class="title">resolv</span>.<span class="title">conf</span>. <span class="title">It</span> <span class="title">can</span> <span class="title">be</span> <span class="title">overridden</span> <span class="title">via</span> <span class="title">config</span> <span class="title">for</span> <span class="title">easier</span> <span class="title">testing</span>.</span></span><br><span class="line"><span class="function">	<span class="title">DNSConfigPath</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	// <span class="title">LogOutput</span> <span class="title">is</span> <span class="title">the</span> <span class="title">writer</span> <span class="title">where</span> <span class="title">logs</span> <span class="title">should</span> <span class="title">be</span> <span class="title">sent</span>. <span class="title">If</span> <span class="title">this</span> <span class="title">is</span> <span class="title">not</span></span></span><br><span class="line"><span class="function">	// <span class="title">set</span>, <span class="title">logging</span> <span class="title">will</span> <span class="title">go</span> <span class="title">to</span> <span class="title">stderr</span> <span class="title">by</span> <span class="title">default</span>. <span class="title">You</span> <span class="title">cannot</span> <span class="title">specify</span> <span class="title">both</span> <span class="title">LogOutput</span></span></span><br><span class="line"><span class="function">	// <span class="title">and</span> <span class="title">Logger</span> <span class="title">at</span> <span class="title">the</span> <span class="title">same</span> <span class="title">time</span>.</span></span><br><span class="line"><span class="function">	<span class="title">LogOutput</span> <span class="title">io</span>.<span class="title">Writer</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	// <span class="title">Logger</span> <span class="title">is</span> <span class="title">a</span> <span class="title">custom</span> <span class="title">logger</span> <span class="title">which</span> <span class="title">you</span> <span class="title">provide</span>. <span class="title">If</span> <span class="title">Logger</span> <span class="title">is</span> <span class="title">set</span>, <span class="title">it</span> <span class="title">will</span> <span class="title">use</span></span></span><br><span class="line"><span class="function">	// <span class="title">this</span> <span class="title">for</span> <span class="title">the</span> <span class="title">internal</span> <span class="title">logger</span>. <span class="title">If</span> <span class="title">Logger</span> <span class="title">is</span> <span class="title">not</span> <span class="title">set</span>, <span class="title">it</span> <span class="title">will</span> <span class="title">fall</span> <span class="title">back</span> <span class="title">to</span> <span class="title">the</span></span></span><br><span class="line"><span class="function">	// <span class="title">behavior</span> <span class="title">for</span> <span class="title">using</span> <span class="title">LogOutput</span>. <span class="title">You</span> <span class="title">cannot</span> <span class="title">specify</span> <span class="title">both</span> <span class="title">LogOutput</span> <span class="title">and</span> <span class="title">Logger</span></span></span><br><span class="line"><span class="function">	// <span class="title">at</span> <span class="title">the</span> <span class="title">same</span> <span class="title">time</span>.</span></span><br><span class="line"><span class="function">	<span class="title">Logger</span> *<span class="title">log</span>.<span class="title">Logger</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	// <span class="title">Size</span> <span class="title">of</span> <span class="title">Memberlist</span>'<span class="title">s</span> <span class="title">internal</span> <span class="title">channel</span> <span class="title">which</span> <span class="title">handles</span> <span class="title">UDP</span> <span class="title">messages</span>. <span class="title">The</span></span></span><br><span class="line"><span class="function">	// <span class="title">size</span> <span class="title">of</span> <span class="title">this</span> <span class="title">determines</span> <span class="title">the</span> <span class="title">size</span> <span class="title">of</span> <span class="title">the</span> <span class="title">queue</span> <span class="title">which</span> <span class="title">Memberlist</span> <span class="title">will</span> <span class="title">keep</span></span></span><br><span class="line"><span class="function">	// <span class="title">while</span> <span class="title">UDP</span> <span class="title">messages</span> <span class="title">are</span> <span class="title">handled</span>.</span></span><br><span class="line"><span class="function">	<span class="title">HandoffQueueDepth</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	// <span class="title">Maximum</span> <span class="title">number</span> <span class="title">of</span> <span class="title">bytes</span> <span class="title">that</span> <span class="title">memberlist</span> <span class="title">will</span> <span class="title">put</span> <span class="title">in</span> <span class="title">a</span> <span class="title">packet</span> <span class="params">(this</span></span></span><br><span class="line"><span class="function"><span class="params">	// will be <span class="keyword">for</span> UDP packets by <span class="keyword">default</span> with a NetTransport)</span>. <span class="title">A</span> <span class="title">safe</span> <span class="title">value</span></span></span><br><span class="line"><span class="function">	// <span class="title">for</span> <span class="title">this</span> <span class="title">is</span> <span class="title">typically</span> 1400 <span class="title">bytes</span> <span class="params">(which is the <span class="keyword">default</span>)</span>. <span class="title">However</span>,</span></span><br><span class="line"><span class="function">	// <span class="title">depending</span> <span class="title">on</span> <span class="title">your</span> <span class="title">network</span>'<span class="title">s</span> <span class="title">MTU</span> <span class="params">(Maximum Transmission Unit)</span> <span class="title">you</span> <span class="title">may</span></span></span><br><span class="line"><span class="function">	// <span class="title">be</span> <span class="title">able</span> <span class="title">to</span> <span class="title">increase</span> <span class="title">this</span> <span class="title">to</span> <span class="title">get</span> <span class="title">more</span> <span class="title">content</span> <span class="title">into</span> <span class="title">each</span> <span class="title">gossip</span> <span class="title">packet</span>.</span></span><br><span class="line"><span class="function">	// <span class="title">This</span> <span class="title">is</span> <span class="title">a</span> <span class="title">legacy</span> <span class="title">name</span> <span class="title">for</span> <span class="title">backward</span> <span class="title">compatibility</span> <span class="title">but</span> <span class="title">should</span> <span class="title">really</span> <span class="title">be</span></span></span><br><span class="line"><span class="function">	// <span class="title">called</span> <span class="title">PacketBufferSize</span> <span class="title">now</span> <span class="title">that</span> <span class="title">we</span> <span class="title">have</span> <span class="title">generalized</span> <span class="title">the</span> <span class="title">transport</span>.</span></span><br><span class="line"><span class="function">	<span class="title">UDPBufferSize</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	// <span class="title">DeadNodeReclaimTime</span> <span class="title">controls</span> <span class="title">the</span> <span class="title">time</span> <span class="title">before</span> <span class="title">a</span> <span class="title">dead</span> <span class="title">node</span>'<span class="title">s</span> <span class="title">name</span> <span class="title">can</span> <span class="title">be</span></span></span><br><span class="line"><span class="function">	// <span class="title">reclaimed</span> <span class="title">by</span> <span class="title">one</span> <span class="title">with</span> <span class="title">a</span> <span class="title">different</span> <span class="title">address</span> <span class="title">or</span> <span class="title">port</span>. <span class="title">By</span> <span class="title">default</span>, <span class="title">this</span> <span class="title">is</span> 0,</span></span><br><span class="line"><span class="function">	// <span class="title">meaning</span> <span class="title">nodes</span> <span class="title">cannot</span> <span class="title">be</span> <span class="title">reclaimed</span> <span class="title">this</span> <span class="title">way</span>.</span></span><br><span class="line"><span class="function">	<span class="title">DeadNodeReclaimTime</span> <span class="title">time</span>.<span class="title">Duration</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">	// <span class="title">RequireNodeNames</span> <span class="title">controls</span> <span class="title">if</span> <span class="title">the</span> <span class="title">name</span> <span class="title">of</span> <span class="title">a</span> <span class="title">node</span> <span class="title">is</span> <span class="title">required</span> <span class="title">when</span> <span class="title">sending</span></span></span><br><span class="line"><span class="function">	// <span class="title">a</span> <span class="title">message</span> <span class="title">to</span> <span class="title">that</span> <span class="title">node</span>.</span></span><br><span class="line"><span class="function">	<span class="title">RequireNodeNames</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function">	// <span class="title">CIDRsAllowed</span> <span class="title">If</span> <span class="title">nil</span>, <span class="title">allow</span> <span class="title">any</span> <span class="title">connection</span> <span class="params">(<span class="keyword">default</span>)</span>, <span class="title">otherwise</span> <span class="title">specify</span> <span class="title">all</span> <span class="title">networks</span></span></span><br><span class="line"><span class="function">	// <span class="title">allowed</span> <span class="title">to</span> <span class="title">connect</span> <span class="params">(you must specify IPv6/IPv4 separately)</span></span></span><br><span class="line"><span class="function">	// <span class="title">Using</span> [] <span class="title">will</span> <span class="title">block</span> <span class="title">all</span> <span class="title">connections</span>.</span></span><br><span class="line"><span class="function">	<span class="title">CIDRsAllowed</span> []<span class="title">net</span>.<span class="title">IPNet</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="从create开始"><a href="#从create开始" class="headerlink" title="从create开始"></a>从create开始</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码来自github.com/hashicorp/memberlist/memberlist.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span><span class="params">(conf *Config)</span> <span class="params">(*Memberlist, error)</span></span> &#123;</span><br><span class="line">	m, err := newMemberlist(conf)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := m.setAlive(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		m.Shutdown()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	m.schedule()</span><br><span class="line">	<span class="keyword">return</span> m, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面有两个重要步骤：</p>
<ul>
<li>newMemberlist</li>
<li>m.schedule</li>
</ul>
<h4 id="newMemberlist"><a href="#newMemberlist" class="headerlink" title="newMemberlist"></a>newMemberlist</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码来自github.com/hashicorp/memberlist/memberlist.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newMemberlist</span><span class="params">(conf *Config)</span> <span class="params">(*Memberlist, error)</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">	m := &amp;Memberlist&#123;</span><br><span class="line">		config:               conf,</span><br><span class="line">		shutdownCh:           <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">		leaveBroadcast:       <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>),</span><br><span class="line">		transport:            nodeAwareTransport,</span><br><span class="line">		handoffCh:            <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>),</span><br><span class="line">		highPriorityMsgQueue: list.New(),</span><br><span class="line">		lowPriorityMsgQueue:  list.New(),</span><br><span class="line">		nodeMap:              <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*nodeState),</span><br><span class="line">		nodeTimers:           <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*suspicion),</span><br><span class="line">		awareness:            newAwareness(conf.AwarenessMaxMultiplier),</span><br><span class="line">		ackHandlers:          <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">uint32</span>]*ackHandler),</span><br><span class="line">		broadcasts:           &amp;TransmitLimitedQueue&#123;RetransmitMult: conf.RetransmitMult&#125;,</span><br><span class="line">		logger:               logger,</span><br><span class="line">	&#125;</span><br><span class="line">  ...</span><br><span class="line">	<span class="keyword">go</span> m.streamListen()</span><br><span class="line">	<span class="keyword">go</span> m.packetListen()</span><br><span class="line">	<span class="keyword">go</span> m.packetHandler()</span><br><span class="line">	<span class="keyword">return</span> m, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在newMemberlist中，最主要的动作就是开启了tcp服务(<code>m.streamListen()</code>)和udp服务(<code>m.packetListen()</code>)，那么就看看net服务（tcp和udp）：</p>
<h5 id="TCP-处理"><a href="#TCP-处理" class="headerlink" title="TCP 处理"></a>TCP 处理</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码来自github.com/hashicorp/memberlist/net.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Memberlist)</span> <span class="title">streamListen</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> conn := &lt;-m.transport.StreamCh(): <span class="comment">//tcp accept</span></span><br><span class="line">      <span class="comment">// 每个链接都有一个处理部分handleConn</span></span><br><span class="line">			<span class="keyword">go</span> m.handleConn(conn)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> &lt;-m.shutdownCh:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续看下处理函数 <code>m.handleConn(conn)</code></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码来自github.com/hashicorp/memberlist/net.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Memberlist)</span> <span class="title">handleConn</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	m.logger.Printf(<span class="string">"[DEBUG] memberlist: Stream connection %s"</span>, LogConn(conn))</span><br><span class="line"></span><br><span class="line">	metrics.IncrCounter([]<span class="keyword">string</span>&#123;<span class="string">"memberlist"</span>, <span class="string">"tcp"</span>, <span class="string">"accept"</span>&#125;, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	conn.SetDeadline(time.Now().Add(m.config.TCPTimeout))</span><br><span class="line">	msgType, bufConn, dec, err := m.readStream(conn)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err != io.EOF &#123;</span><br><span class="line">			m.logger.Printf(<span class="string">"[ERR] memberlist: failed to receive: %s %s"</span>, err, LogConn(conn))</span><br><span class="line"></span><br><span class="line">			resp := errResp&#123;err.Error()&#125;</span><br><span class="line">			out, err := encode(errMsg, &amp;resp)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				m.logger.Printf(<span class="string">"[ERR] memberlist: Failed to encode error response: %s"</span>, err)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			err = m.rawSendMsgStream(conn, out.Bytes())</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				m.logger.Printf(<span class="string">"[ERR] memberlist: Failed to send error: %s %s"</span>, err, LogConn(conn))</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> msgType &#123;</span><br><span class="line">	<span class="keyword">case</span> userMsg:</span><br><span class="line">		<span class="keyword">if</span> err := m.readUserMsg(bufConn, dec); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			m.logger.Printf(<span class="string">"[ERR] memberlist: Failed to receive user message: %s %s"</span>, err, LogConn(conn))</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> pushPullMsg:</span><br><span class="line">		<span class="comment">// Increment counter of pending push/pulls</span></span><br><span class="line">		numConcurrent := atomic.AddUint32(&amp;m.pushPullReq, <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">defer</span> atomic.AddUint32(&amp;m.pushPullReq, ^<span class="keyword">uint32</span>(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Check if we have too many open push/pull requests</span></span><br><span class="line">		<span class="keyword">if</span> numConcurrent &gt;= maxPushPullRequests &#123;</span><br><span class="line">			m.logger.Printf(<span class="string">"[ERR] memberlist: Too many pending push/pull requests"</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		join, remoteNodes, userState, err := m.readRemoteState(bufConn, dec)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			m.logger.Printf(<span class="string">"[ERR] memberlist: Failed to read remote state: %s %s"</span>, err, LogConn(conn))</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err := m.sendLocalState(conn, join); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			m.logger.Printf(<span class="string">"[ERR] memberlist: Failed to push local state: %s %s"</span>, err, LogConn(conn))</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err := m.mergeRemoteState(join, remoteNodes, userState); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			m.logger.Printf(<span class="string">"[ERR] memberlist: Failed push/pull merge: %s %s"</span>, err, LogConn(conn))</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> pingMsg:</span><br><span class="line">		<span class="keyword">var</span> p ping</span><br><span class="line">		<span class="keyword">if</span> err := dec.Decode(&amp;p); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			m.logger.Printf(<span class="string">"[ERR] memberlist: Failed to decode ping: %s %s"</span>, err, LogConn(conn))</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> p.Node != <span class="string">""</span> &amp;&amp; p.Node != m.config.Name &#123;</span><br><span class="line">			m.logger.Printf(<span class="string">"[WARN] memberlist: Got ping for unexpected node %s %s"</span>, p.Node, LogConn(conn))</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ack := ackResp&#123;p.SeqNo, <span class="literal">nil</span>&#125;</span><br><span class="line">		out, err := encode(ackRespMsg, &amp;ack)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			m.logger.Printf(<span class="string">"[ERR] memberlist: Failed to encode ack: %s"</span>, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		err = m.rawSendMsgStream(conn, out.Bytes())</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			m.logger.Printf(<span class="string">"[ERR] memberlist: Failed to send ack: %s %s"</span>, err, LogConn(conn))</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		m.logger.Printf(<span class="string">"[ERR] memberlist: Received invalid msgType (%d) %s"</span>, msgType, LogConn(conn))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体来看，这个方法就是读取TCP流数据，然后对数据进行判断类型，进行相应的处理，ping包和user包暂时不看，看下pullPush的类型的处理，分为三步：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码来自github.com/hashicorp/memberlist/net.go		</span></span><br><span class="line">    <span class="comment">// 读取Remote的状态</span></span><br><span class="line">    join, remoteNodes, userState, err := m.readRemoteState(bufConn, dec)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			m.logger.Printf(<span class="string">"[ERR] memberlist: Failed to read remote state: %s %s"</span>, err, LogConn(conn))</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送本地节点的状态</span></span><br><span class="line">		<span class="keyword">if</span> err := m.sendLocalState(conn, join); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			m.logger.Printf(<span class="string">"[ERR] memberlist: Failed to push local state: %s %s"</span>, err, LogConn(conn))</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将收到的Remote状态进行更新</span></span><br><span class="line">		<span class="keyword">if</span> err := m.mergeRemoteState(join, remoteNodes, userState); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			m.logger.Printf(<span class="string">"[ERR] memberlist: Failed push/pull merge: %s %s"</span>, err, LogConn(conn))</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p><strong>可以看到tcp服务提供的功能就是：同步节点状态。</strong></p>
<p>分别砍下这三个步骤的处理</p>
<h6 id="readRemoteState"><a href="#readRemoteState" class="headerlink" title="readRemoteState"></a>readRemoteState</h6><p>读取节点状态信息，并返回</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码来自github.com/hashicorp/memberlist/net.go</span></span><br><span class="line"><span class="comment">// readRemoteState is used to read the remote state from a connection</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Memberlist)</span> <span class="title">readRemoteState</span><span class="params">(bufConn io.Reader, dec *codec.Decoder)</span> <span class="params">(<span class="keyword">bool</span>, []pushNodeState, []<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Read the push/pull header</span></span><br><span class="line">  <span class="comment">// 读取数据</span></span><br><span class="line">	<span class="keyword">var</span> header pushPullHeader</span><br><span class="line">	<span class="keyword">if</span> err := dec.Decode(&amp;header); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allocate space for the transfer</span></span><br><span class="line">  <span class="comment">// 解码所有的节点信息</span></span><br><span class="line">	remoteNodes := <span class="built_in">make</span>([]pushNodeState, header.Nodes)</span><br><span class="line">	<span class="comment">// Try to decode all the states</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; header.Nodes; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> err := dec.Decode(&amp;remoteNodes[i]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Read the remote user state into a buffer</span></span><br><span class="line">	<span class="keyword">var</span> userBuf []<span class="keyword">byte</span></span><br><span class="line">	<span class="keyword">if</span> header.UserStateLen &gt; <span class="number">0</span> &#123;</span><br><span class="line">		userBuf = <span class="built_in">make</span>([]<span class="keyword">byte</span>, header.UserStateLen)</span><br><span class="line">		bytes, err := io.ReadAtLeast(bufConn, userBuf, header.UserStateLen)</span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; bytes != header.UserStateLen &#123;</span><br><span class="line">			err = fmt.Errorf(</span><br><span class="line">				<span class="string">"Failed to read full user state (%d / %d)"</span>,</span><br><span class="line">				bytes, header.UserStateLen)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// For proto versions &lt; 2, there is no port provided. Mask old</span></span><br><span class="line">	<span class="comment">// behavior by using the configured port</span></span><br><span class="line">	<span class="keyword">for</span> idx := <span class="keyword">range</span> remoteNodes &#123;</span><br><span class="line">		<span class="keyword">if</span> m.ProtocolVersion() &lt; <span class="number">2</span> || remoteNodes[idx].Port == <span class="number">0</span> &#123;</span><br><span class="line">			remoteNodes[idx].Port = <span class="keyword">uint16</span>(m.config.BindPort)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回节点状态信息</span></span><br><span class="line">	<span class="keyword">return</span> header.Join, remoteNodes, userBuf, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="sendLocalState"><a href="#sendLocalState" class="headerlink" title="sendLocalState"></a>sendLocalState</h6><p>发送本地存储的节点状态信息</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">// 代码来自github.com/hashicorp/memberlist/net.go</span><br><span class="line">// sendLocalState <span class="keyword">is</span> invoked to send our local state over a stream connection.</span><br><span class="line">func (m *Memberlist) sendLocalState(conn net.Conn, join bool) error &#123;</span><br><span class="line">	// Setup a deadline</span><br><span class="line">	conn.SetDeadline(time.Now().Add(m.config.TCPTimeout))</span><br><span class="line"></span><br><span class="line">	// Prepare the local node state</span><br><span class="line">  // 收集本地存储的节点状态信息</span><br><span class="line">	m.nodeLock.RLock()</span><br><span class="line">	localNodes := make([]pushNodeState, len(m.nodes))</span><br><span class="line">	<span class="keyword">for</span> idx, n := range m.nodes &#123;</span><br><span class="line">		localNodes[idx].Name = n.Name</span><br><span class="line">		localNodes[idx].Addr = n.Addr</span><br><span class="line">		localNodes[idx].Port = n.Port</span><br><span class="line">		localNodes[idx].Incarnation = n.Incarnation</span><br><span class="line">		localNodes[idx].State = n.State</span><br><span class="line">		localNodes[idx].Meta = n.Meta</span><br><span class="line">		localNodes[idx].Vsn = []uint8&#123;</span><br><span class="line">			n.PMin, n.PMax, n.PCur,</span><br><span class="line">			n.DMin, n.DMax, n.DCur,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	m.nodeLock.RUnlock()</span><br><span class="line"></span><br><span class="line">	// Get the delegate state</span><br><span class="line">	var userData []byte</span><br><span class="line">	<span class="keyword">if</span> m.config.Delegate != nil &#123;</span><br><span class="line">		userData = m.config.Delegate.LocalState(join)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Create a bytes buffer writer</span><br><span class="line">	bufConn := bytes.NewBuffer(nil)</span><br><span class="line"></span><br><span class="line">	// Send our node state</span><br><span class="line">  // 添加头部信息</span><br><span class="line">	header := pushPullHeader&#123;Nodes: len(localNodes), UserStateLen: len(userData), Join: join&#125;</span><br><span class="line">	hd := codec.MsgpackHandle&#123;&#125;</span><br><span class="line">	enc := codec.NewEncoder(bufConn, &amp;hd)</span><br><span class="line"></span><br><span class="line">	// Begin state push</span><br><span class="line">	<span class="keyword">if</span> _, err := bufConn.Write([]byte&#123;byte(pushPullMsg)&#125;); err != nil &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  // 编码并发送</span><br><span class="line">	<span class="keyword">if</span> err := enc.Encode(&amp;header); err != nil &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; header.Nodes; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> err := enc.Encode(&amp;localNodes[i]); err != nil &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Write the user state <span class="keyword">as</span> well</span><br><span class="line">	<span class="keyword">if</span> userData != nil &#123;</span><br><span class="line">		<span class="keyword">if</span> _, err := bufConn.Write(userData); err != nil &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Get the send buffer</span><br><span class="line">	<span class="keyword">return</span> m.rawSendMsgStream(conn, bufConn.Bytes())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="mergeRemoteState"><a href="#mergeRemoteState" class="headerlink" title="mergeRemoteState"></a>mergeRemoteState</h6><p>更新节点状态</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码来自github.com/hashicorp/memberlist/net.go</span></span><br><span class="line"><span class="comment">// mergeRemoteState is used to merge the remote state with our local state</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Memberlist)</span> <span class="title">mergeRemoteState</span><span class="params">(join <span class="keyword">bool</span>, remoteNodes []pushNodeState, userBuf []<span class="keyword">byte</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err := m.verifyProtocol(remoteNodes); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Invoke the merge delegate if any</span></span><br><span class="line">	<span class="keyword">if</span> join &amp;&amp; m.config.Merge != <span class="literal">nil</span> &#123;</span><br><span class="line">		nodes := <span class="built_in">make</span>([]*Node, <span class="built_in">len</span>(remoteNodes))</span><br><span class="line">		<span class="keyword">for</span> idx, n := <span class="keyword">range</span> remoteNodes &#123;</span><br><span class="line">			nodes[idx] = &amp;Node&#123;</span><br><span class="line">				Name:  n.Name,</span><br><span class="line">				Addr:  n.Addr,</span><br><span class="line">				Port:  n.Port,</span><br><span class="line">				Meta:  n.Meta,</span><br><span class="line">				State: n.State,</span><br><span class="line">				PMin:  n.Vsn[<span class="number">0</span>],</span><br><span class="line">				PMax:  n.Vsn[<span class="number">1</span>],</span><br><span class="line">				PCur:  n.Vsn[<span class="number">2</span>],</span><br><span class="line">				DMin:  n.Vsn[<span class="number">3</span>],</span><br><span class="line">				DMax:  n.Vsn[<span class="number">4</span>],</span><br><span class="line">				DCur:  n.Vsn[<span class="number">5</span>],</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err := m.config.Merge.NotifyMerge(nodes); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Merge the membership state</span></span><br><span class="line">	m.mergeState(remoteNodes)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Invoke the delegate for user state</span></span><br><span class="line">	<span class="keyword">if</span> userBuf != <span class="literal">nil</span> &amp;&amp; m.config.Delegate != <span class="literal">nil</span> &#123;</span><br><span class="line">		m.config.Delegate.MergeRemoteState(userBuf, join)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码来自github.com/hashicorp/memberlist/state.go</span></span><br><span class="line"><span class="comment">// mergeState is invoked by the network layer when we get a Push/Pull</span></span><br><span class="line"><span class="comment">// state transfer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Memberlist)</span> <span class="title">mergeState</span><span class="params">(remote []pushNodeState)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, r := <span class="keyword">range</span> remote &#123;</span><br><span class="line">		<span class="keyword">switch</span> r.State &#123;</span><br><span class="line">		<span class="keyword">case</span> StateAlive:</span><br><span class="line">			a := alive&#123;</span><br><span class="line">				Incarnation: r.Incarnation,</span><br><span class="line">				Node:        r.Name,</span><br><span class="line">				Addr:        r.Addr,</span><br><span class="line">				Port:        r.Port,</span><br><span class="line">				Meta:        r.Meta,</span><br><span class="line">				Vsn:         r.Vsn,</span><br><span class="line">			&#125;</span><br><span class="line">			m.aliveNode(&amp;a, <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> StateLeft:</span><br><span class="line">			d := dead&#123;Incarnation: r.Incarnation, Node: r.Name, From: r.Name&#125;</span><br><span class="line">			m.deadNode(&amp;d)</span><br><span class="line">		<span class="keyword">case</span> StateDead:</span><br><span class="line">			<span class="comment">// If the remote node believes a node is dead, we prefer to</span></span><br><span class="line">			<span class="comment">// suspect that node instead of declaring it dead instantly</span></span><br><span class="line">			<span class="keyword">fallthrough</span></span><br><span class="line">		<span class="keyword">case</span> StateSuspect:</span><br><span class="line">			s := suspect&#123;Incarnation: r.Incarnation, Node: r.Name, From: m.config.Name&#125;</span><br><span class="line">			m.suspectNode(&amp;s)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存在四种状态处理：</p>
<ul>
<li>StateAlive</li>
<li>StateLeft</li>
<li>StateDead/StateSuspect</li>
</ul>
<p>这几种状态的处理在后面说</p>
<p><strong>到这里小结一下，tcp链接，主要处理节点状态信息的同步与更新。</strong></p>
<h5 id="UDP-处理"><a href="#UDP-处理" class="headerlink" title="UDP 处理"></a>UDP 处理</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码来自github.com/hashicorp/memberlist/net.go</span></span><br><span class="line"><span class="comment">// packetListen is a long running goroutine that pulls packets out of the</span></span><br><span class="line"><span class="comment">// transport and hands them off for processing.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Memberlist)</span> <span class="title">packetListen</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> packet := &lt;-m.transport.PacketCh():</span><br><span class="line">			m.ingestPacket(packet.Buf, packet.From, packet.Timestamp)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> &lt;-m.shutdownCh:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Memberlist)</span> <span class="title">ingestPacket</span><span class="params">(buf []<span class="keyword">byte</span>, from net.Addr, timestamp time.Time)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Check if encryption is enabled</span></span><br><span class="line">	<span class="keyword">if</span> m.config.EncryptionEnabled() &#123;</span><br><span class="line">		<span class="comment">// Decrypt the payload</span></span><br><span class="line">    <span class="comment">// 读取数据</span></span><br><span class="line">		plain, err := decryptPayload(m.config.Keyring.GetKeys(), buf, <span class="literal">nil</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> !m.config.GossipVerifyIncoming &#123;</span><br><span class="line">				<span class="comment">// Treat the message as plaintext</span></span><br><span class="line">				plain = buf</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				m.logger.Printf(<span class="string">"[ERR] memberlist: Decrypt packet failed: %v %s"</span>, err, LogAddress(from))</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Continue processing the plaintext buffer</span></span><br><span class="line">		buf = plain</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// See if there's a checksum included to verify the contents of the message</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(buf) &gt;= <span class="number">5</span> &amp;&amp; messageType(buf[<span class="number">0</span>]) == hasCrcMsg &#123;</span><br><span class="line">		crc := crc32.ChecksumIEEE(buf[<span class="number">5</span>:])</span><br><span class="line">		expected := binary.BigEndian.Uint32(buf[<span class="number">1</span>:<span class="number">5</span>])</span><br><span class="line">		<span class="keyword">if</span> crc != expected &#123;</span><br><span class="line">			m.logger.Printf(<span class="string">"[WARN] memberlist: Got invalid checksum for UDP packet: %x, %x"</span>, crc, expected)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">// 处理函数</span></span><br><span class="line">		m.handleCommand(buf[<span class="number">5</span>:], from, timestamp)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		m.handleCommand(buf, from, timestamp)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="handleCommand"><a href="#handleCommand" class="headerlink" title="handleCommand"></a>handleCommand</h6><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Memberlist)</span> <span class="title">handleCommand</span><span class="params">(buf []<span class="keyword">byte</span>, from net.Addr, timestamp time.Time)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Decode the message type</span></span><br><span class="line">  <span class="comment">// 解码消息类型</span></span><br><span class="line">	msgType := messageType(buf[<span class="number">0</span>])</span><br><span class="line">	buf = buf[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Switch on the msgType</span></span><br><span class="line">  <span class="comment">// 根据消息不同消息类型，进行不同的处理</span></span><br><span class="line">	<span class="keyword">switch</span> msgType &#123;</span><br><span class="line">	<span class="keyword">case</span> compoundMsg:</span><br><span class="line">		m.handleCompound(buf, from, timestamp)</span><br><span class="line">	<span class="keyword">case</span> compressMsg:</span><br><span class="line">		m.handleCompressed(buf, from, timestamp)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> pingMsg:</span><br><span class="line">		m.handlePing(buf, from)</span><br><span class="line">	<span class="keyword">case</span> indirectPingMsg:</span><br><span class="line">		m.handleIndirectPing(buf, from)</span><br><span class="line">	<span class="keyword">case</span> ackRespMsg:</span><br><span class="line">		m.handleAck(buf, from, timestamp)</span><br><span class="line">	<span class="keyword">case</span> nackRespMsg:</span><br><span class="line">		m.handleNack(buf, from)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> suspectMsg:</span><br><span class="line">		<span class="keyword">fallthrough</span></span><br><span class="line">	<span class="keyword">case</span> aliveMsg:</span><br><span class="line">		<span class="keyword">fallthrough</span></span><br><span class="line">	<span class="keyword">case</span> deadMsg:</span><br><span class="line">		<span class="keyword">fallthrough</span></span><br><span class="line">	<span class="keyword">case</span> userMsg:</span><br><span class="line">		<span class="comment">// Determine the message queue, prioritize alive</span></span><br><span class="line">		queue := m.lowPriorityMsgQueue</span><br><span class="line">		<span class="keyword">if</span> msgType == aliveMsg &#123;</span><br><span class="line">			queue = m.highPriorityMsgQueue</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Check for overflow and append if not full</span></span><br><span class="line">		m.msgQueueLock.Lock()</span><br><span class="line">		<span class="keyword">if</span> queue.Len() &gt;= m.config.HandoffQueueDepth &#123;</span><br><span class="line">			m.logger.Printf(<span class="string">"[WARN] memberlist: handler queue full, dropping message (%d) %s"</span>, msgType, LogAddress(from))</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			queue.PushBack(msgHandoff&#123;msgType, buf, from&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">		m.msgQueueLock.Unlock()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Notify of pending message</span></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> m.handoffCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		m.logger.Printf(<span class="string">"[ERR] memberlist: msg type (%d) not supported %s"</span>, msgType, LogAddress(from))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>compoundMsg：处理函数为handleCompound，多个消息聚合在一起，进行分割，然后再重新调用handleCommand.</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Memberlist)</span> <span class="title">handleCompound</span><span class="params">(buf []<span class="keyword">byte</span>, from net.Addr, timestamp time.Time)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Decode the parts</span></span><br><span class="line">  <span class="comment">// 消息分割</span></span><br><span class="line">	trunc, parts, err := decodeCompoundMessage(buf)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		m.logger.Printf(<span class="string">"[ERR] memberlist: Failed to decode compound request: %s %s"</span>, err, LogAddress(from))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Log any truncation</span></span><br><span class="line">	<span class="keyword">if</span> trunc &gt; <span class="number">0</span> &#123;</span><br><span class="line">		m.logger.Printf(<span class="string">"[WARN] memberlist: Compound request had %d truncated messages %s"</span>, trunc, LogAddress(from))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Handle each message</span></span><br><span class="line">	<span class="keyword">for</span> _, part := <span class="keyword">range</span> parts &#123;</span><br><span class="line">    <span class="comment">// 分割的消息重新调用handleCommand</span></span><br><span class="line">		m.handleCommand(part, from, timestamp)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>pingMsg：处理函数为：handlePing;</p>
</li>
<li><p>indirectPingMsg: 处理函数为handleindirectPing;</p>
</li>
<li><p>ackRespMsg: 处理函数为handleAck</p>
</li>
<li><p>suspectMsg/aliveMsg/deadMsg/userMsg: 处理函数为：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// Determine the message queue, prioritize alive</span></span><br><span class="line">	queue := m.lowPriorityMsgQueue</span><br><span class="line">	<span class="keyword">if</span> msgType == aliveMsg &#123;</span><br><span class="line">		queue = m.highPriorityMsgQueue</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">// Check for overflow and append if not full</span></span><br><span class="line">	m.msgQueueLock.Lock()</span><br><span class="line">	<span class="keyword">if</span> queue.Len() &gt;= m.config.HandoffQueueDepth &#123;</span><br><span class="line">		m.logger.Printf(<span class="string">"[WARN] memberlist: handler queue full, dropping message (%d) %s"</span>, msgType, LogAddress(from))</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		queue.PushBack(msgHandoff&#123;msgType, buf, from&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	m.msgQueueLock.Unlock()</span><br><span class="line">  </span><br><span class="line">	<span class="comment">// Notify of pending message</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> m.handoffCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	m.logger.Printf(<span class="string">"[ERR] memberlist: msg type (%d) not supported %s"</span>, msgType, LogAddress(from))</span><br></pre></td></tr></table></figure>
<p>m.handoffCh &lt;- struct{}{}，是否还记得上面开启TCP和UDP的时候，还有一个协程运行着：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> m.streamListen()</span><br><span class="line"><span class="keyword">go</span> m.packetListen()</span><br><span class="line"><span class="keyword">go</span> m.packetHandler()</span><br></pre></td></tr></table></figure>
<p><code>go m.packetHandler()</code></p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packetHandler is a long running goroutine that processes messages received</span></span><br><span class="line"><span class="comment">// over the packet interface, but is decoupled from the listener to avoid</span></span><br><span class="line"><span class="comment">// blocking the listener which may cause ping/ack messages to be delayed.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Memberlist)</span> <span class="title">packetHandler</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-m.handoffCh:</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				msg, ok := m.getNextMessage()</span><br><span class="line">				<span class="keyword">if</span> !ok &#123;</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">				msgType := msg.msgType</span><br><span class="line">				buf := msg.buf</span><br><span class="line">				from := msg.from</span><br><span class="line"></span><br><span class="line">				<span class="keyword">switch</span> msgType &#123;</span><br><span class="line">				<span class="keyword">case</span> suspectMsg:</span><br><span class="line">					m.handleSuspect(buf, from)</span><br><span class="line">				<span class="keyword">case</span> aliveMsg:</span><br><span class="line">					m.handleAlive(buf, from)</span><br><span class="line">				<span class="keyword">case</span> deadMsg:</span><br><span class="line">					m.handleDead(buf, from)</span><br><span class="line">				<span class="keyword">case</span> userMsg:</span><br><span class="line">					m.handleUser(buf, from)</span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">					m.logger.Printf(<span class="string">"[ERR] memberlist: Message type (%d) not supported %s (packet handler)"</span>, msgType, LogAddress(from))</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> &lt;-m.shutdownCh:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里监听 m.handoffCh，当UDP有消息传过来时，分别处理以下类型的消息，就不展开了</p>
</li>
<li><p>suspectMsg</p>
</li>
<li><p>aliveMsg</p>
</li>
<li><p>deadMsg</p>
</li>
<li><p>userMsg</p>
</li>
</ul>
<p><strong>udp服务提供了一些基本的Command操作</strong></p>
<h4 id="schedule"><a href="#schedule" class="headerlink" title="schedule"></a>schedule</h4><ul>
<li>Schedule函数开启probe协程、pushpull协程、gossip协程</li>
<li>probe协程：进行节点状态维护</li>
<li>push/pull协程：进行节点状态、用户数据同步</li>
<li>gossip协程：进行udp广播发送消息。</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Schedule is used to ensure the Tick is performed periodically. This</span></span><br><span class="line"><span class="comment">// function is safe to call multiple times. If the memberlist is already</span></span><br><span class="line"><span class="comment">// scheduled, then it won't do anything.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Memberlist)</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m.tickerLock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> m.tickerLock.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If we already have tickers, then don't do anything, since we're</span></span><br><span class="line">	<span class="comment">// scheduled</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(m.tickers) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create the stop tick channel, a blocking channel. We close this</span></span><br><span class="line">	<span class="comment">// when we should stop the tickers.</span></span><br><span class="line">	stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create a new probeTicker</span></span><br><span class="line">  <span class="comment">// 开启了probe协程</span></span><br><span class="line">	<span class="keyword">if</span> m.config.ProbeInterval &gt; <span class="number">0</span> &#123;</span><br><span class="line">		t := time.NewTicker(m.config.ProbeInterval)</span><br><span class="line">		<span class="keyword">go</span> m.triggerFunc(m.config.ProbeInterval, t.C, stopCh, m.probe)</span><br><span class="line">		m.tickers = <span class="built_in">append</span>(m.tickers, t)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create a push pull ticker if needed</span></span><br><span class="line">  <span class="comment">// 开启了pushpull协程</span></span><br><span class="line">	<span class="keyword">if</span> m.config.PushPullInterval &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">go</span> m.pushPullTrigger(stopCh)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create a gossip ticker if needed</span></span><br><span class="line">  <span class="comment">// 开启了gossip协程</span></span><br><span class="line">	<span class="keyword">if</span> m.config.GossipInterval &gt; <span class="number">0</span> &amp;&amp; m.config.GossipNodes &gt; <span class="number">0</span> &#123;</span><br><span class="line">		t := time.NewTicker(m.config.GossipInterval)</span><br><span class="line">		<span class="keyword">go</span> m.triggerFunc(m.config.GossipInterval, t.C, stopCh, m.gossip)</span><br><span class="line">		m.tickers = <span class="built_in">append</span>(m.tickers, t)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If we made any tickers, then record the stopTick channel for</span></span><br><span class="line">	<span class="comment">// later.</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(m.tickers) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		m.stopTick = stopCh</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里面一共开启了三个定时任务，probe、pushpull、gossip</p>
<h5 id="probe"><a href="#probe" class="headerlink" title="probe"></a>probe</h5><blockquote>
<p>当节点启动后，每隔一定时间间隔，会选取一个节点对其发送PING消息，当PING消息失败后，会随机选取 IndirectChecks 个节点发起间接PING的请求和直接更其再发起一个tcp PING消息。 收到间接PING请求的节点会根据请求中的地址发起一个PING消息，将PING的结果返回给间接请求的源节点。 如果探测超时之间内，本节点没有收到任何一个要探测节点的ACK消息，则标记要探测的节点状态为suspect。</p>
<p><a href="https://www.colabug.com/1010287.html" target="_blank" rel="external">https://www.colabug.com/1010287.html</a></p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tick is used to perform a single round of failure detection and gossip</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Memberlist)</span> <span class="title">probe</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Track the number of indexes we've considered probing</span></span><br><span class="line">	numCheck := <span class="number">0</span></span><br><span class="line">START:</span><br><span class="line">	m.nodeLock.RLock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Make sure we don't wrap around infinitely</span></span><br><span class="line">	<span class="keyword">if</span> numCheck &gt;= <span class="built_in">len</span>(m.nodes) &#123;</span><br><span class="line">		m.nodeLock.RUnlock()</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Handle the wrap around case</span></span><br><span class="line">  <span class="comment">// probeIndex是node索引，循环进行探测</span></span><br><span class="line">	<span class="keyword">if</span> m.probeIndex &gt;= <span class="built_in">len</span>(m.nodes) &#123;</span><br><span class="line">		m.nodeLock.RUnlock()</span><br><span class="line">		m.resetNodes()</span><br><span class="line">		m.probeIndex = <span class="number">0</span></span><br><span class="line">		numCheck++</span><br><span class="line">		<span class="keyword">goto</span> START</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Determine if we should probe this node</span></span><br><span class="line">	skip := <span class="literal">false</span></span><br><span class="line">	<span class="keyword">var</span> node nodeState</span><br><span class="line"></span><br><span class="line">	node = *m.nodes[m.probeIndex]</span><br><span class="line">	<span class="keyword">if</span> node.Name == m.config.Name &#123;</span><br><span class="line">		skip = <span class="literal">true</span> <span class="comment">//当node在配置文件中</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> node.DeadOrLeft() &#123;</span><br><span class="line">		skip = <span class="literal">true</span> <span class="comment">//当node为dead时候</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Potentially skip</span></span><br><span class="line">	m.nodeLock.RUnlock()</span><br><span class="line">	m.probeIndex++</span><br><span class="line">	<span class="keyword">if</span> skip &#123; <span class="comment">//node在配置文件中或者为dead时候则跳过</span></span><br><span class="line">		numCheck++</span><br><span class="line">		<span class="keyword">goto</span> START</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Probe the specific node</span></span><br><span class="line">	m.probeNode(&amp;node)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// probeNode handles a single round of failure checking on a node.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Memberlist)</span> <span class="title">probeNode</span><span class="params">(node *nodeState)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> metrics.MeasureSince([]<span class="keyword">string</span>&#123;<span class="string">"memberlist"</span>, <span class="string">"probeNode"</span>&#125;, time.Now())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We use our health awareness to scale the overall probe interval, so we</span></span><br><span class="line">	<span class="comment">// slow down if we detect problems. The ticker that calls us can handle</span></span><br><span class="line">	<span class="comment">// us running over the base interval, and will skip missed ticks.</span></span><br><span class="line">	probeInterval := m.awareness.ScaleTimeout(m.config.ProbeInterval)</span><br><span class="line">	<span class="keyword">if</span> probeInterval &gt; m.config.ProbeInterval &#123;</span><br><span class="line">		metrics.IncrCounter([]<span class="keyword">string</span>&#123;<span class="string">"memberlist"</span>, <span class="string">"degraded"</span>, <span class="string">"probe"</span>&#125;, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Prepare a ping message and setup an ack handler.</span></span><br><span class="line">	selfAddr, selfPort := m.getAdvertise()</span><br><span class="line">	ping := ping&#123;</span><br><span class="line">		SeqNo:      m.nextSeqNo(),</span><br><span class="line">		Node:       node.Name,</span><br><span class="line">		SourceAddr: selfAddr,</span><br><span class="line">		SourcePort: selfPort,</span><br><span class="line">		SourceNode: m.config.Name,</span><br><span class="line">	&#125;</span><br><span class="line">	ackCh := <span class="built_in">make</span>(<span class="keyword">chan</span> ackMessage, m.config.IndirectChecks+<span class="number">1</span>)</span><br><span class="line">	nackCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, m.config.IndirectChecks+<span class="number">1</span>)</span><br><span class="line">	m.setProbeChannels(ping.SeqNo, ackCh, nackCh, probeInterval)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Mark the sent time here, which should be after any pre-processing but</span></span><br><span class="line">	<span class="comment">// before system calls to do the actual send. This probably over-reports</span></span><br><span class="line">	<span class="comment">// a bit, but it's the best we can do. We had originally put this right</span></span><br><span class="line">	<span class="comment">// after the I/O, but that would sometimes give negative RTT measurements</span></span><br><span class="line">	<span class="comment">// which was not desirable.</span></span><br><span class="line">	sent := time.Now()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Send a ping to the node. If this node looks like it's suspect or dead,</span></span><br><span class="line">	<span class="comment">// also tack on a suspect message so that it has a chance to refute as</span></span><br><span class="line">	<span class="comment">// soon as possible.</span></span><br><span class="line">	deadline := sent.Add(probeInterval)</span><br><span class="line">	addr := node.Address()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Arrange for our self-awareness to get updated.</span></span><br><span class="line">	<span class="keyword">var</span> awarenessDelta <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		m.awareness.ApplyDelta(awarenessDelta)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">if</span> node.State == StateAlive &#123;</span><br><span class="line">    <span class="comment">// 发送pingMsg</span></span><br><span class="line">		<span class="keyword">if</span> err := m.encodeAndSendMsg(node.FullAddress(), pingMsg, &amp;ping); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			m.logger.Printf(<span class="string">"[ERR] memberlist: Failed to send ping: %s"</span>, err)</span><br><span class="line">			<span class="keyword">if</span> failedRemote(err) &#123;</span><br><span class="line">				<span class="keyword">goto</span> HANDLE_REMOTE_FAILURE</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">HANDLE_REMOTE_FAILURE:</span><br><span class="line">	<span class="comment">// Get some random live nodes.</span></span><br><span class="line">	m.nodeLock.RLock()</span><br><span class="line">  <span class="comment">// 随机获取一些节点</span></span><br><span class="line">	kNodes := kRandomNodes(m.config.IndirectChecks, m.nodes, <span class="function"><span class="keyword">func</span><span class="params">(n *nodeState)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n.Name == m.config.Name ||</span><br><span class="line">			n.Name == node.Name ||</span><br><span class="line">			n.State != StateAlive</span><br><span class="line">	&#125;)</span><br><span class="line">	m.nodeLock.RUnlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Attempt an indirect ping.</span></span><br><span class="line">	expectedNacks := <span class="number">0</span></span><br><span class="line">	selfAddr, selfPort = m.getAdvertise()</span><br><span class="line">	ind := indirectPingReq&#123;</span><br><span class="line">		SeqNo:      ping.SeqNo,</span><br><span class="line">		Target:     node.Addr,</span><br><span class="line">		Port:       node.Port,</span><br><span class="line">		Node:       node.Name,</span><br><span class="line">		SourceAddr: selfAddr,</span><br><span class="line">		SourcePort: selfPort,</span><br><span class="line">		SourceNode: m.config.Name,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, peer := <span class="keyword">range</span> kNodes &#123;</span><br><span class="line">		<span class="comment">// We only expect nack to be sent from peers who understand</span></span><br><span class="line">		<span class="comment">// version 4 of the protocol.</span></span><br><span class="line">		<span class="keyword">if</span> ind.Nack = peer.PMax &gt;= <span class="number">4</span>; ind.Nack &#123;</span><br><span class="line">			expectedNacks++</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送indirectPingMsg</span></span><br><span class="line">		<span class="keyword">if</span> err := m.encodeAndSendMsg(peer.FullAddress(), indirectPingMsg, &amp;ind); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			m.logger.Printf(<span class="string">"[ERR] memberlist: Failed to send indirect ping: %s"</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Also make an attempt to contact the node directly over TCP. This</span></span><br><span class="line">	<span class="comment">// helps prevent confused clients who get isolated from UDP traffic</span></span><br><span class="line">	<span class="comment">// but can still speak TCP (which also means they can possibly report</span></span><br><span class="line">	<span class="comment">// misinformation to other nodes via anti-entropy), avoiding flapping in</span></span><br><span class="line">	<span class="comment">// the cluster.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// This is a little unusual because we will attempt a TCP ping to any</span></span><br><span class="line">	<span class="comment">// member who understands version 3 of the protocol, regardless of</span></span><br><span class="line">	<span class="comment">// which protocol version we are speaking. That's why we've included a</span></span><br><span class="line">	<span class="comment">// config option to turn this off if desired.</span></span><br><span class="line">	fallbackCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	disableTcpPings := m.config.DisableTcpPings ||</span><br><span class="line">		(m.config.DisableTcpPingsForNode != <span class="literal">nil</span> &amp;&amp; m.config.DisableTcpPingsForNode(node.Name))</span><br><span class="line">	<span class="keyword">if</span> (!disableTcpPings) &amp;&amp; (node.PMax &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> <span class="built_in">close</span>(fallbackCh)</span><br><span class="line">			didContact, err := m.sendPingAndWaitForAck(node.FullAddress(), ping, deadline)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				m.logger.Printf(<span class="string">"[ERR] memberlist: Failed fallback ping: %s"</span>, err)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				fallbackCh &lt;- didContact</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">close</span>(fallbackCh)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Wait for the acks or timeout. Note that we don't check the fallback</span></span><br><span class="line">	<span class="comment">// channel here because we want to issue a warning below if that's the</span></span><br><span class="line">	<span class="comment">// *only* way we hear back from the peer, so we have to let this time</span></span><br><span class="line">	<span class="comment">// out first to allow the normal UDP-based acks to come in.</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> v := &lt;-ackCh:</span><br><span class="line">		<span class="keyword">if</span> v.Complete == <span class="literal">true</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Finally, poll the fallback channel. The timeouts are set such that</span></span><br><span class="line">	<span class="comment">// the channel will have something or be closed without having to wait</span></span><br><span class="line">	<span class="comment">// any additional time here.</span></span><br><span class="line">	<span class="keyword">for</span> didContact := <span class="keyword">range</span> fallbackCh &#123;</span><br><span class="line">		<span class="keyword">if</span> didContact &#123;</span><br><span class="line">			m.logger.Printf(<span class="string">"[WARN] memberlist: Was able to connect to %s but other probes failed, network may be misconfigured"</span>, node.Name)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Update our self-awareness based on the results of this failed probe.</span></span><br><span class="line">	<span class="comment">// If we don't have peers who will send nacks then we penalize for any</span></span><br><span class="line">	<span class="comment">// failed probe as a simple health metric. If we do have peers to nack</span></span><br><span class="line">	<span class="comment">// verify, then we can use that as a more sophisticated measure of self-</span></span><br><span class="line">	<span class="comment">// health because we assume them to be working, and they can help us</span></span><br><span class="line">	<span class="comment">// decide if the probed node was really dead or if it was something wrong</span></span><br><span class="line">	<span class="comment">// with ourselves.</span></span><br><span class="line">	awarenessDelta = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> expectedNacks &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> nackCount := <span class="built_in">len</span>(nackCh); nackCount &lt; expectedNacks &#123;</span><br><span class="line">			awarenessDelta += (expectedNacks - nackCount)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		awarenessDelta += <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// No acks received from target, suspect it as failed.</span></span><br><span class="line">	m.logger.Printf(<span class="string">"[INFO] memberlist: Suspect %s has failed, no acks received"</span>, node.Name)</span><br><span class="line">  <span class="comment">//若探测结果失败则将node设置为suspect</span></span><br><span class="line">	s := suspect&#123;Incarnation: node.Incarnation, Node: node.Name, From: m.config.Name&#125;</span><br><span class="line">	m.suspectNode(&amp;s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="pushpull"><a href="#pushpull" class="headerlink" title="pushpull"></a>pushpull</h5><blockquote>
<p>每隔一个时间间隔，随机选取一个节点，跟它建立tcp连接，然后将本地的全部节点 状态、用户数据发送过去，然后对端将其掌握的全部节点状态、用户数据发送回来，然后完成2份数据的合并。 此动作可以加速集群内信息的收敛速度。</p>
<p><a href="https://www.jianshu.com/p/e2173b44db65" target="_blank" rel="external">https://www.jianshu.com/p/e2173b44db65</a></p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Memberlist)</span> <span class="title">pushPullTrigger</span><span class="params">(stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	interval := m.config.PushPullInterval</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Use a random stagger to avoid syncronizing</span></span><br><span class="line">	randStagger := time.Duration(<span class="keyword">uint64</span>(rand.Int63()) % <span class="keyword">uint64</span>(interval))</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(randStagger):</span><br><span class="line">	<span class="keyword">case</span> &lt;-stop:</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Tick using a dynamic timer</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		tickTime := pushPullScale(interval, m.estNumNodes())</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-time.After(tickTime):</span><br><span class="line">			m.pushPull()</span><br><span class="line">		<span class="keyword">case</span> &lt;-stop:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Memberlist)</span> <span class="title">pushPull</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Get a random live node</span></span><br><span class="line">	m.nodeLock.RLock()</span><br><span class="line">  <span class="comment">// 随机选取1个节点</span></span><br><span class="line">	nodes := kRandomNodes(<span class="number">1</span>, m.nodes, <span class="function"><span class="keyword">func</span><span class="params">(n *nodeState)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n.Name == m.config.Name ||</span><br><span class="line">			n.State != StateAlive</span><br><span class="line">	&#125;)</span><br><span class="line">	m.nodeLock.RUnlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If no nodes, bail</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(nodes) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	node := nodes[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Attempt a push pull</span></span><br><span class="line">  <span class="comment">// 调用pushPullNode</span></span><br><span class="line">	<span class="keyword">if</span> err := m.pushPullNode(node.FullAddress(), <span class="literal">false</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		m.logger.Printf(<span class="string">"[ERR] memberlist: Push/Pull with %s failed: %s"</span>, node.Name, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面随机选取一个节点</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pushPullNode does a complete state exchange with a specific node.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Memberlist)</span> <span class="title">pushPullNode</span><span class="params">(a Address, join <span class="keyword">bool</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> metrics.MeasureSince([]<span class="keyword">string</span>&#123;<span class="string">"memberlist"</span>, <span class="string">"pushPullNode"</span>&#125;, time.Now())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Attempt to send and receive with the node</span></span><br><span class="line">  <span class="comment">// 发送并获取状态信息</span></span><br><span class="line">	remote, userState, err := m.sendAndReceiveState(a, join)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 合并更新节点状态信息</span></span><br><span class="line">	<span class="keyword">if</span> err := m.mergeRemoteState(join, remote, userState); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sendAndReceiveState is used to initiate a push/pull over a stream with a</span></span><br><span class="line"><span class="comment">// remote host.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Memberlist)</span> <span class="title">sendAndReceiveState</span><span class="params">(a Address, join <span class="keyword">bool</span>)</span> <span class="params">([]pushNodeState, []<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a.Name == <span class="string">""</span> &amp;&amp; m.config.RequireNodeNames &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, errNodeNamesAreRequired</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Attempt to connect</span></span><br><span class="line">  <span class="comment">// 创建tcp client链接</span></span><br><span class="line">	conn, err := m.transport.DialAddressTimeout(a, m.config.TCPTimeout)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	m.logger.Printf(<span class="string">"[DEBUG] memberlist: Initiating push/pull sync with: %s %s"</span>, a.Name, conn.RemoteAddr())</span><br><span class="line">	metrics.IncrCounter([]<span class="keyword">string</span>&#123;<span class="string">"memberlist"</span>, <span class="string">"tcp"</span>, <span class="string">"connect"</span>&#125;, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Send our state</span></span><br><span class="line">  <span class="comment">// 发送本地节点状态信息</span></span><br><span class="line">	<span class="keyword">if</span> err := m.sendLocalState(conn, join); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	conn.SetDeadline(time.Now().Add(m.config.TCPTimeout))</span><br><span class="line">	msgType, bufConn, dec, err := m.readStream(conn)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> msgType == errMsg &#123;</span><br><span class="line">		<span class="keyword">var</span> resp errResp</span><br><span class="line">		<span class="keyword">if</span> err := dec.Decode(&amp;resp); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">"remote error: %v"</span>, resp.Error)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Quit if not push/pull</span></span><br><span class="line">	<span class="keyword">if</span> msgType != pushPullMsg &#123;</span><br><span class="line">		err := fmt.Errorf(<span class="string">"received invalid msgType (%d), expected pushPullMsg (%d) %s"</span>, msgType, pushPullMsg, LogConn(conn))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Read remote state</span></span><br><span class="line">  <span class="comment">// 读取Remote节点状态信息并返回</span></span><br><span class="line">	_, remoteNodes, userState, err := m.readRemoteState(bufConn, dec)</span><br><span class="line">	<span class="keyword">return</span> remoteNodes, userState, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="gossip"><a href="#gossip" class="headerlink" title="gossip"></a>gossip</h5><blockquote>
<p>节点通过udp协议向K个节点发送消息，节点从广播队列里面获取消息，广播队列里的消息发送失败超过一定次数后，消息就会被丢弃。发送次数参考Config 里的 RetransmitMul的注释。</p>
<p><a href="https://www.jianshu.com/p/e2173b44db65" target="_blank" rel="external">https://www.jianshu.com/p/e2173b44db65</a></p>
</blockquote>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gossip is invoked every GossipInterval period to broadcast our gossip</span></span><br><span class="line"><span class="comment">// messages to a few random nodes.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Memberlist)</span> <span class="title">gossip</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> metrics.MeasureSince([]<span class="keyword">string</span>&#123;<span class="string">"memberlist"</span>, <span class="string">"gossip"</span>&#125;, time.Now())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Get some random live, suspect, or recently dead nodes</span></span><br><span class="line">	m.nodeLock.RLock()</span><br><span class="line">  <span class="comment">// 随机获取gossipNodes配置项个数的节点</span></span><br><span class="line">	kNodes := kRandomNodes(m.config.GossipNodes, m.nodes, <span class="function"><span class="keyword">func</span><span class="params">(n *nodeState)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> n.Name == m.config.Name &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> n.State &#123;</span><br><span class="line">		<span class="keyword">case</span> StateAlive, StateSuspect:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> StateDead:</span><br><span class="line">			<span class="keyword">return</span> time.Since(n.StateChange) &gt; m.config.GossipToTheDeadTime</span><br><span class="line"></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	m.nodeLock.RUnlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Compute the bytes available</span></span><br><span class="line">	bytesAvail := m.config.UDPBufferSize - compoundHeaderOverhead</span><br><span class="line">	<span class="keyword">if</span> m.config.EncryptionEnabled() &#123;</span><br><span class="line">		bytesAvail -= encryptOverhead(m.encryptionVersion())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, node := <span class="keyword">range</span> kNodes &#123;</span><br><span class="line">		<span class="comment">// Get any pending broadcasts</span></span><br><span class="line">    <span class="comment">// 获取能够广播消息大小</span></span><br><span class="line">		msgs := m.getBroadcasts(compoundOverhead, bytesAvail)</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(msgs) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		addr := node.Address()</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(msgs) == <span class="number">1</span> &#123;</span><br><span class="line">			<span class="comment">// Send single message as is</span></span><br><span class="line">			<span class="keyword">if</span> err := m.rawSendMsgPacket(node.FullAddress(), &amp;node.Node, msgs[<span class="number">0</span>]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				m.logger.Printf(<span class="string">"[ERR] memberlist: Failed to send gossip to %s: %s"</span>, addr, err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Otherwise create and send a compound message</span></span><br><span class="line">      <span class="comment">// 创建一个合并的消息</span></span><br><span class="line">			compound := makeCompoundMessage(msgs)</span><br><span class="line">      <span class="comment">// 发送消息</span></span><br><span class="line">			<span class="keyword">if</span> err := m.rawSendMsgPacket(node.FullAddress(), &amp;node.Node, compound.Bytes()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				m.logger.Printf(<span class="string">"[ERR] memberlist: Failed to send gossip to %s: %s"</span>, addr, err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此将节点的状态分为3种</p>
<ul>
<li><p>alive: 用于标识活跃节点</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// aliveNode is invoked by the network layer when we get a message about a</span></span><br><span class="line"><span class="comment">// live node.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Memberlist)</span> <span class="title">aliveNode</span><span class="params">(a *alive, notify <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, bootstrap <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	m.nodeLock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> m.nodeLock.Unlock()</span><br><span class="line">	state, ok := m.nodeMap[a.Node]</span><br><span class="line"></span><br><span class="line">	<span class="comment">// It is possible that during a Leave(), there is already an aliveMsg</span></span><br><span class="line">	<span class="comment">// in-queue to be processed but blocked by the locks above. If we let</span></span><br><span class="line">	<span class="comment">// that aliveMsg process, it'll cause us to re-join the cluster. This</span></span><br><span class="line">	<span class="comment">// ensures that we don't.</span></span><br><span class="line">	<span class="keyword">if</span> m.hasLeft() &amp;&amp; a.Node == m.config.Name &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(a.Vsn) &gt;= <span class="number">3</span> &#123;</span><br><span class="line">		pMin := a.Vsn[<span class="number">0</span>]</span><br><span class="line">		pMax := a.Vsn[<span class="number">1</span>]</span><br><span class="line">		pCur := a.Vsn[<span class="number">2</span>]</span><br><span class="line">		<span class="keyword">if</span> pMin == <span class="number">0</span> || pMax == <span class="number">0</span> || pMin &gt; pMax &#123;</span><br><span class="line">			m.logger.Printf(<span class="string">"[WARN] memberlist: Ignoring an alive message for '%s' (%v:%d) because protocol version(s) are wrong: %d &lt;= %d &lt;= %d should be &gt;0"</span>, a.Node, net.IP(a.Addr), a.Port, pMin, pCur, pMax)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Invoke the Alive delegate if any. This can be used to filter out</span></span><br><span class="line">	<span class="comment">// alive messages based on custom logic. For example, using a cluster name.</span></span><br><span class="line">	<span class="comment">// Using a merge delegate is not enough, as it is possible for passive</span></span><br><span class="line">	<span class="comment">// cluster merging to still occur.</span></span><br><span class="line">	<span class="keyword">if</span> m.config.Alive != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(a.Vsn) &lt; <span class="number">6</span> &#123;</span><br><span class="line">			m.logger.Printf(<span class="string">"[WARN] memberlist: ignoring alive message for '%s' (%v:%d) because Vsn is not present"</span>,</span><br><span class="line">				a.Node, net.IP(a.Addr), a.Port)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		node := &amp;Node&#123;</span><br><span class="line">			Name: a.Node,</span><br><span class="line">			Addr: a.Addr,</span><br><span class="line">			Port: a.Port,</span><br><span class="line">			Meta: a.Meta,</span><br><span class="line">			PMin: a.Vsn[<span class="number">0</span>],</span><br><span class="line">			PMax: a.Vsn[<span class="number">1</span>],</span><br><span class="line">			PCur: a.Vsn[<span class="number">2</span>],</span><br><span class="line">			DMin: a.Vsn[<span class="number">3</span>],</span><br><span class="line">			DMax: a.Vsn[<span class="number">4</span>],</span><br><span class="line">			DCur: a.Vsn[<span class="number">5</span>],</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err := m.config.Alive.NotifyAlive(node); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			m.logger.Printf(<span class="string">"[WARN] memberlist: ignoring alive message for '%s': %s"</span>,</span><br><span class="line">				a.Node, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check if we've never seen this node before, and if not, then</span></span><br><span class="line">	<span class="comment">// store this node in our node map.</span></span><br><span class="line">	<span class="keyword">var</span> updatesNode <span class="keyword">bool</span></span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		errCon := m.config.IPAllowed(a.Addr)</span><br><span class="line">		<span class="keyword">if</span> errCon != <span class="literal">nil</span> &#123;</span><br><span class="line">			m.logger.Printf(<span class="string">"[WARN] memberlist: Rejected node %s (%v): %s"</span>, a.Node, net.IP(a.Addr), errCon)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		state = &amp;nodeState&#123;</span><br><span class="line">			Node: Node&#123;</span><br><span class="line">				Name: a.Node,</span><br><span class="line">				Addr: a.Addr,</span><br><span class="line">				Port: a.Port,</span><br><span class="line">				Meta: a.Meta,</span><br><span class="line">			&#125;,</span><br><span class="line">			State: StateDead,</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(a.Vsn) &gt; <span class="number">5</span> &#123;</span><br><span class="line">			state.PMin = a.Vsn[<span class="number">0</span>]</span><br><span class="line">			state.PMax = a.Vsn[<span class="number">1</span>]</span><br><span class="line">			state.PCur = a.Vsn[<span class="number">2</span>]</span><br><span class="line">			state.DMin = a.Vsn[<span class="number">3</span>]</span><br><span class="line">			state.DMax = a.Vsn[<span class="number">4</span>]</span><br><span class="line">			state.DCur = a.Vsn[<span class="number">5</span>]</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Add to map</span></span><br><span class="line">		m.nodeMap[a.Node] = state</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Get a random offset. This is important to ensure</span></span><br><span class="line">		<span class="comment">// the failure detection bound is low on average. If all</span></span><br><span class="line">		<span class="comment">// nodes did an append, failure detection bound would be</span></span><br><span class="line">		<span class="comment">// very high.</span></span><br><span class="line">		n := <span class="built_in">len</span>(m.nodes)</span><br><span class="line">		offset := randomOffset(n)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Add at the end and swap with the node at the offset</span></span><br><span class="line">		m.nodes = <span class="built_in">append</span>(m.nodes, state)</span><br><span class="line">		m.nodes[offset], m.nodes[n] = m.nodes[n], m.nodes[offset]</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Update numNodes after we've added a new node</span></span><br><span class="line">		atomic.AddUint32(&amp;m.numNodes, <span class="number">1</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Check if this address is different than the existing node unless the old node is dead.</span></span><br><span class="line">		<span class="keyword">if</span> !bytes.Equal([]<span class="keyword">byte</span>(state.Addr), a.Addr) || state.Port != a.Port &#123;</span><br><span class="line">			errCon := m.config.IPAllowed(a.Addr)</span><br><span class="line">			<span class="keyword">if</span> errCon != <span class="literal">nil</span> &#123;</span><br><span class="line">				m.logger.Printf(<span class="string">"[WARN] memberlist: Rejected IP update from %v to %v for node %s: %s"</span>, a.Node, state.Addr, net.IP(a.Addr), errCon)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// If DeadNodeReclaimTime is configured, check if enough time has elapsed since the node died.</span></span><br><span class="line">			canReclaim := (m.config.DeadNodeReclaimTime &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">				time.Since(state.StateChange) &gt; m.config.DeadNodeReclaimTime)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Allow the address to be updated if a dead node is being replaced.</span></span><br><span class="line">			<span class="keyword">if</span> state.State == StateLeft || (state.State == StateDead &amp;&amp; canReclaim) &#123;</span><br><span class="line">				m.logger.Printf(<span class="string">"[INFO] memberlist: Updating address for left or failed node %s from %v:%d to %v:%d"</span>,</span><br><span class="line">					state.Name, state.Addr, state.Port, net.IP(a.Addr), a.Port)</span><br><span class="line">				updatesNode = <span class="literal">true</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				m.logger.Printf(<span class="string">"[ERR] memberlist: Conflicting address for %s. Mine: %v:%d Theirs: %v:%d Old state: %v"</span>,</span><br><span class="line">					state.Name, state.Addr, state.Port, net.IP(a.Addr), a.Port, state.State)</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Inform the conflict delegate if provided</span></span><br><span class="line">				<span class="keyword">if</span> m.config.Conflict != <span class="literal">nil</span> &#123;</span><br><span class="line">					other := Node&#123;</span><br><span class="line">						Name: a.Node,</span><br><span class="line">						Addr: a.Addr,</span><br><span class="line">						Port: a.Port,</span><br><span class="line">						Meta: a.Meta,</span><br><span class="line">					&#125;</span><br><span class="line">					m.config.Conflict.NotifyConflict(&amp;state.Node, &amp;other)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Bail if the incarnation number is older, and this is not about us</span></span><br><span class="line">	isLocalNode := state.Name == m.config.Name</span><br><span class="line">	<span class="keyword">if</span> a.Incarnation &lt;= state.Incarnation &amp;&amp; !isLocalNode &amp;&amp; !updatesNode &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Bail if strictly less and this is about us</span></span><br><span class="line">	<span class="keyword">if</span> a.Incarnation &lt; state.Incarnation &amp;&amp; isLocalNode &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Clear out any suspicion timer that may be in effect.</span></span><br><span class="line">	<span class="built_in">delete</span>(m.nodeTimers, a.Node)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Store the old state and meta data</span></span><br><span class="line">	oldState := state.State</span><br><span class="line">	oldMeta := state.Meta</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If this is us we need to refute, otherwise re-broadcast</span></span><br><span class="line">	<span class="keyword">if</span> !bootstrap &amp;&amp; isLocalNode &#123;</span><br><span class="line">		<span class="comment">// Compute the version vector</span></span><br><span class="line">		versions := []<span class="keyword">uint8</span>&#123;</span><br><span class="line">			state.PMin, state.PMax, state.PCur,</span><br><span class="line">			state.DMin, state.DMax, state.DCur,</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// If the Incarnation is the same, we need special handling, since it</span></span><br><span class="line">		<span class="comment">// possible for the following situation to happen:</span></span><br><span class="line">		<span class="comment">// 1) Start with configuration C, join cluster</span></span><br><span class="line">		<span class="comment">// 2) Hard fail / Kill / Shutdown</span></span><br><span class="line">		<span class="comment">// 3) Restart with configuration C', join cluster</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="comment">// In this case, other nodes and the local node see the same incarnation,</span></span><br><span class="line">		<span class="comment">// but the values may not be the same. For this reason, we always</span></span><br><span class="line">		<span class="comment">// need to do an equality check for this Incarnation. In most cases,</span></span><br><span class="line">		<span class="comment">// we just ignore, but we may need to refute.</span></span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		<span class="keyword">if</span> a.Incarnation == state.Incarnation &amp;&amp;</span><br><span class="line">			bytes.Equal(a.Meta, state.Meta) &amp;&amp;</span><br><span class="line">			bytes.Equal(a.Vsn, versions) &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		m.refute(state, a.Incarnation)</span><br><span class="line">		m.logger.Printf(<span class="string">"[WARN] memberlist: Refuting an alive message for '%s' (%v:%d) meta:(%v VS %v), vsn:(%v VS %v)"</span>, a.Node, net.IP(a.Addr), a.Port, a.Meta, state.Meta, a.Vsn, versions)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		m.encodeBroadcastNotify(a.Node, aliveMsg, a, notify)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Update protocol versions if it arrived</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(a.Vsn) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			state.PMin = a.Vsn[<span class="number">0</span>]</span><br><span class="line">			state.PMax = a.Vsn[<span class="number">1</span>]</span><br><span class="line">			state.PCur = a.Vsn[<span class="number">2</span>]</span><br><span class="line">			state.DMin = a.Vsn[<span class="number">3</span>]</span><br><span class="line">			state.DMax = a.Vsn[<span class="number">4</span>]</span><br><span class="line">			state.DCur = a.Vsn[<span class="number">5</span>]</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Update the state and incarnation number</span></span><br><span class="line">		state.Incarnation = a.Incarnation</span><br><span class="line">		state.Meta = a.Meta</span><br><span class="line">		state.Addr = a.Addr</span><br><span class="line">		state.Port = a.Port</span><br><span class="line">		<span class="keyword">if</span> state.State != StateAlive &#123;</span><br><span class="line">			state.State = StateAlive</span><br><span class="line">			state.StateChange = time.Now()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Update metrics</span></span><br><span class="line">	metrics.IncrCounter([]<span class="keyword">string</span>&#123;<span class="string">"memberlist"</span>, <span class="string">"msg"</span>, <span class="string">"alive"</span>&#125;, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Notify the delegate of any relevant updates</span></span><br><span class="line">	<span class="keyword">if</span> m.config.Events != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> oldState == StateDead || oldState == StateLeft &#123;</span><br><span class="line">			<span class="comment">// if Dead/Left -&gt; Alive, notify of join</span></span><br><span class="line">			m.config.Events.NotifyJoin(&amp;state.Node)</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> !bytes.Equal(oldMeta, state.Meta) &#123;</span><br><span class="line">			<span class="comment">// if Meta changed, trigger an update notification</span></span><br><span class="line">			m.config.Events.NotifyUpdate(&amp;state.Node)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>suspect: 当探测一些节点失败时，或者suspect某个节点的信息时，会将本地对应的信息标记为suspect，然后启动一个 定时器，并发出一个suspect广播，此期间内如果收到其他节点发来的相同的suspect信息时，将本地suspect的 确认数+1，当定时器超时后，该节点信息仍然不是alive的，且确认数达到要求，会将该节点标记为dead。 当本节点收到别的节点发来的suspect消息时，会发送alive广播，从而清除其他节点上的suspect标记。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// suspectNode is invoked by the network layer when we get a message</span></span><br><span class="line"><span class="comment">// about a suspect node</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Memberlist)</span> <span class="title">suspectNode</span><span class="params">(s *suspect)</span></span> &#123;</span><br><span class="line">	m.nodeLock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> m.nodeLock.Unlock()</span><br><span class="line">	state, ok := m.nodeMap[s.Node]</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If we've never heard about this node before, ignore it</span></span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Ignore old incarnation numbers</span></span><br><span class="line">	<span class="keyword">if</span> s.Incarnation &lt; state.Incarnation &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// See if there's a suspicion timer we can confirm. If the info is new</span></span><br><span class="line">	<span class="comment">// to us we will go ahead and re-gossip it. This allows for multiple</span></span><br><span class="line">	<span class="comment">// independent confirmations to flow even when a node probes a node</span></span><br><span class="line">	<span class="comment">// that's already suspect.</span></span><br><span class="line">	<span class="keyword">if</span> timer, ok := m.nodeTimers[s.Node]; ok &#123;</span><br><span class="line">		<span class="keyword">if</span> timer.Confirm(s.From) &#123;</span><br><span class="line">			m.encodeAndBroadcast(s.Node, suspectMsg, s)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Ignore non-alive nodes</span></span><br><span class="line">	<span class="keyword">if</span> state.State != StateAlive &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If this is us we need to refute, otherwise re-broadcast</span></span><br><span class="line">	<span class="keyword">if</span> state.Name == m.config.Name &#123;</span><br><span class="line">		m.refute(state, s.Incarnation)</span><br><span class="line">		m.logger.Printf(<span class="string">"[WARN] memberlist: Refuting a suspect message (from: %s)"</span>, s.From)</span><br><span class="line">		<span class="keyword">return</span> <span class="comment">// Do not mark ourself suspect</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		m.encodeAndBroadcast(s.Node, suspectMsg, s)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Update metrics</span></span><br><span class="line">	metrics.IncrCounter([]<span class="keyword">string</span>&#123;<span class="string">"memberlist"</span>, <span class="string">"msg"</span>, <span class="string">"suspect"</span>&#125;, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Update the state</span></span><br><span class="line">	state.Incarnation = s.Incarnation</span><br><span class="line">	state.State = StateSuspect</span><br><span class="line">	changeTime := time.Now()</span><br><span class="line">	state.StateChange = changeTime</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Setup a suspicion timer. Given that we don't have any known phase</span></span><br><span class="line">	<span class="comment">// relationship with our peers, we set up k such that we hit the nominal</span></span><br><span class="line">	<span class="comment">// timeout two probe intervals short of what we expect given the suspicion</span></span><br><span class="line">	<span class="comment">// multiplier.</span></span><br><span class="line">	k := m.config.SuspicionMult - <span class="number">2</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// If there aren't enough nodes to give the expected confirmations, just</span></span><br><span class="line">	<span class="comment">// set k to 0 to say that we don't expect any. Note we subtract 2 from n</span></span><br><span class="line">	<span class="comment">// here to take out ourselves and the node being probed.</span></span><br><span class="line">	n := m.estNumNodes()</span><br><span class="line">	<span class="keyword">if</span> n<span class="number">-2</span> &lt; k &#123;</span><br><span class="line">		k = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Compute the timeouts based on the size of the cluster.</span></span><br><span class="line">	min := suspicionTimeout(m.config.SuspicionMult, n, m.config.ProbeInterval)</span><br><span class="line">	max := time.Duration(m.config.SuspicionMaxTimeoutMult) * min</span><br><span class="line">	fn := <span class="function"><span class="keyword">func</span><span class="params">(numConfirmations <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">		m.nodeLock.Lock()</span><br><span class="line">		state, ok := m.nodeMap[s.Node]</span><br><span class="line">		timeout := ok &amp;&amp; state.State == StateSuspect &amp;&amp; state.StateChange == changeTime</span><br><span class="line">		m.nodeLock.Unlock()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> timeout &#123;</span><br><span class="line">			<span class="keyword">if</span> k &gt; <span class="number">0</span> &amp;&amp; numConfirmations &lt; k &#123;</span><br><span class="line">				metrics.IncrCounter([]<span class="keyword">string</span>&#123;<span class="string">"memberlist"</span>, <span class="string">"degraded"</span>, <span class="string">"timeout"</span>&#125;, <span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			m.logger.Printf(<span class="string">"[INFO] memberlist: Marking %s as failed, suspect timeout reached (%d peer confirmations)"</span>,</span><br><span class="line">				state.Name, numConfirmations)</span><br><span class="line">			d := dead&#123;Incarnation: state.Incarnation, Node: state.Name, From: m.config.Name&#125;</span><br><span class="line">			m.deadNode(&amp;d)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	m.nodeTimers[s.Node] = newSuspicion(s.From, k, min, max, fn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>dead: 当本节点离开集群时或者本地探测的其他节点超时被标记死亡，会向集群发送本节点dead广播。收到dead广播 消息的节点会跟本地的记录比较，当本地记录也是dead时会忽略消息，当本地的记录不是dead时，会删除本地 的记录再将dead消息再次广播出去，形成再次传播。 如果从其他节点收到自身的dead广播消息时，说明本节点相对于其他节点网络分区，此时会发起一个alive广播 以修正其他节点上存储的本节点数据。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// deadNode is invoked by the network layer when we get a message</span></span><br><span class="line"><span class="comment">// about a dead node</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Memberlist)</span> <span class="title">deadNode</span><span class="params">(d *dead)</span></span> &#123;</span><br><span class="line">	m.nodeLock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> m.nodeLock.Unlock()</span><br><span class="line">	state, ok := m.nodeMap[d.Node]</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If we've never heard about this node before, ignore it</span></span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Ignore old incarnation numbers</span></span><br><span class="line">	<span class="keyword">if</span> d.Incarnation &lt; state.Incarnation &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Clear out any suspicion timer that may be in effect.</span></span><br><span class="line">	<span class="built_in">delete</span>(m.nodeTimers, d.Node)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Ignore if node is already dead</span></span><br><span class="line">	<span class="keyword">if</span> state.DeadOrLeft() &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check if this is us</span></span><br><span class="line">	<span class="keyword">if</span> state.Name == m.config.Name &#123;</span><br><span class="line">		<span class="comment">// If we are not leaving we need to refute</span></span><br><span class="line">		<span class="keyword">if</span> !m.hasLeft() &#123;</span><br><span class="line">			m.refute(state, d.Incarnation)</span><br><span class="line">			m.logger.Printf(<span class="string">"[WARN] memberlist: Refuting a dead message (from: %s)"</span>, d.From)</span><br><span class="line">			<span class="keyword">return</span> <span class="comment">// Do not mark ourself dead</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// If we are leaving, we broadcast and wait</span></span><br><span class="line">		m.encodeBroadcastNotify(d.Node, deadMsg, d, m.leaveBroadcast)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		m.encodeAndBroadcast(d.Node, deadMsg, d)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Update metrics</span></span><br><span class="line">	metrics.IncrCounter([]<span class="keyword">string</span>&#123;<span class="string">"memberlist"</span>, <span class="string">"msg"</span>, <span class="string">"dead"</span>&#125;, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Update the state</span></span><br><span class="line">	state.Incarnation = d.Incarnation</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If the dead message was send by the node itself, mark it is left</span></span><br><span class="line">	<span class="comment">// instead of dead.</span></span><br><span class="line">	<span class="keyword">if</span> d.Node == d.From &#123;</span><br><span class="line">		state.State = StateLeft</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		state.State = StateDead</span><br><span class="line">	&#125;</span><br><span class="line">	state.StateChange = time.Now()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Notify of death</span></span><br><span class="line">	<span class="keyword">if</span> m.config.Events != <span class="literal">nil</span> &#123;</span><br><span class="line">		m.config.Events.NotifyLeave(&amp;state.Node)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="broadcast模块"><a href="#broadcast模块" class="headerlink" title="broadcast模块"></a>broadcast模块</h4><p>broadcast模块是广播模块，提供了三个函数，最主要的函数是 getBroadcasts，返回一个广播的最大size，主要是用于填充udp包。很简单代码如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getBroadcasts is used to return a slice of broadcasts to send up to</span></span><br><span class="line"><span class="comment">// a maximum byte size, while imposing a per-broadcast overhead. This is used</span></span><br><span class="line"><span class="comment">// to fill a UDP packet with piggybacked data</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Memberlist)</span> <span class="title">getBroadcasts</span><span class="params">(overhead, limit <span class="keyword">int</span>)</span> [][]<span class="title">byte</span></span> &#123;</span><br><span class="line">	<span class="comment">// Get memberlist messages first</span></span><br><span class="line">	toSend := m.broadcasts.GetBroadcasts(overhead, limit)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check if the user has anything to broadcast</span></span><br><span class="line">	d := m.config.Delegate</span><br><span class="line">	<span class="keyword">if</span> d != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Determine the bytes used already</span></span><br><span class="line">		bytesUsed := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> _, msg := <span class="keyword">range</span> toSend &#123;</span><br><span class="line">			bytesUsed += <span class="built_in">len</span>(msg) + overhead</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Check space remaining for user messages</span></span><br><span class="line">		avail := limit - bytesUsed</span><br><span class="line">		<span class="keyword">if</span> avail &gt; overhead+userMsgOverhead &#123;</span><br><span class="line">			userMsgs := d.GetBroadcasts(overhead+userMsgOverhead, avail)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Frame each user message</span></span><br><span class="line">			<span class="keyword">for</span> _, msg := <span class="keyword">range</span> userMsgs &#123;</span><br><span class="line">				buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1</span>, <span class="built_in">len</span>(msg)+<span class="number">1</span>)</span><br><span class="line">				buf[<span class="number">0</span>] = <span class="keyword">byte</span>(userMsg)</span><br><span class="line">				buf = <span class="built_in">append</span>(buf, msg...)</span><br><span class="line">				toSend = <span class="built_in">append</span>(toSend, buf)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> toSend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>回忆一下总体流程：</p>
<ul>
<li><p>项目在memberlist.go 函数Create启动，调用sate.go中函数schedule</p>
</li>
<li><p>Schedule函数开启probe协程、pushpull协程、gossip协程</p>
</li>
<li><p>probe协程：进行节点状态维护</p>
</li>
<li><p>push/pull协程：进行节点状态、用户数据同步</p>
</li>
<li><p>gossip协程：进行udp广播发送消息。</p>
</li>
</ul>
<p>memberlist利用点对点随机探测机制实现成员的故障检测，因此将节点的状态分为3种：</p>
<ul>
<li>StateAlive：活动节点</li>
<li>StateSuspect：可疑节点</li>
<li>StateDead：死亡节点</li>
</ul>
<p>probe协程通过点对点随机探测实现成员的故障检测，强化系统的高可用。整体流程如下：</p>
<ul>
<li>随机探测：节点启动后，每隔一定时间间隔，会选取一个节点对其发送PING消息。</li>
<li>重试与间隔探测请求：PING消息失败后，会随机选取N（由config中IndirectChecks设置）个节点发起间接PING请求和再发起一个TCP PING消息。</li>
<li>间隔探测：收到间接PING请求的节点会根据请求中的地址发起一个PING消息，将PING的结果返回给间接请求的源节点。</li>
<li>探测超时标识可疑：如果探测超时之间内，本节点没有收到任何一个要探测节点的ACK消息，则标记要探测的节点状态为suspect。</li>
<li>可疑节点广播：启动一个定时器用于发出一个suspect广播，此期间内如果收到其他节点发来的相同的suspect信息时，将本地suspect的 确认数+1，当定时器超时后，该节点信息仍然不是alive的，且确认数达到要求，会将该节点标记为dead。</li>
<li>可疑消除：当本节点收到别的节点发来的suspect消息时，会发送alive广播，从而清除其他节点上的suspect标记。。</li>
<li>死亡通知:当本节点离开集群时或者本地探测的其他节点超时被标记死亡，会向集群发送本节点dead广播</li>
<li>死亡消除:如果从其他节点收到自身的dead广播消息时，说明本节点相对于其他节点网络分区，此时会发起一个alive广播以修正其他节点上存储的本节点数据。</li>
</ul>
<p>Memberlist在整个生命周期内，总的有两种类型的消息：</p>
<ul>
<li><strong>udp**</strong>协议消息：**传输PING消息、间接PING消息、ACK消息、NACK消息、Suspect消息、 Alive消息、Dead消息、消息广播；</li>
<li><strong>tcp协议消息：</strong>用户数据同步、节点状态同步、PUSH-PULL消息。</li>
</ul>
<p>push/pull协程周期性的从已知的alive的集群节点中选1个节点进行push/pull交换信息。交换的信息包含2种：</p>
<ul>
<li>集群信息：节点数据</li>
<li>用户自定义的信息：实现Delegate接口的struct。</li>
</ul>
<p>push/pull协程可以加速集群内信息的收敛速度，整体流程为：</p>
<ul>
<li>建立TCP链接：每隔一个时间间隔，随机选取一个节点，跟它建立tcp连接，</li>
<li>将本地的全部节点 状态、用户数据发送过去，</li>
<li>对端将其掌握的全部节点状态、用户数据发送回来，然后完成2份数据的合并。</li>
</ul>
<p>Gossip协程通过udp协议向K个节点发送消息，节点从广播队列里面获取消息，广播队列里的消息发送失败超过一定次数后，消息就会被丢弃。</p>
<p>参考：</p>
<p><a href="https://yunlzheng.gitbook.io/prometheus-book/part-ii-prometheus-jin-jie/readmd/alertmanager-high-availability" target="_blank" rel="external">Alertmanager高可用</a></p>
<p><a href="https://blog.csdn.net/jianxian89/article/details/107482423" target="_blank" rel="external">一致性算法-Gossip协议实践(Memberlist)</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

<blockquote class="blockquote-center" style="color: #ccc;">
    -------------本文结束 <i class="fa fa-apple"></i> 感谢您的阅读-------------
</blockquote>

  <span id="inline-green" style="border-radius:3px;">作者</span>：<a class="link-blue" href="https://github.com/magiceses" target="_blank">Magiceses</a><br/>有问题请 <a class="link-blue" href="https://magiceses.github.io/guestbook" target="_blank">留言</a> 或者私信我的 <a class="link-blue" href="https://weibo.com/u/3069595351" target="_blank">微博</a>。

  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>满分是10分的话，这篇文章你给几分</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/reward/reward_wechat.png" alt="magiceses WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/reward/reward_alipay.png" alt="magiceses Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Prometheus/" rel="tag"><i class="fa fa-tag"></i> Prometheus</a>
          
            <a href="/tags/Alertmanager/" rel="tag"><i class="fa fa-tag"></i> Alertmanager</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/12/14/prometheus-alertmanager-高可用总结-下/" rel="next" title="Alertmanager 高可用总结-下">
                <i class="fa fa-chevron-left"></i> Alertmanager 高可用总结-下
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
  <a class="jiathis_button_tsina"></a>
  <a class="jiathis_button_tqq"></a>
  <a class="jiathis_button_weixin"></a>
  <a class="jiathis_button_cqq"></a>
  <a class="jiathis_button_douban"></a>
  <a class="jiathis_button_renren"></a>
  <a class="jiathis_button_qzone"></a>
  <a class="jiathis_button_kaixin001"></a>
  <a class="jiathis_button_copy"></a>
  <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
  <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
  var jiathis_config={
    hideMore:false
  }
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    </div>
  </div>


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/avatar/avatar.png"
               alt="magiceses" />
          <p class="site-author-name" itemprop="name">magiceses</p>
          <p class="site-description motion-element" itemprop="description">Stay Hungry,Stay Foolish</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">61</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/magiceses" target="_blank" title="Github">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  Github
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://blog.csdn.net/weixin_43700106" target="_blank" title="CSDN">
                  
                    <i class="fa fa-fw fa-chrome"></i>
                  
                  CSDN
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="/weblog" title="建站日志" target="_blank">建站日志</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="/reward" title="打赏" target="_blank">打赏</a>
                </li>
              
            </ul>
          </div>
        
      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#高可用简介"><span class="nav-number">1.</span> <span class="nav-text">高可用简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Gossip协议"><span class="nav-number">2.</span> <span class="nav-text">Gossip协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Gossip-的特点（优势）"><span class="nav-number">2.1.</span> <span class="nav-text">Gossip 的特点（优势）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Gossip-的缺陷"><span class="nav-number">2.2.</span> <span class="nav-text">Gossip 的缺陷</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Gossip-类型"><span class="nav-number">2.3.</span> <span class="nav-text">Gossip 类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Gossip-中的通信模式"><span class="nav-number">2.4.</span> <span class="nav-text">Gossip 中的通信模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复杂度分析"><span class="nav-number">2.5.</span> <span class="nav-text">复杂度分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高可用方案"><span class="nav-number">3.</span> <span class="nav-text">高可用方案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高可用源码分析"><span class="nav-number">4.</span> <span class="nav-text">高可用源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#集群启动"><span class="nav-number">4.1.</span> <span class="nav-text">集群启动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#memberlist"><span class="nav-number">4.2.</span> <span class="nav-text">memberlist</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Memberlist-结构体"><span class="nav-number">4.2.1.</span> <span class="nav-text">Memberlist 结构体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Config-结构体"><span class="nav-number">4.2.2.</span> <span class="nav-text">Config 结构体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#从create开始"><span class="nav-number">4.2.3.</span> <span class="nav-text">从create开始</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#newMemberlist"><span class="nav-number">4.2.4.</span> <span class="nav-text">newMemberlist</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#TCP-处理"><span class="nav-number">4.2.4.1.</span> <span class="nav-text">TCP 处理</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#readRemoteState"><span class="nav-number">4.2.4.1.1.</span> <span class="nav-text">readRemoteState</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#sendLocalState"><span class="nav-number">4.2.4.1.2.</span> <span class="nav-text">sendLocalState</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#mergeRemoteState"><span class="nav-number">4.2.4.1.3.</span> <span class="nav-text">mergeRemoteState</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#UDP-处理"><span class="nav-number">4.2.4.2.</span> <span class="nav-text">UDP 处理</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#handleCommand"><span class="nav-number">4.2.4.2.1.</span> <span class="nav-text">handleCommand</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#schedule"><span class="nav-number">4.2.5.</span> <span class="nav-text">schedule</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#probe"><span class="nav-number">4.2.5.1.</span> <span class="nav-text">probe</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#pushpull"><span class="nav-number">4.2.5.2.</span> <span class="nav-text">pushpull</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#gossip"><span class="nav-number">4.2.5.3.</span> <span class="nav-text">gossip</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#broadcast模块"><span class="nav-number">4.2.6.</span> <span class="nav-text">broadcast模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-number">4.2.7.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li></ol></div>
            
          </div>
        </section>
      

      
    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        

<div class="busuanzi-count">

  <!-- <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script> -->
  <!-- 上面这个是之前的，不知道为什么失效了，改成下面这个 -->
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">您是第<span class="busuanzi-value" id="busuanzi_value_site_uv"></span>个小伙伴</span>
  

  
    <span class="site-pv">本站总浏览<span class="busuanzi-value" id="busuanzi_value_site_pv"></span>次</span>
  
  
</div>



        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">magiceses</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io" rel="external nofollow">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next" rel="external nofollow">
    NexT.Pisces
  </a>
</div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count" style="color: #e90f92;">全站共 1m 字</span>
</div>
        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = true;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = data.url;
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '' && data_content != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title < 0 && index_content < 0 ){
                                isMatch = false;
                            } else {
                                if (index_content < 0) {
                                    index_content = 0;
                                }
                                if (i == 0) {
                                    first_occur = index_content;
                                }
                            }
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });

                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  
<script type="text/javascript" async src="//push.zhanzhang.baidu.com/push.js">
</script>


  <!-- 按需加载背景 -->
  <!-- 背景动画 -->
<script type="text/javascript">
  // 按需加载背景
  // 如果是all，就直接加载了
  if("pc" == "all") {
    $.getScript("/js/src/particle.js?v=5.0.1");
  }
  // 识别手机或电脑的js开始
  (function(){
    var res = GetRequest();
    var par = res['index'];
    if(par!='gfan'){
      var ua=navigator.userAgent.toLowerCase();
      var contains=function (a, b){
          if(a.indexOf(b)!=-1){return true;}
      };
      if((contains(ua,"android") && contains(ua,"mobile"))||(contains(ua,"android") && contains(ua,"mozilla"))||(contains(ua,"android") && contains(ua,"opera"))||contains(ua,"ucweb7")||contains(ua,"iphone")){
        return false;
      } else {
        $.getScript("/js/src/particle.js?v=5.0.1");
      }
    }
  })();
  function GetRequest() {
    var url = location.search;
    var theRequest = new Object();
    if (url.indexOf("?") != -1) {
      var str = url.substr(1);
      strs = str.split("&");
      for(var i = 0; i < strs.length; i ++) {
        theRequest[strs[i].split("=")[0]]=unescape(strs[i].split("=")[1]);
      }
    }
    return theRequest;
  }
</script>
<!-- 识别手机或电脑的js结束 -->  

  <!-- 页面点击小红心 -->
  <!-- 页面点击小红心 -->

  <script type="text/javascript" src="/js/src/love.js?v=5.0.1"></script>


  <!-- 鼠标移动，效果 -->
  <!-- 鼠标移动特效 -->

  <script type="text/javascript" src="/js/src/jquery-stars.js?v=5.0.1"></script>
  <script type="text/javascript">
  jQuery('body').jstars({
  	image_path: '/images',
  	image: 'candy-cane-stars.png',
  	style: 'white',
  	width: 34,
  	height: 34,
  	delay: 700,
  	frequency: 5
  });
  </script>


  <!-- 页面 title 进入/离开 效果 -->

  <script type="text/javascript">var OriginTitile=document.title,st;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="Waiting for you back！",clearTimeout(st)):(document.title="Thanks for visit~ "+OriginTitile,st=setTimeout(function(){document.title=OriginTitile},4e3))})</script>


</body>
</html>
